// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"crm/biz/dal/db/ent/followupplan"
	"crm/biz/dal/db/ent/followuprecord"
	"crm/biz/dal/db/ent/opportunities"
	"crm/biz/dal/db/ent/predicate"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeFollowUpPlan   = "FollowUpPlan"
	TypeFollowUpRecord = "FollowUpRecord"
	TypeOpportunities  = "Opportunities"
)

// FollowUpPlanMutation represents an operation that mutates the FollowUpPlan nodes in the graph.
type FollowUpPlanMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	content       *string
	time          *time.Time
	member_id     *int64
	addmember_id  *int64
	user_id       *int64
	adduser_id    *int64
	division      *int64
	adddivision   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FollowUpPlan, error)
	predicates    []predicate.FollowUpPlan
}

var _ ent.Mutation = (*FollowUpPlanMutation)(nil)

// followupplanOption allows management of the mutation configuration using functional options.
type followupplanOption func(*FollowUpPlanMutation)

// newFollowUpPlanMutation creates new mutation for the FollowUpPlan entity.
func newFollowUpPlanMutation(c config, op Op, opts ...followupplanOption) *FollowUpPlanMutation {
	m := &FollowUpPlanMutation{
		config:        c,
		op:            op,
		typ:           TypeFollowUpPlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFollowUpPlanID sets the ID field of the mutation.
func withFollowUpPlanID(id int64) followupplanOption {
	return func(m *FollowUpPlanMutation) {
		var (
			err   error
			once  sync.Once
			value *FollowUpPlan
		)
		m.oldValue = func(ctx context.Context) (*FollowUpPlan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FollowUpPlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFollowUpPlan sets the old FollowUpPlan of the mutation.
func withFollowUpPlan(node *FollowUpPlan) followupplanOption {
	return func(m *FollowUpPlanMutation) {
		m.oldValue = func(context.Context) (*FollowUpPlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FollowUpPlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FollowUpPlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FollowUpPlan entities.
func (m *FollowUpPlanMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FollowUpPlanMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FollowUpPlanMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FollowUpPlan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FollowUpPlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FollowUpPlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FollowUpPlan entity.
// If the FollowUpPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpPlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *FollowUpPlanMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[followupplan.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *FollowUpPlanMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[followupplan.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FollowUpPlanMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, followupplan.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FollowUpPlanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FollowUpPlanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FollowUpPlan entity.
// If the FollowUpPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpPlanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *FollowUpPlanMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[followupplan.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *FollowUpPlanMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[followupplan.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FollowUpPlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, followupplan.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *FollowUpPlanMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *FollowUpPlanMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the FollowUpPlan entity.
// If the FollowUpPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpPlanMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *FollowUpPlanMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *FollowUpPlanMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *FollowUpPlanMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[followupplan.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *FollowUpPlanMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[followupplan.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *FollowUpPlanMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, followupplan.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *FollowUpPlanMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *FollowUpPlanMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the FollowUpPlan entity.
// If the FollowUpPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpPlanMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *FollowUpPlanMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *FollowUpPlanMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *FollowUpPlanMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[followupplan.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *FollowUpPlanMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[followupplan.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *FollowUpPlanMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, followupplan.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *FollowUpPlanMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *FollowUpPlanMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FollowUpPlan entity.
// If the FollowUpPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpPlanMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *FollowUpPlanMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *FollowUpPlanMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *FollowUpPlanMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[followupplan.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *FollowUpPlanMutation) StatusCleared() bool {
	_, ok := m.clearedFields[followupplan.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *FollowUpPlanMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, followupplan.FieldStatus)
}

// SetContent sets the "content" field.
func (m *FollowUpPlanMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *FollowUpPlanMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the FollowUpPlan entity.
// If the FollowUpPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpPlanMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *FollowUpPlanMutation) ClearContent() {
	m.content = nil
	m.clearedFields[followupplan.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *FollowUpPlanMutation) ContentCleared() bool {
	_, ok := m.clearedFields[followupplan.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *FollowUpPlanMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, followupplan.FieldContent)
}

// SetTime sets the "time" field.
func (m *FollowUpPlanMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *FollowUpPlanMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the FollowUpPlan entity.
// If the FollowUpPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpPlanMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ClearTime clears the value of the "time" field.
func (m *FollowUpPlanMutation) ClearTime() {
	m.time = nil
	m.clearedFields[followupplan.FieldTime] = struct{}{}
}

// TimeCleared returns if the "time" field was cleared in this mutation.
func (m *FollowUpPlanMutation) TimeCleared() bool {
	_, ok := m.clearedFields[followupplan.FieldTime]
	return ok
}

// ResetTime resets all changes to the "time" field.
func (m *FollowUpPlanMutation) ResetTime() {
	m.time = nil
	delete(m.clearedFields, followupplan.FieldTime)
}

// SetMemberID sets the "member_id" field.
func (m *FollowUpPlanMutation) SetMemberID(i int64) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *FollowUpPlanMutation) MemberID() (r int64, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the FollowUpPlan entity.
// If the FollowUpPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpPlanMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *FollowUpPlanMutation) AddMemberID(i int64) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *FollowUpPlanMutation) AddedMemberID() (r int64, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *FollowUpPlanMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[followupplan.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *FollowUpPlanMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[followupplan.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *FollowUpPlanMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, followupplan.FieldMemberID)
}

// SetUserID sets the "user_id" field.
func (m *FollowUpPlanMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FollowUpPlanMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the FollowUpPlan entity.
// If the FollowUpPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpPlanMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *FollowUpPlanMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *FollowUpPlanMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *FollowUpPlanMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[followupplan.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *FollowUpPlanMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[followupplan.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FollowUpPlanMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, followupplan.FieldUserID)
}

// SetDivision sets the "division" field.
func (m *FollowUpPlanMutation) SetDivision(i int64) {
	m.division = &i
	m.adddivision = nil
}

// Division returns the value of the "division" field in the mutation.
func (m *FollowUpPlanMutation) Division() (r int64, exists bool) {
	v := m.division
	if v == nil {
		return
	}
	return *v, true
}

// OldDivision returns the old "division" field's value of the FollowUpPlan entity.
// If the FollowUpPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpPlanMutation) OldDivision(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivision: %w", err)
	}
	return oldValue.Division, nil
}

// AddDivision adds i to the "division" field.
func (m *FollowUpPlanMutation) AddDivision(i int64) {
	if m.adddivision != nil {
		*m.adddivision += i
	} else {
		m.adddivision = &i
	}
}

// AddedDivision returns the value that was added to the "division" field in this mutation.
func (m *FollowUpPlanMutation) AddedDivision() (r int64, exists bool) {
	v := m.adddivision
	if v == nil {
		return
	}
	return *v, true
}

// ClearDivision clears the value of the "division" field.
func (m *FollowUpPlanMutation) ClearDivision() {
	m.division = nil
	m.adddivision = nil
	m.clearedFields[followupplan.FieldDivision] = struct{}{}
}

// DivisionCleared returns if the "division" field was cleared in this mutation.
func (m *FollowUpPlanMutation) DivisionCleared() bool {
	_, ok := m.clearedFields[followupplan.FieldDivision]
	return ok
}

// ResetDivision resets all changes to the "division" field.
func (m *FollowUpPlanMutation) ResetDivision() {
	m.division = nil
	m.adddivision = nil
	delete(m.clearedFields, followupplan.FieldDivision)
}

// Where appends a list predicates to the FollowUpPlanMutation builder.
func (m *FollowUpPlanMutation) Where(ps ...predicate.FollowUpPlan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FollowUpPlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FollowUpPlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FollowUpPlan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FollowUpPlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FollowUpPlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FollowUpPlan).
func (m *FollowUpPlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FollowUpPlanMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, followupplan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, followupplan.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, followupplan.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, followupplan.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, followupplan.FieldStatus)
	}
	if m.content != nil {
		fields = append(fields, followupplan.FieldContent)
	}
	if m.time != nil {
		fields = append(fields, followupplan.FieldTime)
	}
	if m.member_id != nil {
		fields = append(fields, followupplan.FieldMemberID)
	}
	if m.user_id != nil {
		fields = append(fields, followupplan.FieldUserID)
	}
	if m.division != nil {
		fields = append(fields, followupplan.FieldDivision)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FollowUpPlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case followupplan.FieldCreatedAt:
		return m.CreatedAt()
	case followupplan.FieldUpdatedAt:
		return m.UpdatedAt()
	case followupplan.FieldDelete:
		return m.Delete()
	case followupplan.FieldCreatedID:
		return m.CreatedID()
	case followupplan.FieldStatus:
		return m.Status()
	case followupplan.FieldContent:
		return m.Content()
	case followupplan.FieldTime:
		return m.Time()
	case followupplan.FieldMemberID:
		return m.MemberID()
	case followupplan.FieldUserID:
		return m.UserID()
	case followupplan.FieldDivision:
		return m.Division()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FollowUpPlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case followupplan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case followupplan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case followupplan.FieldDelete:
		return m.OldDelete(ctx)
	case followupplan.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case followupplan.FieldStatus:
		return m.OldStatus(ctx)
	case followupplan.FieldContent:
		return m.OldContent(ctx)
	case followupplan.FieldTime:
		return m.OldTime(ctx)
	case followupplan.FieldMemberID:
		return m.OldMemberID(ctx)
	case followupplan.FieldUserID:
		return m.OldUserID(ctx)
	case followupplan.FieldDivision:
		return m.OldDivision(ctx)
	}
	return nil, fmt.Errorf("unknown FollowUpPlan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FollowUpPlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case followupplan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case followupplan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case followupplan.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case followupplan.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case followupplan.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case followupplan.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case followupplan.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case followupplan.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case followupplan.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case followupplan.FieldDivision:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivision(v)
		return nil
	}
	return fmt.Errorf("unknown FollowUpPlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FollowUpPlanMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, followupplan.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, followupplan.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, followupplan.FieldStatus)
	}
	if m.addmember_id != nil {
		fields = append(fields, followupplan.FieldMemberID)
	}
	if m.adduser_id != nil {
		fields = append(fields, followupplan.FieldUserID)
	}
	if m.adddivision != nil {
		fields = append(fields, followupplan.FieldDivision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FollowUpPlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case followupplan.FieldDelete:
		return m.AddedDelete()
	case followupplan.FieldCreatedID:
		return m.AddedCreatedID()
	case followupplan.FieldStatus:
		return m.AddedStatus()
	case followupplan.FieldMemberID:
		return m.AddedMemberID()
	case followupplan.FieldUserID:
		return m.AddedUserID()
	case followupplan.FieldDivision:
		return m.AddedDivision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FollowUpPlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case followupplan.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case followupplan.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case followupplan.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case followupplan.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	case followupplan.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case followupplan.FieldDivision:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDivision(v)
		return nil
	}
	return fmt.Errorf("unknown FollowUpPlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FollowUpPlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(followupplan.FieldCreatedAt) {
		fields = append(fields, followupplan.FieldCreatedAt)
	}
	if m.FieldCleared(followupplan.FieldUpdatedAt) {
		fields = append(fields, followupplan.FieldUpdatedAt)
	}
	if m.FieldCleared(followupplan.FieldDelete) {
		fields = append(fields, followupplan.FieldDelete)
	}
	if m.FieldCleared(followupplan.FieldCreatedID) {
		fields = append(fields, followupplan.FieldCreatedID)
	}
	if m.FieldCleared(followupplan.FieldStatus) {
		fields = append(fields, followupplan.FieldStatus)
	}
	if m.FieldCleared(followupplan.FieldContent) {
		fields = append(fields, followupplan.FieldContent)
	}
	if m.FieldCleared(followupplan.FieldTime) {
		fields = append(fields, followupplan.FieldTime)
	}
	if m.FieldCleared(followupplan.FieldMemberID) {
		fields = append(fields, followupplan.FieldMemberID)
	}
	if m.FieldCleared(followupplan.FieldUserID) {
		fields = append(fields, followupplan.FieldUserID)
	}
	if m.FieldCleared(followupplan.FieldDivision) {
		fields = append(fields, followupplan.FieldDivision)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FollowUpPlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FollowUpPlanMutation) ClearField(name string) error {
	switch name {
	case followupplan.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case followupplan.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case followupplan.FieldDelete:
		m.ClearDelete()
		return nil
	case followupplan.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case followupplan.FieldStatus:
		m.ClearStatus()
		return nil
	case followupplan.FieldContent:
		m.ClearContent()
		return nil
	case followupplan.FieldTime:
		m.ClearTime()
		return nil
	case followupplan.FieldMemberID:
		m.ClearMemberID()
		return nil
	case followupplan.FieldUserID:
		m.ClearUserID()
		return nil
	case followupplan.FieldDivision:
		m.ClearDivision()
		return nil
	}
	return fmt.Errorf("unknown FollowUpPlan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FollowUpPlanMutation) ResetField(name string) error {
	switch name {
	case followupplan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case followupplan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case followupplan.FieldDelete:
		m.ResetDelete()
		return nil
	case followupplan.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case followupplan.FieldStatus:
		m.ResetStatus()
		return nil
	case followupplan.FieldContent:
		m.ResetContent()
		return nil
	case followupplan.FieldTime:
		m.ResetTime()
		return nil
	case followupplan.FieldMemberID:
		m.ResetMemberID()
		return nil
	case followupplan.FieldUserID:
		m.ResetUserID()
		return nil
	case followupplan.FieldDivision:
		m.ResetDivision()
		return nil
	}
	return fmt.Errorf("unknown FollowUpPlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FollowUpPlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FollowUpPlanMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FollowUpPlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FollowUpPlanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FollowUpPlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FollowUpPlanMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FollowUpPlanMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FollowUpPlan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FollowUpPlanMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FollowUpPlan edge %s", name)
}

// FollowUpRecordMutation represents an operation that mutates the FollowUpRecord nodes in the graph.
type FollowUpRecordMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	created_at          *time.Time
	updated_at          *time.Time
	delete              *int64
	adddelete           *int64
	created_id          *int64
	addcreated_id       *int64
	status              *int64
	addstatus           *int64
	content             *string
	follow_up_id        *int64
	addfollow_up_id     *int64
	method              *int64
	addmethod           *int64
	user_id             *int64
	adduser_id          *int64
	division            *int64
	adddivision         *int64
	opportunities_id    *int64
	addopportunities_id *int64
	record              *string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*FollowUpRecord, error)
	predicates          []predicate.FollowUpRecord
}

var _ ent.Mutation = (*FollowUpRecordMutation)(nil)

// followuprecordOption allows management of the mutation configuration using functional options.
type followuprecordOption func(*FollowUpRecordMutation)

// newFollowUpRecordMutation creates new mutation for the FollowUpRecord entity.
func newFollowUpRecordMutation(c config, op Op, opts ...followuprecordOption) *FollowUpRecordMutation {
	m := &FollowUpRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeFollowUpRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFollowUpRecordID sets the ID field of the mutation.
func withFollowUpRecordID(id int64) followuprecordOption {
	return func(m *FollowUpRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *FollowUpRecord
		)
		m.oldValue = func(ctx context.Context) (*FollowUpRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FollowUpRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFollowUpRecord sets the old FollowUpRecord of the mutation.
func withFollowUpRecord(node *FollowUpRecord) followuprecordOption {
	return func(m *FollowUpRecordMutation) {
		m.oldValue = func(context.Context) (*FollowUpRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FollowUpRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FollowUpRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FollowUpRecord entities.
func (m *FollowUpRecordMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FollowUpRecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FollowUpRecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FollowUpRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FollowUpRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FollowUpRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FollowUpRecord entity.
// If the FollowUpRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *FollowUpRecordMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[followuprecord.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *FollowUpRecordMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[followuprecord.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FollowUpRecordMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, followuprecord.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FollowUpRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FollowUpRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FollowUpRecord entity.
// If the FollowUpRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *FollowUpRecordMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[followuprecord.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *FollowUpRecordMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[followuprecord.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FollowUpRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, followuprecord.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *FollowUpRecordMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *FollowUpRecordMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the FollowUpRecord entity.
// If the FollowUpRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpRecordMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *FollowUpRecordMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *FollowUpRecordMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *FollowUpRecordMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[followuprecord.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *FollowUpRecordMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[followuprecord.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *FollowUpRecordMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, followuprecord.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *FollowUpRecordMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *FollowUpRecordMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the FollowUpRecord entity.
// If the FollowUpRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpRecordMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *FollowUpRecordMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *FollowUpRecordMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *FollowUpRecordMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[followuprecord.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *FollowUpRecordMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[followuprecord.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *FollowUpRecordMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, followuprecord.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *FollowUpRecordMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *FollowUpRecordMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FollowUpRecord entity.
// If the FollowUpRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpRecordMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *FollowUpRecordMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *FollowUpRecordMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *FollowUpRecordMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[followuprecord.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *FollowUpRecordMutation) StatusCleared() bool {
	_, ok := m.clearedFields[followuprecord.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *FollowUpRecordMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, followuprecord.FieldStatus)
}

// SetContent sets the "content" field.
func (m *FollowUpRecordMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *FollowUpRecordMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the FollowUpRecord entity.
// If the FollowUpRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpRecordMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *FollowUpRecordMutation) ClearContent() {
	m.content = nil
	m.clearedFields[followuprecord.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *FollowUpRecordMutation) ContentCleared() bool {
	_, ok := m.clearedFields[followuprecord.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *FollowUpRecordMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, followuprecord.FieldContent)
}

// SetFollowUpID sets the "follow_up_id" field.
func (m *FollowUpRecordMutation) SetFollowUpID(i int64) {
	m.follow_up_id = &i
	m.addfollow_up_id = nil
}

// FollowUpID returns the value of the "follow_up_id" field in the mutation.
func (m *FollowUpRecordMutation) FollowUpID() (r int64, exists bool) {
	v := m.follow_up_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowUpID returns the old "follow_up_id" field's value of the FollowUpRecord entity.
// If the FollowUpRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpRecordMutation) OldFollowUpID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowUpID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowUpID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowUpID: %w", err)
	}
	return oldValue.FollowUpID, nil
}

// AddFollowUpID adds i to the "follow_up_id" field.
func (m *FollowUpRecordMutation) AddFollowUpID(i int64) {
	if m.addfollow_up_id != nil {
		*m.addfollow_up_id += i
	} else {
		m.addfollow_up_id = &i
	}
}

// AddedFollowUpID returns the value that was added to the "follow_up_id" field in this mutation.
func (m *FollowUpRecordMutation) AddedFollowUpID() (r int64, exists bool) {
	v := m.addfollow_up_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFollowUpID clears the value of the "follow_up_id" field.
func (m *FollowUpRecordMutation) ClearFollowUpID() {
	m.follow_up_id = nil
	m.addfollow_up_id = nil
	m.clearedFields[followuprecord.FieldFollowUpID] = struct{}{}
}

// FollowUpIDCleared returns if the "follow_up_id" field was cleared in this mutation.
func (m *FollowUpRecordMutation) FollowUpIDCleared() bool {
	_, ok := m.clearedFields[followuprecord.FieldFollowUpID]
	return ok
}

// ResetFollowUpID resets all changes to the "follow_up_id" field.
func (m *FollowUpRecordMutation) ResetFollowUpID() {
	m.follow_up_id = nil
	m.addfollow_up_id = nil
	delete(m.clearedFields, followuprecord.FieldFollowUpID)
}

// SetMethod sets the "method" field.
func (m *FollowUpRecordMutation) SetMethod(i int64) {
	m.method = &i
	m.addmethod = nil
}

// Method returns the value of the "method" field in the mutation.
func (m *FollowUpRecordMutation) Method() (r int64, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the FollowUpRecord entity.
// If the FollowUpRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpRecordMutation) OldMethod(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// AddMethod adds i to the "method" field.
func (m *FollowUpRecordMutation) AddMethod(i int64) {
	if m.addmethod != nil {
		*m.addmethod += i
	} else {
		m.addmethod = &i
	}
}

// AddedMethod returns the value that was added to the "method" field in this mutation.
func (m *FollowUpRecordMutation) AddedMethod() (r int64, exists bool) {
	v := m.addmethod
	if v == nil {
		return
	}
	return *v, true
}

// ClearMethod clears the value of the "method" field.
func (m *FollowUpRecordMutation) ClearMethod() {
	m.method = nil
	m.addmethod = nil
	m.clearedFields[followuprecord.FieldMethod] = struct{}{}
}

// MethodCleared returns if the "method" field was cleared in this mutation.
func (m *FollowUpRecordMutation) MethodCleared() bool {
	_, ok := m.clearedFields[followuprecord.FieldMethod]
	return ok
}

// ResetMethod resets all changes to the "method" field.
func (m *FollowUpRecordMutation) ResetMethod() {
	m.method = nil
	m.addmethod = nil
	delete(m.clearedFields, followuprecord.FieldMethod)
}

// SetUserID sets the "user_id" field.
func (m *FollowUpRecordMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FollowUpRecordMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the FollowUpRecord entity.
// If the FollowUpRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpRecordMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *FollowUpRecordMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *FollowUpRecordMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *FollowUpRecordMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[followuprecord.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *FollowUpRecordMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[followuprecord.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FollowUpRecordMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, followuprecord.FieldUserID)
}

// SetDivision sets the "division" field.
func (m *FollowUpRecordMutation) SetDivision(i int64) {
	m.division = &i
	m.adddivision = nil
}

// Division returns the value of the "division" field in the mutation.
func (m *FollowUpRecordMutation) Division() (r int64, exists bool) {
	v := m.division
	if v == nil {
		return
	}
	return *v, true
}

// OldDivision returns the old "division" field's value of the FollowUpRecord entity.
// If the FollowUpRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpRecordMutation) OldDivision(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDivision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDivision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDivision: %w", err)
	}
	return oldValue.Division, nil
}

// AddDivision adds i to the "division" field.
func (m *FollowUpRecordMutation) AddDivision(i int64) {
	if m.adddivision != nil {
		*m.adddivision += i
	} else {
		m.adddivision = &i
	}
}

// AddedDivision returns the value that was added to the "division" field in this mutation.
func (m *FollowUpRecordMutation) AddedDivision() (r int64, exists bool) {
	v := m.adddivision
	if v == nil {
		return
	}
	return *v, true
}

// ClearDivision clears the value of the "division" field.
func (m *FollowUpRecordMutation) ClearDivision() {
	m.division = nil
	m.adddivision = nil
	m.clearedFields[followuprecord.FieldDivision] = struct{}{}
}

// DivisionCleared returns if the "division" field was cleared in this mutation.
func (m *FollowUpRecordMutation) DivisionCleared() bool {
	_, ok := m.clearedFields[followuprecord.FieldDivision]
	return ok
}

// ResetDivision resets all changes to the "division" field.
func (m *FollowUpRecordMutation) ResetDivision() {
	m.division = nil
	m.adddivision = nil
	delete(m.clearedFields, followuprecord.FieldDivision)
}

// SetOpportunitiesID sets the "opportunities_id" field.
func (m *FollowUpRecordMutation) SetOpportunitiesID(i int64) {
	m.opportunities_id = &i
	m.addopportunities_id = nil
}

// OpportunitiesID returns the value of the "opportunities_id" field in the mutation.
func (m *FollowUpRecordMutation) OpportunitiesID() (r int64, exists bool) {
	v := m.opportunities_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpportunitiesID returns the old "opportunities_id" field's value of the FollowUpRecord entity.
// If the FollowUpRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpRecordMutation) OldOpportunitiesID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpportunitiesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpportunitiesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpportunitiesID: %w", err)
	}
	return oldValue.OpportunitiesID, nil
}

// AddOpportunitiesID adds i to the "opportunities_id" field.
func (m *FollowUpRecordMutation) AddOpportunitiesID(i int64) {
	if m.addopportunities_id != nil {
		*m.addopportunities_id += i
	} else {
		m.addopportunities_id = &i
	}
}

// AddedOpportunitiesID returns the value that was added to the "opportunities_id" field in this mutation.
func (m *FollowUpRecordMutation) AddedOpportunitiesID() (r int64, exists bool) {
	v := m.addopportunities_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOpportunitiesID clears the value of the "opportunities_id" field.
func (m *FollowUpRecordMutation) ClearOpportunitiesID() {
	m.opportunities_id = nil
	m.addopportunities_id = nil
	m.clearedFields[followuprecord.FieldOpportunitiesID] = struct{}{}
}

// OpportunitiesIDCleared returns if the "opportunities_id" field was cleared in this mutation.
func (m *FollowUpRecordMutation) OpportunitiesIDCleared() bool {
	_, ok := m.clearedFields[followuprecord.FieldOpportunitiesID]
	return ok
}

// ResetOpportunitiesID resets all changes to the "opportunities_id" field.
func (m *FollowUpRecordMutation) ResetOpportunitiesID() {
	m.opportunities_id = nil
	m.addopportunities_id = nil
	delete(m.clearedFields, followuprecord.FieldOpportunitiesID)
}

// SetRecord sets the "record" field.
func (m *FollowUpRecordMutation) SetRecord(s string) {
	m.record = &s
}

// Record returns the value of the "record" field in the mutation.
func (m *FollowUpRecordMutation) Record() (r string, exists bool) {
	v := m.record
	if v == nil {
		return
	}
	return *v, true
}

// OldRecord returns the old "record" field's value of the FollowUpRecord entity.
// If the FollowUpRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowUpRecordMutation) OldRecord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecord: %w", err)
	}
	return oldValue.Record, nil
}

// ClearRecord clears the value of the "record" field.
func (m *FollowUpRecordMutation) ClearRecord() {
	m.record = nil
	m.clearedFields[followuprecord.FieldRecord] = struct{}{}
}

// RecordCleared returns if the "record" field was cleared in this mutation.
func (m *FollowUpRecordMutation) RecordCleared() bool {
	_, ok := m.clearedFields[followuprecord.FieldRecord]
	return ok
}

// ResetRecord resets all changes to the "record" field.
func (m *FollowUpRecordMutation) ResetRecord() {
	m.record = nil
	delete(m.clearedFields, followuprecord.FieldRecord)
}

// Where appends a list predicates to the FollowUpRecordMutation builder.
func (m *FollowUpRecordMutation) Where(ps ...predicate.FollowUpRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FollowUpRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FollowUpRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FollowUpRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FollowUpRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FollowUpRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FollowUpRecord).
func (m *FollowUpRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FollowUpRecordMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, followuprecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, followuprecord.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, followuprecord.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, followuprecord.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, followuprecord.FieldStatus)
	}
	if m.content != nil {
		fields = append(fields, followuprecord.FieldContent)
	}
	if m.follow_up_id != nil {
		fields = append(fields, followuprecord.FieldFollowUpID)
	}
	if m.method != nil {
		fields = append(fields, followuprecord.FieldMethod)
	}
	if m.user_id != nil {
		fields = append(fields, followuprecord.FieldUserID)
	}
	if m.division != nil {
		fields = append(fields, followuprecord.FieldDivision)
	}
	if m.opportunities_id != nil {
		fields = append(fields, followuprecord.FieldOpportunitiesID)
	}
	if m.record != nil {
		fields = append(fields, followuprecord.FieldRecord)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FollowUpRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case followuprecord.FieldCreatedAt:
		return m.CreatedAt()
	case followuprecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case followuprecord.FieldDelete:
		return m.Delete()
	case followuprecord.FieldCreatedID:
		return m.CreatedID()
	case followuprecord.FieldStatus:
		return m.Status()
	case followuprecord.FieldContent:
		return m.Content()
	case followuprecord.FieldFollowUpID:
		return m.FollowUpID()
	case followuprecord.FieldMethod:
		return m.Method()
	case followuprecord.FieldUserID:
		return m.UserID()
	case followuprecord.FieldDivision:
		return m.Division()
	case followuprecord.FieldOpportunitiesID:
		return m.OpportunitiesID()
	case followuprecord.FieldRecord:
		return m.Record()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FollowUpRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case followuprecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case followuprecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case followuprecord.FieldDelete:
		return m.OldDelete(ctx)
	case followuprecord.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case followuprecord.FieldStatus:
		return m.OldStatus(ctx)
	case followuprecord.FieldContent:
		return m.OldContent(ctx)
	case followuprecord.FieldFollowUpID:
		return m.OldFollowUpID(ctx)
	case followuprecord.FieldMethod:
		return m.OldMethod(ctx)
	case followuprecord.FieldUserID:
		return m.OldUserID(ctx)
	case followuprecord.FieldDivision:
		return m.OldDivision(ctx)
	case followuprecord.FieldOpportunitiesID:
		return m.OldOpportunitiesID(ctx)
	case followuprecord.FieldRecord:
		return m.OldRecord(ctx)
	}
	return nil, fmt.Errorf("unknown FollowUpRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FollowUpRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case followuprecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case followuprecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case followuprecord.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case followuprecord.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case followuprecord.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case followuprecord.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case followuprecord.FieldFollowUpID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowUpID(v)
		return nil
	case followuprecord.FieldMethod:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case followuprecord.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case followuprecord.FieldDivision:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDivision(v)
		return nil
	case followuprecord.FieldOpportunitiesID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpportunitiesID(v)
		return nil
	case followuprecord.FieldRecord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecord(v)
		return nil
	}
	return fmt.Errorf("unknown FollowUpRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FollowUpRecordMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, followuprecord.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, followuprecord.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, followuprecord.FieldStatus)
	}
	if m.addfollow_up_id != nil {
		fields = append(fields, followuprecord.FieldFollowUpID)
	}
	if m.addmethod != nil {
		fields = append(fields, followuprecord.FieldMethod)
	}
	if m.adduser_id != nil {
		fields = append(fields, followuprecord.FieldUserID)
	}
	if m.adddivision != nil {
		fields = append(fields, followuprecord.FieldDivision)
	}
	if m.addopportunities_id != nil {
		fields = append(fields, followuprecord.FieldOpportunitiesID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FollowUpRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case followuprecord.FieldDelete:
		return m.AddedDelete()
	case followuprecord.FieldCreatedID:
		return m.AddedCreatedID()
	case followuprecord.FieldStatus:
		return m.AddedStatus()
	case followuprecord.FieldFollowUpID:
		return m.AddedFollowUpID()
	case followuprecord.FieldMethod:
		return m.AddedMethod()
	case followuprecord.FieldUserID:
		return m.AddedUserID()
	case followuprecord.FieldDivision:
		return m.AddedDivision()
	case followuprecord.FieldOpportunitiesID:
		return m.AddedOpportunitiesID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FollowUpRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case followuprecord.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case followuprecord.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case followuprecord.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case followuprecord.FieldFollowUpID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowUpID(v)
		return nil
	case followuprecord.FieldMethod:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMethod(v)
		return nil
	case followuprecord.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case followuprecord.FieldDivision:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDivision(v)
		return nil
	case followuprecord.FieldOpportunitiesID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpportunitiesID(v)
		return nil
	}
	return fmt.Errorf("unknown FollowUpRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FollowUpRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(followuprecord.FieldCreatedAt) {
		fields = append(fields, followuprecord.FieldCreatedAt)
	}
	if m.FieldCleared(followuprecord.FieldUpdatedAt) {
		fields = append(fields, followuprecord.FieldUpdatedAt)
	}
	if m.FieldCleared(followuprecord.FieldDelete) {
		fields = append(fields, followuprecord.FieldDelete)
	}
	if m.FieldCleared(followuprecord.FieldCreatedID) {
		fields = append(fields, followuprecord.FieldCreatedID)
	}
	if m.FieldCleared(followuprecord.FieldStatus) {
		fields = append(fields, followuprecord.FieldStatus)
	}
	if m.FieldCleared(followuprecord.FieldContent) {
		fields = append(fields, followuprecord.FieldContent)
	}
	if m.FieldCleared(followuprecord.FieldFollowUpID) {
		fields = append(fields, followuprecord.FieldFollowUpID)
	}
	if m.FieldCleared(followuprecord.FieldMethod) {
		fields = append(fields, followuprecord.FieldMethod)
	}
	if m.FieldCleared(followuprecord.FieldUserID) {
		fields = append(fields, followuprecord.FieldUserID)
	}
	if m.FieldCleared(followuprecord.FieldDivision) {
		fields = append(fields, followuprecord.FieldDivision)
	}
	if m.FieldCleared(followuprecord.FieldOpportunitiesID) {
		fields = append(fields, followuprecord.FieldOpportunitiesID)
	}
	if m.FieldCleared(followuprecord.FieldRecord) {
		fields = append(fields, followuprecord.FieldRecord)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FollowUpRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FollowUpRecordMutation) ClearField(name string) error {
	switch name {
	case followuprecord.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case followuprecord.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case followuprecord.FieldDelete:
		m.ClearDelete()
		return nil
	case followuprecord.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case followuprecord.FieldStatus:
		m.ClearStatus()
		return nil
	case followuprecord.FieldContent:
		m.ClearContent()
		return nil
	case followuprecord.FieldFollowUpID:
		m.ClearFollowUpID()
		return nil
	case followuprecord.FieldMethod:
		m.ClearMethod()
		return nil
	case followuprecord.FieldUserID:
		m.ClearUserID()
		return nil
	case followuprecord.FieldDivision:
		m.ClearDivision()
		return nil
	case followuprecord.FieldOpportunitiesID:
		m.ClearOpportunitiesID()
		return nil
	case followuprecord.FieldRecord:
		m.ClearRecord()
		return nil
	}
	return fmt.Errorf("unknown FollowUpRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FollowUpRecordMutation) ResetField(name string) error {
	switch name {
	case followuprecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case followuprecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case followuprecord.FieldDelete:
		m.ResetDelete()
		return nil
	case followuprecord.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case followuprecord.FieldStatus:
		m.ResetStatus()
		return nil
	case followuprecord.FieldContent:
		m.ResetContent()
		return nil
	case followuprecord.FieldFollowUpID:
		m.ResetFollowUpID()
		return nil
	case followuprecord.FieldMethod:
		m.ResetMethod()
		return nil
	case followuprecord.FieldUserID:
		m.ResetUserID()
		return nil
	case followuprecord.FieldDivision:
		m.ResetDivision()
		return nil
	case followuprecord.FieldOpportunitiesID:
		m.ResetOpportunitiesID()
		return nil
	case followuprecord.FieldRecord:
		m.ResetRecord()
		return nil
	}
	return fmt.Errorf("unknown FollowUpRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FollowUpRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FollowUpRecordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FollowUpRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FollowUpRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FollowUpRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FollowUpRecordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FollowUpRecordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FollowUpRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FollowUpRecordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FollowUpRecord edge %s", name)
}

// OpportunitiesMutation represents an operation that mutates the Opportunities nodes in the graph.
type OpportunitiesMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_at           *time.Time
	updated_at           *time.Time
	delete               *int64
	adddelete            *int64
	created_id           *int64
	addcreated_id        *int64
	status               *int64
	addstatus            *int64
	title                *string
	content              *string
	user_id              *int64
	adduser_id           *int64
	member_id            *int64
	addmember_id         *int64
	period               *int64
	addperiod            *int64
	prediction_amount    *int64
	addprediction_amount *int64
	period_at            *time.Time
	end_sales_at         *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Opportunities, error)
	predicates           []predicate.Opportunities
}

var _ ent.Mutation = (*OpportunitiesMutation)(nil)

// opportunitiesOption allows management of the mutation configuration using functional options.
type opportunitiesOption func(*OpportunitiesMutation)

// newOpportunitiesMutation creates new mutation for the Opportunities entity.
func newOpportunitiesMutation(c config, op Op, opts ...opportunitiesOption) *OpportunitiesMutation {
	m := &OpportunitiesMutation{
		config:        c,
		op:            op,
		typ:           TypeOpportunities,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOpportunitiesID sets the ID field of the mutation.
func withOpportunitiesID(id int64) opportunitiesOption {
	return func(m *OpportunitiesMutation) {
		var (
			err   error
			once  sync.Once
			value *Opportunities
		)
		m.oldValue = func(ctx context.Context) (*Opportunities, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Opportunities.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOpportunities sets the old Opportunities of the mutation.
func withOpportunities(node *Opportunities) opportunitiesOption {
	return func(m *OpportunitiesMutation) {
		m.oldValue = func(context.Context) (*Opportunities, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OpportunitiesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OpportunitiesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Opportunities entities.
func (m *OpportunitiesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OpportunitiesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OpportunitiesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Opportunities.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OpportunitiesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OpportunitiesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Opportunities entity.
// If the Opportunities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpportunitiesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OpportunitiesMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[opportunities.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OpportunitiesMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[opportunities.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OpportunitiesMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, opportunities.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OpportunitiesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OpportunitiesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Opportunities entity.
// If the Opportunities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpportunitiesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OpportunitiesMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[opportunities.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OpportunitiesMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[opportunities.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OpportunitiesMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, opportunities.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *OpportunitiesMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *OpportunitiesMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Opportunities entity.
// If the Opportunities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpportunitiesMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *OpportunitiesMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *OpportunitiesMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *OpportunitiesMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[opportunities.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *OpportunitiesMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[opportunities.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *OpportunitiesMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, opportunities.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *OpportunitiesMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *OpportunitiesMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Opportunities entity.
// If the Opportunities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpportunitiesMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *OpportunitiesMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *OpportunitiesMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *OpportunitiesMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[opportunities.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *OpportunitiesMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[opportunities.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *OpportunitiesMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, opportunities.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *OpportunitiesMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OpportunitiesMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Opportunities entity.
// If the Opportunities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpportunitiesMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OpportunitiesMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OpportunitiesMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *OpportunitiesMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[opportunities.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OpportunitiesMutation) StatusCleared() bool {
	_, ok := m.clearedFields[opportunities.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OpportunitiesMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, opportunities.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *OpportunitiesMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *OpportunitiesMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Opportunities entity.
// If the Opportunities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpportunitiesMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *OpportunitiesMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[opportunities.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *OpportunitiesMutation) TitleCleared() bool {
	_, ok := m.clearedFields[opportunities.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *OpportunitiesMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, opportunities.FieldTitle)
}

// SetContent sets the "content" field.
func (m *OpportunitiesMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *OpportunitiesMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Opportunities entity.
// If the Opportunities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpportunitiesMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *OpportunitiesMutation) ClearContent() {
	m.content = nil
	m.clearedFields[opportunities.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *OpportunitiesMutation) ContentCleared() bool {
	_, ok := m.clearedFields[opportunities.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *OpportunitiesMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, opportunities.FieldContent)
}

// SetUserID sets the "user_id" field.
func (m *OpportunitiesMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OpportunitiesMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Opportunities entity.
// If the Opportunities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpportunitiesMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *OpportunitiesMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *OpportunitiesMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *OpportunitiesMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[opportunities.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *OpportunitiesMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[opportunities.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OpportunitiesMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, opportunities.FieldUserID)
}

// SetMemberID sets the "member_id" field.
func (m *OpportunitiesMutation) SetMemberID(i int64) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *OpportunitiesMutation) MemberID() (r int64, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the Opportunities entity.
// If the Opportunities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpportunitiesMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *OpportunitiesMutation) AddMemberID(i int64) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *OpportunitiesMutation) AddedMemberID() (r int64, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *OpportunitiesMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[opportunities.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *OpportunitiesMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[opportunities.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *OpportunitiesMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, opportunities.FieldMemberID)
}

// SetPeriod sets the "period" field.
func (m *OpportunitiesMutation) SetPeriod(i int64) {
	m.period = &i
	m.addperiod = nil
}

// Period returns the value of the "period" field in the mutation.
func (m *OpportunitiesMutation) Period() (r int64, exists bool) {
	v := m.period
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriod returns the old "period" field's value of the Opportunities entity.
// If the Opportunities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpportunitiesMutation) OldPeriod(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriod: %w", err)
	}
	return oldValue.Period, nil
}

// AddPeriod adds i to the "period" field.
func (m *OpportunitiesMutation) AddPeriod(i int64) {
	if m.addperiod != nil {
		*m.addperiod += i
	} else {
		m.addperiod = &i
	}
}

// AddedPeriod returns the value that was added to the "period" field in this mutation.
func (m *OpportunitiesMutation) AddedPeriod() (r int64, exists bool) {
	v := m.addperiod
	if v == nil {
		return
	}
	return *v, true
}

// ClearPeriod clears the value of the "period" field.
func (m *OpportunitiesMutation) ClearPeriod() {
	m.period = nil
	m.addperiod = nil
	m.clearedFields[opportunities.FieldPeriod] = struct{}{}
}

// PeriodCleared returns if the "period" field was cleared in this mutation.
func (m *OpportunitiesMutation) PeriodCleared() bool {
	_, ok := m.clearedFields[opportunities.FieldPeriod]
	return ok
}

// ResetPeriod resets all changes to the "period" field.
func (m *OpportunitiesMutation) ResetPeriod() {
	m.period = nil
	m.addperiod = nil
	delete(m.clearedFields, opportunities.FieldPeriod)
}

// SetPredictionAmount sets the "prediction_amount" field.
func (m *OpportunitiesMutation) SetPredictionAmount(i int64) {
	m.prediction_amount = &i
	m.addprediction_amount = nil
}

// PredictionAmount returns the value of the "prediction_amount" field in the mutation.
func (m *OpportunitiesMutation) PredictionAmount() (r int64, exists bool) {
	v := m.prediction_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldPredictionAmount returns the old "prediction_amount" field's value of the Opportunities entity.
// If the Opportunities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpportunitiesMutation) OldPredictionAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPredictionAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPredictionAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPredictionAmount: %w", err)
	}
	return oldValue.PredictionAmount, nil
}

// AddPredictionAmount adds i to the "prediction_amount" field.
func (m *OpportunitiesMutation) AddPredictionAmount(i int64) {
	if m.addprediction_amount != nil {
		*m.addprediction_amount += i
	} else {
		m.addprediction_amount = &i
	}
}

// AddedPredictionAmount returns the value that was added to the "prediction_amount" field in this mutation.
func (m *OpportunitiesMutation) AddedPredictionAmount() (r int64, exists bool) {
	v := m.addprediction_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearPredictionAmount clears the value of the "prediction_amount" field.
func (m *OpportunitiesMutation) ClearPredictionAmount() {
	m.prediction_amount = nil
	m.addprediction_amount = nil
	m.clearedFields[opportunities.FieldPredictionAmount] = struct{}{}
}

// PredictionAmountCleared returns if the "prediction_amount" field was cleared in this mutation.
func (m *OpportunitiesMutation) PredictionAmountCleared() bool {
	_, ok := m.clearedFields[opportunities.FieldPredictionAmount]
	return ok
}

// ResetPredictionAmount resets all changes to the "prediction_amount" field.
func (m *OpportunitiesMutation) ResetPredictionAmount() {
	m.prediction_amount = nil
	m.addprediction_amount = nil
	delete(m.clearedFields, opportunities.FieldPredictionAmount)
}

// SetPeriodAt sets the "period_at" field.
func (m *OpportunitiesMutation) SetPeriodAt(t time.Time) {
	m.period_at = &t
}

// PeriodAt returns the value of the "period_at" field in the mutation.
func (m *OpportunitiesMutation) PeriodAt() (r time.Time, exists bool) {
	v := m.period_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodAt returns the old "period_at" field's value of the Opportunities entity.
// If the Opportunities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpportunitiesMutation) OldPeriodAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriodAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriodAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodAt: %w", err)
	}
	return oldValue.PeriodAt, nil
}

// ClearPeriodAt clears the value of the "period_at" field.
func (m *OpportunitiesMutation) ClearPeriodAt() {
	m.period_at = nil
	m.clearedFields[opportunities.FieldPeriodAt] = struct{}{}
}

// PeriodAtCleared returns if the "period_at" field was cleared in this mutation.
func (m *OpportunitiesMutation) PeriodAtCleared() bool {
	_, ok := m.clearedFields[opportunities.FieldPeriodAt]
	return ok
}

// ResetPeriodAt resets all changes to the "period_at" field.
func (m *OpportunitiesMutation) ResetPeriodAt() {
	m.period_at = nil
	delete(m.clearedFields, opportunities.FieldPeriodAt)
}

// SetEndSalesAt sets the "end_sales_at" field.
func (m *OpportunitiesMutation) SetEndSalesAt(t time.Time) {
	m.end_sales_at = &t
}

// EndSalesAt returns the value of the "end_sales_at" field in the mutation.
func (m *OpportunitiesMutation) EndSalesAt() (r time.Time, exists bool) {
	v := m.end_sales_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndSalesAt returns the old "end_sales_at" field's value of the Opportunities entity.
// If the Opportunities object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OpportunitiesMutation) OldEndSalesAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndSalesAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndSalesAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndSalesAt: %w", err)
	}
	return oldValue.EndSalesAt, nil
}

// ClearEndSalesAt clears the value of the "end_sales_at" field.
func (m *OpportunitiesMutation) ClearEndSalesAt() {
	m.end_sales_at = nil
	m.clearedFields[opportunities.FieldEndSalesAt] = struct{}{}
}

// EndSalesAtCleared returns if the "end_sales_at" field was cleared in this mutation.
func (m *OpportunitiesMutation) EndSalesAtCleared() bool {
	_, ok := m.clearedFields[opportunities.FieldEndSalesAt]
	return ok
}

// ResetEndSalesAt resets all changes to the "end_sales_at" field.
func (m *OpportunitiesMutation) ResetEndSalesAt() {
	m.end_sales_at = nil
	delete(m.clearedFields, opportunities.FieldEndSalesAt)
}

// Where appends a list predicates to the OpportunitiesMutation builder.
func (m *OpportunitiesMutation) Where(ps ...predicate.Opportunities) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OpportunitiesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OpportunitiesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Opportunities, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OpportunitiesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OpportunitiesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Opportunities).
func (m *OpportunitiesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OpportunitiesMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, opportunities.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, opportunities.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, opportunities.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, opportunities.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, opportunities.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, opportunities.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, opportunities.FieldContent)
	}
	if m.user_id != nil {
		fields = append(fields, opportunities.FieldUserID)
	}
	if m.member_id != nil {
		fields = append(fields, opportunities.FieldMemberID)
	}
	if m.period != nil {
		fields = append(fields, opportunities.FieldPeriod)
	}
	if m.prediction_amount != nil {
		fields = append(fields, opportunities.FieldPredictionAmount)
	}
	if m.period_at != nil {
		fields = append(fields, opportunities.FieldPeriodAt)
	}
	if m.end_sales_at != nil {
		fields = append(fields, opportunities.FieldEndSalesAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OpportunitiesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case opportunities.FieldCreatedAt:
		return m.CreatedAt()
	case opportunities.FieldUpdatedAt:
		return m.UpdatedAt()
	case opportunities.FieldDelete:
		return m.Delete()
	case opportunities.FieldCreatedID:
		return m.CreatedID()
	case opportunities.FieldStatus:
		return m.Status()
	case opportunities.FieldTitle:
		return m.Title()
	case opportunities.FieldContent:
		return m.Content()
	case opportunities.FieldUserID:
		return m.UserID()
	case opportunities.FieldMemberID:
		return m.MemberID()
	case opportunities.FieldPeriod:
		return m.Period()
	case opportunities.FieldPredictionAmount:
		return m.PredictionAmount()
	case opportunities.FieldPeriodAt:
		return m.PeriodAt()
	case opportunities.FieldEndSalesAt:
		return m.EndSalesAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OpportunitiesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case opportunities.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case opportunities.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case opportunities.FieldDelete:
		return m.OldDelete(ctx)
	case opportunities.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case opportunities.FieldStatus:
		return m.OldStatus(ctx)
	case opportunities.FieldTitle:
		return m.OldTitle(ctx)
	case opportunities.FieldContent:
		return m.OldContent(ctx)
	case opportunities.FieldUserID:
		return m.OldUserID(ctx)
	case opportunities.FieldMemberID:
		return m.OldMemberID(ctx)
	case opportunities.FieldPeriod:
		return m.OldPeriod(ctx)
	case opportunities.FieldPredictionAmount:
		return m.OldPredictionAmount(ctx)
	case opportunities.FieldPeriodAt:
		return m.OldPeriodAt(ctx)
	case opportunities.FieldEndSalesAt:
		return m.OldEndSalesAt(ctx)
	}
	return nil, fmt.Errorf("unknown Opportunities field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OpportunitiesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case opportunities.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case opportunities.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case opportunities.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case opportunities.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case opportunities.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case opportunities.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case opportunities.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case opportunities.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case opportunities.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case opportunities.FieldPeriod:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriod(v)
		return nil
	case opportunities.FieldPredictionAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPredictionAmount(v)
		return nil
	case opportunities.FieldPeriodAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodAt(v)
		return nil
	case opportunities.FieldEndSalesAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndSalesAt(v)
		return nil
	}
	return fmt.Errorf("unknown Opportunities field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OpportunitiesMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, opportunities.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, opportunities.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, opportunities.FieldStatus)
	}
	if m.adduser_id != nil {
		fields = append(fields, opportunities.FieldUserID)
	}
	if m.addmember_id != nil {
		fields = append(fields, opportunities.FieldMemberID)
	}
	if m.addperiod != nil {
		fields = append(fields, opportunities.FieldPeriod)
	}
	if m.addprediction_amount != nil {
		fields = append(fields, opportunities.FieldPredictionAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OpportunitiesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case opportunities.FieldDelete:
		return m.AddedDelete()
	case opportunities.FieldCreatedID:
		return m.AddedCreatedID()
	case opportunities.FieldStatus:
		return m.AddedStatus()
	case opportunities.FieldUserID:
		return m.AddedUserID()
	case opportunities.FieldMemberID:
		return m.AddedMemberID()
	case opportunities.FieldPeriod:
		return m.AddedPeriod()
	case opportunities.FieldPredictionAmount:
		return m.AddedPredictionAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OpportunitiesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case opportunities.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case opportunities.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case opportunities.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case opportunities.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case opportunities.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	case opportunities.FieldPeriod:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeriod(v)
		return nil
	case opportunities.FieldPredictionAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPredictionAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Opportunities numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OpportunitiesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(opportunities.FieldCreatedAt) {
		fields = append(fields, opportunities.FieldCreatedAt)
	}
	if m.FieldCleared(opportunities.FieldUpdatedAt) {
		fields = append(fields, opportunities.FieldUpdatedAt)
	}
	if m.FieldCleared(opportunities.FieldDelete) {
		fields = append(fields, opportunities.FieldDelete)
	}
	if m.FieldCleared(opportunities.FieldCreatedID) {
		fields = append(fields, opportunities.FieldCreatedID)
	}
	if m.FieldCleared(opportunities.FieldStatus) {
		fields = append(fields, opportunities.FieldStatus)
	}
	if m.FieldCleared(opportunities.FieldTitle) {
		fields = append(fields, opportunities.FieldTitle)
	}
	if m.FieldCleared(opportunities.FieldContent) {
		fields = append(fields, opportunities.FieldContent)
	}
	if m.FieldCleared(opportunities.FieldUserID) {
		fields = append(fields, opportunities.FieldUserID)
	}
	if m.FieldCleared(opportunities.FieldMemberID) {
		fields = append(fields, opportunities.FieldMemberID)
	}
	if m.FieldCleared(opportunities.FieldPeriod) {
		fields = append(fields, opportunities.FieldPeriod)
	}
	if m.FieldCleared(opportunities.FieldPredictionAmount) {
		fields = append(fields, opportunities.FieldPredictionAmount)
	}
	if m.FieldCleared(opportunities.FieldPeriodAt) {
		fields = append(fields, opportunities.FieldPeriodAt)
	}
	if m.FieldCleared(opportunities.FieldEndSalesAt) {
		fields = append(fields, opportunities.FieldEndSalesAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OpportunitiesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OpportunitiesMutation) ClearField(name string) error {
	switch name {
	case opportunities.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case opportunities.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case opportunities.FieldDelete:
		m.ClearDelete()
		return nil
	case opportunities.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case opportunities.FieldStatus:
		m.ClearStatus()
		return nil
	case opportunities.FieldTitle:
		m.ClearTitle()
		return nil
	case opportunities.FieldContent:
		m.ClearContent()
		return nil
	case opportunities.FieldUserID:
		m.ClearUserID()
		return nil
	case opportunities.FieldMemberID:
		m.ClearMemberID()
		return nil
	case opportunities.FieldPeriod:
		m.ClearPeriod()
		return nil
	case opportunities.FieldPredictionAmount:
		m.ClearPredictionAmount()
		return nil
	case opportunities.FieldPeriodAt:
		m.ClearPeriodAt()
		return nil
	case opportunities.FieldEndSalesAt:
		m.ClearEndSalesAt()
		return nil
	}
	return fmt.Errorf("unknown Opportunities nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OpportunitiesMutation) ResetField(name string) error {
	switch name {
	case opportunities.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case opportunities.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case opportunities.FieldDelete:
		m.ResetDelete()
		return nil
	case opportunities.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case opportunities.FieldStatus:
		m.ResetStatus()
		return nil
	case opportunities.FieldTitle:
		m.ResetTitle()
		return nil
	case opportunities.FieldContent:
		m.ResetContent()
		return nil
	case opportunities.FieldUserID:
		m.ResetUserID()
		return nil
	case opportunities.FieldMemberID:
		m.ResetMemberID()
		return nil
	case opportunities.FieldPeriod:
		m.ResetPeriod()
		return nil
	case opportunities.FieldPredictionAmount:
		m.ResetPredictionAmount()
		return nil
	case opportunities.FieldPeriodAt:
		m.ResetPeriodAt()
		return nil
	case opportunities.FieldEndSalesAt:
		m.ResetEndSalesAt()
		return nil
	}
	return fmt.Errorf("unknown Opportunities field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OpportunitiesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OpportunitiesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OpportunitiesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OpportunitiesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OpportunitiesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OpportunitiesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OpportunitiesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Opportunities unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OpportunitiesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Opportunities edge %s", name)
}

// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"system/biz/dal/db/ent/api"
	"system/biz/dal/db/ent/dict"
	"system/biz/dal/db/ent/dictht"
	"system/biz/dal/db/ent/logs"
	"system/biz/dal/db/ent/menu"
	"system/biz/dal/db/ent/messages"
	"system/biz/dal/db/ent/predicate"
	"system/biz/dal/db/ent/role"
	"system/biz/dal/db/ent/sms"
	"system/biz/dal/db/ent/smslog"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPI      = "API"
	TypeDict     = "Dict"
	TypeDictht   = "Dictht"
	TypeLogs     = "Logs"
	TypeMenu     = "Menu"
	TypeMessages = "Messages"
	TypeRole     = "Role"
	TypeSms      = "Sms"
	TypeSmsLog   = "SmsLog"
)

// APIMutation represents an operation that mutates the API nodes in the graph.
type APIMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	_path         *string
	title         *string
	desc          *string
	group         *string
	method        *string
	clearedFields map[string]struct{}
	roles         map[int64]struct{}
	removedroles  map[int64]struct{}
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*API, error)
	predicates    []predicate.API
}

var _ ent.Mutation = (*APIMutation)(nil)

// apiOption allows management of the mutation configuration using functional options.
type apiOption func(*APIMutation)

// newAPIMutation creates new mutation for the API entity.
func newAPIMutation(c config, op Op, opts ...apiOption) *APIMutation {
	m := &APIMutation{
		config:        c,
		op:            op,
		typ:           TypeAPI,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIID sets the ID field of the mutation.
func withAPIID(id int64) apiOption {
	return func(m *APIMutation) {
		var (
			err   error
			once  sync.Once
			value *API
		)
		m.oldValue = func(ctx context.Context) (*API, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().API.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPI sets the old API of the mutation.
func withAPI(node *API) apiOption {
	return func(m *APIMutation) {
		m.oldValue = func(context.Context) (*API, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of API entities.
func (m *APIMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().API.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *APIMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[api.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *APIMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[api.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, api.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *APIMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[api.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *APIMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[api.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, api.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *APIMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *APIMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *APIMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *APIMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *APIMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[api.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *APIMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[api.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *APIMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, api.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *APIMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *APIMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *APIMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *APIMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *APIMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[api.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *APIMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[api.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *APIMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, api.FieldCreatedID)
}

// SetPath sets the "path" field.
func (m *APIMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *APIMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *APIMutation) ClearPath() {
	m._path = nil
	m.clearedFields[api.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *APIMutation) PathCleared() bool {
	_, ok := m.clearedFields[api.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *APIMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, api.FieldPath)
}

// SetTitle sets the "title" field.
func (m *APIMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *APIMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *APIMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[api.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *APIMutation) TitleCleared() bool {
	_, ok := m.clearedFields[api.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *APIMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, api.FieldTitle)
}

// SetDesc sets the "desc" field.
func (m *APIMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *APIMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *APIMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[api.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *APIMutation) DescCleared() bool {
	_, ok := m.clearedFields[api.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *APIMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, api.FieldDesc)
}

// SetGroup sets the "group" field.
func (m *APIMutation) SetGroup(s string) {
	m.group = &s
}

// Group returns the value of the "group" field in the mutation.
func (m *APIMutation) Group() (r string, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "group" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// ClearGroup clears the value of the "group" field.
func (m *APIMutation) ClearGroup() {
	m.group = nil
	m.clearedFields[api.FieldGroup] = struct{}{}
}

// GroupCleared returns if the "group" field was cleared in this mutation.
func (m *APIMutation) GroupCleared() bool {
	_, ok := m.clearedFields[api.FieldGroup]
	return ok
}

// ResetGroup resets all changes to the "group" field.
func (m *APIMutation) ResetGroup() {
	m.group = nil
	delete(m.clearedFields, api.FieldGroup)
}

// SetMethod sets the "method" field.
func (m *APIMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *APIMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ClearMethod clears the value of the "method" field.
func (m *APIMutation) ClearMethod() {
	m.method = nil
	m.clearedFields[api.FieldMethod] = struct{}{}
}

// MethodCleared returns if the "method" field was cleared in this mutation.
func (m *APIMutation) MethodCleared() bool {
	_, ok := m.clearedFields[api.FieldMethod]
	return ok
}

// ResetMethod resets all changes to the "method" field.
func (m *APIMutation) ResetMethod() {
	m.method = nil
	delete(m.clearedFields, api.FieldMethod)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *APIMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *APIMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *APIMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *APIMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *APIMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *APIMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *APIMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the APIMutation builder.
func (m *APIMutation) Where(ps ...predicate.API) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.API, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (API).
func (m *APIMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, api.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, api.FieldCreatedID)
	}
	if m._path != nil {
		fields = append(fields, api.FieldPath)
	}
	if m.title != nil {
		fields = append(fields, api.FieldTitle)
	}
	if m.desc != nil {
		fields = append(fields, api.FieldDesc)
	}
	if m.group != nil {
		fields = append(fields, api.FieldGroup)
	}
	if m.method != nil {
		fields = append(fields, api.FieldMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case api.FieldCreatedAt:
		return m.CreatedAt()
	case api.FieldUpdatedAt:
		return m.UpdatedAt()
	case api.FieldDelete:
		return m.Delete()
	case api.FieldCreatedID:
		return m.CreatedID()
	case api.FieldPath:
		return m.Path()
	case api.FieldTitle:
		return m.Title()
	case api.FieldDesc:
		return m.Desc()
	case api.FieldGroup:
		return m.Group()
	case api.FieldMethod:
		return m.Method()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case api.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case api.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case api.FieldDelete:
		return m.OldDelete(ctx)
	case api.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case api.FieldPath:
		return m.OldPath(ctx)
	case api.FieldTitle:
		return m.OldTitle(ctx)
	case api.FieldDesc:
		return m.OldDesc(ctx)
	case api.FieldGroup:
		return m.OldGroup(ctx)
	case api.FieldMethod:
		return m.OldMethod(ctx)
	}
	return nil, fmt.Errorf("unknown API field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) SetField(name string, value ent.Value) error {
	switch name {
	case api.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case api.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case api.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case api.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case api.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case api.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case api.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case api.FieldGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case api.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, api.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, api.FieldCreatedID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case api.FieldDelete:
		return m.AddedDelete()
	case api.FieldCreatedID:
		return m.AddedCreatedID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) AddField(name string, value ent.Value) error {
	switch name {
	case api.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case api.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	}
	return fmt.Errorf("unknown API numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(api.FieldCreatedAt) {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.FieldCleared(api.FieldUpdatedAt) {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m.FieldCleared(api.FieldDelete) {
		fields = append(fields, api.FieldDelete)
	}
	if m.FieldCleared(api.FieldCreatedID) {
		fields = append(fields, api.FieldCreatedID)
	}
	if m.FieldCleared(api.FieldPath) {
		fields = append(fields, api.FieldPath)
	}
	if m.FieldCleared(api.FieldTitle) {
		fields = append(fields, api.FieldTitle)
	}
	if m.FieldCleared(api.FieldDesc) {
		fields = append(fields, api.FieldDesc)
	}
	if m.FieldCleared(api.FieldGroup) {
		fields = append(fields, api.FieldGroup)
	}
	if m.FieldCleared(api.FieldMethod) {
		fields = append(fields, api.FieldMethod)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIMutation) ClearField(name string) error {
	switch name {
	case api.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case api.FieldDelete:
		m.ClearDelete()
		return nil
	case api.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case api.FieldPath:
		m.ClearPath()
		return nil
	case api.FieldTitle:
		m.ClearTitle()
		return nil
	case api.FieldDesc:
		m.ClearDesc()
		return nil
	case api.FieldGroup:
		m.ClearGroup()
		return nil
	case api.FieldMethod:
		m.ClearMethod()
		return nil
	}
	return fmt.Errorf("unknown API nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIMutation) ResetField(name string) error {
	switch name {
	case api.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case api.FieldDelete:
		m.ResetDelete()
		return nil
	case api.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case api.FieldPath:
		m.ResetPath()
		return nil
	case api.FieldTitle:
		m.ResetTitle()
		return nil
	case api.FieldDesc:
		m.ResetDesc()
		return nil
	case api.FieldGroup:
		m.ResetGroup()
		return nil
	case api.FieldMethod:
		m.ResetMethod()
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roles != nil {
		edges = append(edges, api.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case api.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroles != nil {
		edges = append(edges, api.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case api.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedroles {
		edges = append(edges, api.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIMutation) EdgeCleared(name string) bool {
	switch name {
	case api.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown API unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIMutation) ResetEdge(name string) error {
	switch name {
	case api.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown API edge %s", name)
}

// DictMutation represents an operation that mutates the Dict nodes in the graph.
type DictMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	title         *string
	code          *string
	desc          *string
	clearedFields map[string]struct{}
	dictht        map[int64]struct{}
	removeddictht map[int64]struct{}
	cleareddictht bool
	done          bool
	oldValue      func(context.Context) (*Dict, error)
	predicates    []predicate.Dict
}

var _ ent.Mutation = (*DictMutation)(nil)

// dictOption allows management of the mutation configuration using functional options.
type dictOption func(*DictMutation)

// newDictMutation creates new mutation for the Dict entity.
func newDictMutation(c config, op Op, opts ...dictOption) *DictMutation {
	m := &DictMutation{
		config:        c,
		op:            op,
		typ:           TypeDict,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictID sets the ID field of the mutation.
func withDictID(id int64) dictOption {
	return func(m *DictMutation) {
		var (
			err   error
			once  sync.Once
			value *Dict
		)
		m.oldValue = func(ctx context.Context) (*Dict, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dict.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDict sets the old Dict of the mutation.
func withDict(node *Dict) dictOption {
	return func(m *DictMutation) {
		m.oldValue = func(context.Context) (*Dict, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dict entities.
func (m *DictMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dict.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Dict entity.
// If the Dict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DictMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[dict.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DictMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[dict.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, dict.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Dict entity.
// If the Dict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DictMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[dict.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DictMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[dict.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, dict.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *DictMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *DictMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Dict entity.
// If the Dict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *DictMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *DictMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *DictMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[dict.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *DictMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[dict.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *DictMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, dict.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *DictMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *DictMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Dict entity.
// If the Dict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *DictMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *DictMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *DictMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[dict.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *DictMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[dict.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *DictMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, dict.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *DictMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DictMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Dict entity.
// If the Dict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DictMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DictMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DictMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dict.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dict.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dict.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *DictMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DictMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Dict entity.
// If the Dict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *DictMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[dict.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *DictMutation) TitleCleared() bool {
	_, ok := m.clearedFields[dict.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *DictMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, dict.FieldTitle)
}

// SetCode sets the "code" field.
func (m *DictMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *DictMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Dict entity.
// If the Dict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *DictMutation) ClearCode() {
	m.code = nil
	m.clearedFields[dict.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *DictMutation) CodeCleared() bool {
	_, ok := m.clearedFields[dict.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *DictMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, dict.FieldCode)
}

// SetDesc sets the "desc" field.
func (m *DictMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *DictMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Dict entity.
// If the Dict object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *DictMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[dict.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *DictMutation) DescCleared() bool {
	_, ok := m.clearedFields[dict.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *DictMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, dict.FieldDesc)
}

// AddDicthtIDs adds the "dictht" edge to the Dictht entity by ids.
func (m *DictMutation) AddDicthtIDs(ids ...int64) {
	if m.dictht == nil {
		m.dictht = make(map[int64]struct{})
	}
	for i := range ids {
		m.dictht[ids[i]] = struct{}{}
	}
}

// ClearDictht clears the "dictht" edge to the Dictht entity.
func (m *DictMutation) ClearDictht() {
	m.cleareddictht = true
}

// DicthtCleared reports if the "dictht" edge to the Dictht entity was cleared.
func (m *DictMutation) DicthtCleared() bool {
	return m.cleareddictht
}

// RemoveDicthtIDs removes the "dictht" edge to the Dictht entity by IDs.
func (m *DictMutation) RemoveDicthtIDs(ids ...int64) {
	if m.removeddictht == nil {
		m.removeddictht = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.dictht, ids[i])
		m.removeddictht[ids[i]] = struct{}{}
	}
}

// RemovedDictht returns the removed IDs of the "dictht" edge to the Dictht entity.
func (m *DictMutation) RemovedDicthtIDs() (ids []int64) {
	for id := range m.removeddictht {
		ids = append(ids, id)
	}
	return
}

// DicthtIDs returns the "dictht" edge IDs in the mutation.
func (m *DictMutation) DicthtIDs() (ids []int64) {
	for id := range m.dictht {
		ids = append(ids, id)
	}
	return
}

// ResetDictht resets all changes to the "dictht" edge.
func (m *DictMutation) ResetDictht() {
	m.dictht = nil
	m.cleareddictht = false
	m.removeddictht = nil
}

// Where appends a list predicates to the DictMutation builder.
func (m *DictMutation) Where(ps ...predicate.Dict) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dict, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dict).
func (m *DictMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, dict.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dict.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, dict.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, dict.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, dict.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, dict.FieldTitle)
	}
	if m.code != nil {
		fields = append(fields, dict.FieldCode)
	}
	if m.desc != nil {
		fields = append(fields, dict.FieldDesc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dict.FieldCreatedAt:
		return m.CreatedAt()
	case dict.FieldUpdatedAt:
		return m.UpdatedAt()
	case dict.FieldDelete:
		return m.Delete()
	case dict.FieldCreatedID:
		return m.CreatedID()
	case dict.FieldStatus:
		return m.Status()
	case dict.FieldTitle:
		return m.Title()
	case dict.FieldCode:
		return m.Code()
	case dict.FieldDesc:
		return m.Desc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dict.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dict.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dict.FieldDelete:
		return m.OldDelete(ctx)
	case dict.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case dict.FieldStatus:
		return m.OldStatus(ctx)
	case dict.FieldTitle:
		return m.OldTitle(ctx)
	case dict.FieldCode:
		return m.OldCode(ctx)
	case dict.FieldDesc:
		return m.OldDesc(ctx)
	}
	return nil, fmt.Errorf("unknown Dict field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dict.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dict.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dict.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case dict.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case dict.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dict.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dict.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case dict.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	}
	return fmt.Errorf("unknown Dict field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, dict.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, dict.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, dict.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dict.FieldDelete:
		return m.AddedDelete()
	case dict.FieldCreatedID:
		return m.AddedCreatedID()
	case dict.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dict.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case dict.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case dict.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Dict numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dict.FieldCreatedAt) {
		fields = append(fields, dict.FieldCreatedAt)
	}
	if m.FieldCleared(dict.FieldUpdatedAt) {
		fields = append(fields, dict.FieldUpdatedAt)
	}
	if m.FieldCleared(dict.FieldDelete) {
		fields = append(fields, dict.FieldDelete)
	}
	if m.FieldCleared(dict.FieldCreatedID) {
		fields = append(fields, dict.FieldCreatedID)
	}
	if m.FieldCleared(dict.FieldStatus) {
		fields = append(fields, dict.FieldStatus)
	}
	if m.FieldCleared(dict.FieldTitle) {
		fields = append(fields, dict.FieldTitle)
	}
	if m.FieldCleared(dict.FieldCode) {
		fields = append(fields, dict.FieldCode)
	}
	if m.FieldCleared(dict.FieldDesc) {
		fields = append(fields, dict.FieldDesc)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictMutation) ClearField(name string) error {
	switch name {
	case dict.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case dict.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case dict.FieldDelete:
		m.ClearDelete()
		return nil
	case dict.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case dict.FieldStatus:
		m.ClearStatus()
		return nil
	case dict.FieldTitle:
		m.ClearTitle()
		return nil
	case dict.FieldCode:
		m.ClearCode()
		return nil
	case dict.FieldDesc:
		m.ClearDesc()
		return nil
	}
	return fmt.Errorf("unknown Dict nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictMutation) ResetField(name string) error {
	switch name {
	case dict.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dict.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dict.FieldDelete:
		m.ResetDelete()
		return nil
	case dict.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case dict.FieldStatus:
		m.ResetStatus()
		return nil
	case dict.FieldTitle:
		m.ResetTitle()
		return nil
	case dict.FieldCode:
		m.ResetCode()
		return nil
	case dict.FieldDesc:
		m.ResetDesc()
		return nil
	}
	return fmt.Errorf("unknown Dict field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dictht != nil {
		edges = append(edges, dict.EdgeDictht)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dict.EdgeDictht:
		ids := make([]ent.Value, 0, len(m.dictht))
		for id := range m.dictht {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddictht != nil {
		edges = append(edges, dict.EdgeDictht)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dict.EdgeDictht:
		ids := make([]ent.Value, 0, len(m.removeddictht))
		for id := range m.removeddictht {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddictht {
		edges = append(edges, dict.EdgeDictht)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictMutation) EdgeCleared(name string) bool {
	switch name {
	case dict.EdgeDictht:
		return m.cleareddictht
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Dict unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictMutation) ResetEdge(name string) error {
	switch name {
	case dict.EdgeDictht:
		m.ResetDictht()
		return nil
	}
	return fmt.Errorf("unknown Dict edge %s", name)
}

// DicthtMutation represents an operation that mutates the Dictht nodes in the graph.
type DicthtMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	title         *string
	value         *string
	clearedFields map[string]struct{}
	dict          *int64
	cleareddict   bool
	done          bool
	oldValue      func(context.Context) (*Dictht, error)
	predicates    []predicate.Dictht
}

var _ ent.Mutation = (*DicthtMutation)(nil)

// dicthtOption allows management of the mutation configuration using functional options.
type dicthtOption func(*DicthtMutation)

// newDicthtMutation creates new mutation for the Dictht entity.
func newDicthtMutation(c config, op Op, opts ...dicthtOption) *DicthtMutation {
	m := &DicthtMutation{
		config:        c,
		op:            op,
		typ:           TypeDictht,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDicthtID sets the ID field of the mutation.
func withDicthtID(id int64) dicthtOption {
	return func(m *DicthtMutation) {
		var (
			err   error
			once  sync.Once
			value *Dictht
		)
		m.oldValue = func(ctx context.Context) (*Dictht, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dictht.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictht sets the old Dictht of the mutation.
func withDictht(node *Dictht) dicthtOption {
	return func(m *DicthtMutation) {
		m.oldValue = func(context.Context) (*Dictht, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DicthtMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DicthtMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dictht entities.
func (m *DicthtMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DicthtMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DicthtMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dictht.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DicthtMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DicthtMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Dictht entity.
// If the Dictht object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DicthtMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DicthtMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[dictht.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DicthtMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[dictht.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DicthtMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, dictht.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DicthtMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DicthtMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Dictht entity.
// If the Dictht object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DicthtMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DicthtMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[dictht.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DicthtMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[dictht.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DicthtMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, dictht.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *DicthtMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *DicthtMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Dictht entity.
// If the Dictht object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DicthtMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *DicthtMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *DicthtMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *DicthtMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[dictht.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *DicthtMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[dictht.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *DicthtMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, dictht.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *DicthtMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *DicthtMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Dictht entity.
// If the Dictht object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DicthtMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *DicthtMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *DicthtMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *DicthtMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[dictht.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *DicthtMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[dictht.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *DicthtMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, dictht.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *DicthtMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *DicthtMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Dictht entity.
// If the Dictht object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DicthtMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *DicthtMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *DicthtMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *DicthtMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[dictht.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DicthtMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictht.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DicthtMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, dictht.FieldStatus)
}

// SetTitle sets the "title" field.
func (m *DicthtMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DicthtMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Dictht entity.
// If the Dictht object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DicthtMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *DicthtMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[dictht.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *DicthtMutation) TitleCleared() bool {
	_, ok := m.clearedFields[dictht.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *DicthtMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, dictht.FieldTitle)
}

// SetValue sets the "value" field.
func (m *DicthtMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *DicthtMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Dictht entity.
// If the Dictht object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DicthtMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *DicthtMutation) ClearValue() {
	m.value = nil
	m.clearedFields[dictht.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *DicthtMutation) ValueCleared() bool {
	_, ok := m.clearedFields[dictht.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *DicthtMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, dictht.FieldValue)
}

// SetDictID sets the "dict_id" field.
func (m *DicthtMutation) SetDictID(i int64) {
	m.dict = &i
}

// DictID returns the value of the "dict_id" field in the mutation.
func (m *DicthtMutation) DictID() (r int64, exists bool) {
	v := m.dict
	if v == nil {
		return
	}
	return *v, true
}

// OldDictID returns the old "dict_id" field's value of the Dictht entity.
// If the Dictht object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DicthtMutation) OldDictID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDictID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDictID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDictID: %w", err)
	}
	return oldValue.DictID, nil
}

// ClearDictID clears the value of the "dict_id" field.
func (m *DicthtMutation) ClearDictID() {
	m.dict = nil
	m.clearedFields[dictht.FieldDictID] = struct{}{}
}

// DictIDCleared returns if the "dict_id" field was cleared in this mutation.
func (m *DicthtMutation) DictIDCleared() bool {
	_, ok := m.clearedFields[dictht.FieldDictID]
	return ok
}

// ResetDictID resets all changes to the "dict_id" field.
func (m *DicthtMutation) ResetDictID() {
	m.dict = nil
	delete(m.clearedFields, dictht.FieldDictID)
}

// ClearDict clears the "dict" edge to the Dict entity.
func (m *DicthtMutation) ClearDict() {
	m.cleareddict = true
	m.clearedFields[dictht.FieldDictID] = struct{}{}
}

// DictCleared reports if the "dict" edge to the Dict entity was cleared.
func (m *DicthtMutation) DictCleared() bool {
	return m.DictIDCleared() || m.cleareddict
}

// DictIDs returns the "dict" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DictID instead. It exists only for internal usage by the builders.
func (m *DicthtMutation) DictIDs() (ids []int64) {
	if id := m.dict; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDict resets all changes to the "dict" edge.
func (m *DicthtMutation) ResetDict() {
	m.dict = nil
	m.cleareddict = false
}

// Where appends a list predicates to the DicthtMutation builder.
func (m *DicthtMutation) Where(ps ...predicate.Dictht) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DicthtMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DicthtMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dictht, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DicthtMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DicthtMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dictht).
func (m *DicthtMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DicthtMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, dictht.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictht.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, dictht.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, dictht.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, dictht.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, dictht.FieldTitle)
	}
	if m.value != nil {
		fields = append(fields, dictht.FieldValue)
	}
	if m.dict != nil {
		fields = append(fields, dictht.FieldDictID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DicthtMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictht.FieldCreatedAt:
		return m.CreatedAt()
	case dictht.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictht.FieldDelete:
		return m.Delete()
	case dictht.FieldCreatedID:
		return m.CreatedID()
	case dictht.FieldStatus:
		return m.Status()
	case dictht.FieldTitle:
		return m.Title()
	case dictht.FieldValue:
		return m.Value()
	case dictht.FieldDictID:
		return m.DictID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DicthtMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictht.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictht.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictht.FieldDelete:
		return m.OldDelete(ctx)
	case dictht.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case dictht.FieldStatus:
		return m.OldStatus(ctx)
	case dictht.FieldTitle:
		return m.OldTitle(ctx)
	case dictht.FieldValue:
		return m.OldValue(ctx)
	case dictht.FieldDictID:
		return m.OldDictID(ctx)
	}
	return nil, fmt.Errorf("unknown Dictht field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DicthtMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictht.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictht.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictht.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case dictht.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case dictht.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictht.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case dictht.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case dictht.FieldDictID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDictID(v)
		return nil
	}
	return fmt.Errorf("unknown Dictht field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DicthtMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, dictht.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, dictht.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, dictht.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DicthtMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictht.FieldDelete:
		return m.AddedDelete()
	case dictht.FieldCreatedID:
		return m.AddedCreatedID()
	case dictht.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DicthtMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictht.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case dictht.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case dictht.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Dictht numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DicthtMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictht.FieldCreatedAt) {
		fields = append(fields, dictht.FieldCreatedAt)
	}
	if m.FieldCleared(dictht.FieldUpdatedAt) {
		fields = append(fields, dictht.FieldUpdatedAt)
	}
	if m.FieldCleared(dictht.FieldDelete) {
		fields = append(fields, dictht.FieldDelete)
	}
	if m.FieldCleared(dictht.FieldCreatedID) {
		fields = append(fields, dictht.FieldCreatedID)
	}
	if m.FieldCleared(dictht.FieldStatus) {
		fields = append(fields, dictht.FieldStatus)
	}
	if m.FieldCleared(dictht.FieldTitle) {
		fields = append(fields, dictht.FieldTitle)
	}
	if m.FieldCleared(dictht.FieldValue) {
		fields = append(fields, dictht.FieldValue)
	}
	if m.FieldCleared(dictht.FieldDictID) {
		fields = append(fields, dictht.FieldDictID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DicthtMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DicthtMutation) ClearField(name string) error {
	switch name {
	case dictht.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case dictht.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case dictht.FieldDelete:
		m.ClearDelete()
		return nil
	case dictht.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case dictht.FieldStatus:
		m.ClearStatus()
		return nil
	case dictht.FieldTitle:
		m.ClearTitle()
		return nil
	case dictht.FieldValue:
		m.ClearValue()
		return nil
	case dictht.FieldDictID:
		m.ClearDictID()
		return nil
	}
	return fmt.Errorf("unknown Dictht nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DicthtMutation) ResetField(name string) error {
	switch name {
	case dictht.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictht.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictht.FieldDelete:
		m.ResetDelete()
		return nil
	case dictht.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case dictht.FieldStatus:
		m.ResetStatus()
		return nil
	case dictht.FieldTitle:
		m.ResetTitle()
		return nil
	case dictht.FieldValue:
		m.ResetValue()
		return nil
	case dictht.FieldDictID:
		m.ResetDictID()
		return nil
	}
	return fmt.Errorf("unknown Dictht field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DicthtMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dict != nil {
		edges = append(edges, dictht.EdgeDict)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DicthtMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictht.EdgeDict:
		if id := m.dict; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DicthtMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DicthtMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DicthtMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddict {
		edges = append(edges, dictht.EdgeDict)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DicthtMutation) EdgeCleared(name string) bool {
	switch name {
	case dictht.EdgeDict:
		return m.cleareddict
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DicthtMutation) ClearEdge(name string) error {
	switch name {
	case dictht.EdgeDict:
		m.ClearDict()
		return nil
	}
	return fmt.Errorf("unknown Dictht unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DicthtMutation) ResetEdge(name string) error {
	switch name {
	case dictht.EdgeDict:
		m.ResetDict()
		return nil
	}
	return fmt.Errorf("unknown Dictht edge %s", name)
}

// LogsMutation represents an operation that mutates the Logs nodes in the graph.
type LogsMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	_type         *string
	method        *string
	api           *string
	success       *bool
	req_content   *string
	resp_content  *string
	ip            *string
	user_agent    *string
	operatorsr    *string
	time          *int64
	addtime       *int64
	identity      *int64
	addidentity   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Logs, error)
	predicates    []predicate.Logs
}

var _ ent.Mutation = (*LogsMutation)(nil)

// logsOption allows management of the mutation configuration using functional options.
type logsOption func(*LogsMutation)

// newLogsMutation creates new mutation for the Logs entity.
func newLogsMutation(c config, op Op, opts ...logsOption) *LogsMutation {
	m := &LogsMutation{
		config:        c,
		op:            op,
		typ:           TypeLogs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogsID sets the ID field of the mutation.
func withLogsID(id int64) logsOption {
	return func(m *LogsMutation) {
		var (
			err   error
			once  sync.Once
			value *Logs
		)
		m.oldValue = func(ctx context.Context) (*Logs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Logs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogs sets the old Logs of the mutation.
func withLogs(node *Logs) logsOption {
	return func(m *LogsMutation) {
		m.oldValue = func(context.Context) (*Logs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Logs entities.
func (m *LogsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Logs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LogsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LogsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *LogsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[logs.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *LogsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[logs.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LogsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, logs.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LogsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LogsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *LogsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[logs.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *LogsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[logs.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LogsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, logs.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *LogsMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *LogsMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *LogsMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *LogsMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *LogsMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[logs.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *LogsMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[logs.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *LogsMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, logs.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *LogsMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *LogsMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *LogsMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *LogsMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *LogsMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[logs.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *LogsMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[logs.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *LogsMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, logs.FieldCreatedID)
}

// SetType sets the "type" field.
func (m *LogsMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *LogsMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *LogsMutation) ClearType() {
	m._type = nil
	m.clearedFields[logs.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *LogsMutation) TypeCleared() bool {
	_, ok := m.clearedFields[logs.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *LogsMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, logs.FieldType)
}

// SetMethod sets the "method" field.
func (m *LogsMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *LogsMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ClearMethod clears the value of the "method" field.
func (m *LogsMutation) ClearMethod() {
	m.method = nil
	m.clearedFields[logs.FieldMethod] = struct{}{}
}

// MethodCleared returns if the "method" field was cleared in this mutation.
func (m *LogsMutation) MethodCleared() bool {
	_, ok := m.clearedFields[logs.FieldMethod]
	return ok
}

// ResetMethod resets all changes to the "method" field.
func (m *LogsMutation) ResetMethod() {
	m.method = nil
	delete(m.clearedFields, logs.FieldMethod)
}

// SetAPI sets the "api" field.
func (m *LogsMutation) SetAPI(s string) {
	m.api = &s
}

// API returns the value of the "api" field in the mutation.
func (m *LogsMutation) API() (r string, exists bool) {
	v := m.api
	if v == nil {
		return
	}
	return *v, true
}

// OldAPI returns the old "api" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldAPI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPI: %w", err)
	}
	return oldValue.API, nil
}

// ClearAPI clears the value of the "api" field.
func (m *LogsMutation) ClearAPI() {
	m.api = nil
	m.clearedFields[logs.FieldAPI] = struct{}{}
}

// APICleared returns if the "api" field was cleared in this mutation.
func (m *LogsMutation) APICleared() bool {
	_, ok := m.clearedFields[logs.FieldAPI]
	return ok
}

// ResetAPI resets all changes to the "api" field.
func (m *LogsMutation) ResetAPI() {
	m.api = nil
	delete(m.clearedFields, logs.FieldAPI)
}

// SetSuccess sets the "success" field.
func (m *LogsMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *LogsMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ClearSuccess clears the value of the "success" field.
func (m *LogsMutation) ClearSuccess() {
	m.success = nil
	m.clearedFields[logs.FieldSuccess] = struct{}{}
}

// SuccessCleared returns if the "success" field was cleared in this mutation.
func (m *LogsMutation) SuccessCleared() bool {
	_, ok := m.clearedFields[logs.FieldSuccess]
	return ok
}

// ResetSuccess resets all changes to the "success" field.
func (m *LogsMutation) ResetSuccess() {
	m.success = nil
	delete(m.clearedFields, logs.FieldSuccess)
}

// SetReqContent sets the "req_content" field.
func (m *LogsMutation) SetReqContent(s string) {
	m.req_content = &s
}

// ReqContent returns the value of the "req_content" field in the mutation.
func (m *LogsMutation) ReqContent() (r string, exists bool) {
	v := m.req_content
	if v == nil {
		return
	}
	return *v, true
}

// OldReqContent returns the old "req_content" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldReqContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqContent: %w", err)
	}
	return oldValue.ReqContent, nil
}

// ClearReqContent clears the value of the "req_content" field.
func (m *LogsMutation) ClearReqContent() {
	m.req_content = nil
	m.clearedFields[logs.FieldReqContent] = struct{}{}
}

// ReqContentCleared returns if the "req_content" field was cleared in this mutation.
func (m *LogsMutation) ReqContentCleared() bool {
	_, ok := m.clearedFields[logs.FieldReqContent]
	return ok
}

// ResetReqContent resets all changes to the "req_content" field.
func (m *LogsMutation) ResetReqContent() {
	m.req_content = nil
	delete(m.clearedFields, logs.FieldReqContent)
}

// SetRespContent sets the "resp_content" field.
func (m *LogsMutation) SetRespContent(s string) {
	m.resp_content = &s
}

// RespContent returns the value of the "resp_content" field in the mutation.
func (m *LogsMutation) RespContent() (r string, exists bool) {
	v := m.resp_content
	if v == nil {
		return
	}
	return *v, true
}

// OldRespContent returns the old "resp_content" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldRespContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespContent: %w", err)
	}
	return oldValue.RespContent, nil
}

// ClearRespContent clears the value of the "resp_content" field.
func (m *LogsMutation) ClearRespContent() {
	m.resp_content = nil
	m.clearedFields[logs.FieldRespContent] = struct{}{}
}

// RespContentCleared returns if the "resp_content" field was cleared in this mutation.
func (m *LogsMutation) RespContentCleared() bool {
	_, ok := m.clearedFields[logs.FieldRespContent]
	return ok
}

// ResetRespContent resets all changes to the "resp_content" field.
func (m *LogsMutation) ResetRespContent() {
	m.resp_content = nil
	delete(m.clearedFields, logs.FieldRespContent)
}

// SetIP sets the "ip" field.
func (m *LogsMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *LogsMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *LogsMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[logs.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *LogsMutation) IPCleared() bool {
	_, ok := m.clearedFields[logs.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *LogsMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, logs.FieldIP)
}

// SetUserAgent sets the "user_agent" field.
func (m *LogsMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *LogsMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *LogsMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[logs.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *LogsMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[logs.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *LogsMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, logs.FieldUserAgent)
}

// SetOperatorsr sets the "operatorsr" field.
func (m *LogsMutation) SetOperatorsr(s string) {
	m.operatorsr = &s
}

// Operatorsr returns the value of the "operatorsr" field in the mutation.
func (m *LogsMutation) Operatorsr() (r string, exists bool) {
	v := m.operatorsr
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorsr returns the old "operatorsr" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldOperatorsr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorsr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorsr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorsr: %w", err)
	}
	return oldValue.Operatorsr, nil
}

// ClearOperatorsr clears the value of the "operatorsr" field.
func (m *LogsMutation) ClearOperatorsr() {
	m.operatorsr = nil
	m.clearedFields[logs.FieldOperatorsr] = struct{}{}
}

// OperatorsrCleared returns if the "operatorsr" field was cleared in this mutation.
func (m *LogsMutation) OperatorsrCleared() bool {
	_, ok := m.clearedFields[logs.FieldOperatorsr]
	return ok
}

// ResetOperatorsr resets all changes to the "operatorsr" field.
func (m *LogsMutation) ResetOperatorsr() {
	m.operatorsr = nil
	delete(m.clearedFields, logs.FieldOperatorsr)
}

// SetTime sets the "time" field.
func (m *LogsMutation) SetTime(i int64) {
	m.time = &i
	m.addtime = nil
}

// Time returns the value of the "time" field in the mutation.
func (m *LogsMutation) Time() (r int64, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// AddTime adds i to the "time" field.
func (m *LogsMutation) AddTime(i int64) {
	if m.addtime != nil {
		*m.addtime += i
	} else {
		m.addtime = &i
	}
}

// AddedTime returns the value that was added to the "time" field in this mutation.
func (m *LogsMutation) AddedTime() (r int64, exists bool) {
	v := m.addtime
	if v == nil {
		return
	}
	return *v, true
}

// ClearTime clears the value of the "time" field.
func (m *LogsMutation) ClearTime() {
	m.time = nil
	m.addtime = nil
	m.clearedFields[logs.FieldTime] = struct{}{}
}

// TimeCleared returns if the "time" field was cleared in this mutation.
func (m *LogsMutation) TimeCleared() bool {
	_, ok := m.clearedFields[logs.FieldTime]
	return ok
}

// ResetTime resets all changes to the "time" field.
func (m *LogsMutation) ResetTime() {
	m.time = nil
	m.addtime = nil
	delete(m.clearedFields, logs.FieldTime)
}

// SetIdentity sets the "identity" field.
func (m *LogsMutation) SetIdentity(i int64) {
	m.identity = &i
	m.addidentity = nil
}

// Identity returns the value of the "identity" field in the mutation.
func (m *LogsMutation) Identity() (r int64, exists bool) {
	v := m.identity
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentity returns the old "identity" field's value of the Logs entity.
// If the Logs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogsMutation) OldIdentity(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentity: %w", err)
	}
	return oldValue.Identity, nil
}

// AddIdentity adds i to the "identity" field.
func (m *LogsMutation) AddIdentity(i int64) {
	if m.addidentity != nil {
		*m.addidentity += i
	} else {
		m.addidentity = &i
	}
}

// AddedIdentity returns the value that was added to the "identity" field in this mutation.
func (m *LogsMutation) AddedIdentity() (r int64, exists bool) {
	v := m.addidentity
	if v == nil {
		return
	}
	return *v, true
}

// ClearIdentity clears the value of the "identity" field.
func (m *LogsMutation) ClearIdentity() {
	m.identity = nil
	m.addidentity = nil
	m.clearedFields[logs.FieldIdentity] = struct{}{}
}

// IdentityCleared returns if the "identity" field was cleared in this mutation.
func (m *LogsMutation) IdentityCleared() bool {
	_, ok := m.clearedFields[logs.FieldIdentity]
	return ok
}

// ResetIdentity resets all changes to the "identity" field.
func (m *LogsMutation) ResetIdentity() {
	m.identity = nil
	m.addidentity = nil
	delete(m.clearedFields, logs.FieldIdentity)
}

// Where appends a list predicates to the LogsMutation builder.
func (m *LogsMutation) Where(ps ...predicate.Logs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LogsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LogsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Logs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LogsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LogsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Logs).
func (m *LogsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogsMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, logs.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, logs.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, logs.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, logs.FieldCreatedID)
	}
	if m._type != nil {
		fields = append(fields, logs.FieldType)
	}
	if m.method != nil {
		fields = append(fields, logs.FieldMethod)
	}
	if m.api != nil {
		fields = append(fields, logs.FieldAPI)
	}
	if m.success != nil {
		fields = append(fields, logs.FieldSuccess)
	}
	if m.req_content != nil {
		fields = append(fields, logs.FieldReqContent)
	}
	if m.resp_content != nil {
		fields = append(fields, logs.FieldRespContent)
	}
	if m.ip != nil {
		fields = append(fields, logs.FieldIP)
	}
	if m.user_agent != nil {
		fields = append(fields, logs.FieldUserAgent)
	}
	if m.operatorsr != nil {
		fields = append(fields, logs.FieldOperatorsr)
	}
	if m.time != nil {
		fields = append(fields, logs.FieldTime)
	}
	if m.identity != nil {
		fields = append(fields, logs.FieldIdentity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldCreatedAt:
		return m.CreatedAt()
	case logs.FieldUpdatedAt:
		return m.UpdatedAt()
	case logs.FieldDelete:
		return m.Delete()
	case logs.FieldCreatedID:
		return m.CreatedID()
	case logs.FieldType:
		return m.GetType()
	case logs.FieldMethod:
		return m.Method()
	case logs.FieldAPI:
		return m.API()
	case logs.FieldSuccess:
		return m.Success()
	case logs.FieldReqContent:
		return m.ReqContent()
	case logs.FieldRespContent:
		return m.RespContent()
	case logs.FieldIP:
		return m.IP()
	case logs.FieldUserAgent:
		return m.UserAgent()
	case logs.FieldOperatorsr:
		return m.Operatorsr()
	case logs.FieldTime:
		return m.Time()
	case logs.FieldIdentity:
		return m.Identity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logs.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case logs.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case logs.FieldDelete:
		return m.OldDelete(ctx)
	case logs.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case logs.FieldType:
		return m.OldType(ctx)
	case logs.FieldMethod:
		return m.OldMethod(ctx)
	case logs.FieldAPI:
		return m.OldAPI(ctx)
	case logs.FieldSuccess:
		return m.OldSuccess(ctx)
	case logs.FieldReqContent:
		return m.OldReqContent(ctx)
	case logs.FieldRespContent:
		return m.OldRespContent(ctx)
	case logs.FieldIP:
		return m.OldIP(ctx)
	case logs.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case logs.FieldOperatorsr:
		return m.OldOperatorsr(ctx)
	case logs.FieldTime:
		return m.OldTime(ctx)
	case logs.FieldIdentity:
		return m.OldIdentity(ctx)
	}
	return nil, fmt.Errorf("unknown Logs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logs.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case logs.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case logs.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case logs.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case logs.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case logs.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case logs.FieldAPI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPI(v)
		return nil
	case logs.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case logs.FieldReqContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqContent(v)
		return nil
	case logs.FieldRespContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespContent(v)
		return nil
	case logs.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case logs.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case logs.FieldOperatorsr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorsr(v)
		return nil
	case logs.FieldTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case logs.FieldIdentity:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentity(v)
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogsMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, logs.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, logs.FieldCreatedID)
	}
	if m.addtime != nil {
		fields = append(fields, logs.FieldTime)
	}
	if m.addidentity != nil {
		fields = append(fields, logs.FieldIdentity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case logs.FieldDelete:
		return m.AddedDelete()
	case logs.FieldCreatedID:
		return m.AddedCreatedID()
	case logs.FieldTime:
		return m.AddedTime()
	case logs.FieldIdentity:
		return m.AddedIdentity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case logs.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case logs.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case logs.FieldTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTime(v)
		return nil
	case logs.FieldIdentity:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIdentity(v)
		return nil
	}
	return fmt.Errorf("unknown Logs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(logs.FieldCreatedAt) {
		fields = append(fields, logs.FieldCreatedAt)
	}
	if m.FieldCleared(logs.FieldUpdatedAt) {
		fields = append(fields, logs.FieldUpdatedAt)
	}
	if m.FieldCleared(logs.FieldDelete) {
		fields = append(fields, logs.FieldDelete)
	}
	if m.FieldCleared(logs.FieldCreatedID) {
		fields = append(fields, logs.FieldCreatedID)
	}
	if m.FieldCleared(logs.FieldType) {
		fields = append(fields, logs.FieldType)
	}
	if m.FieldCleared(logs.FieldMethod) {
		fields = append(fields, logs.FieldMethod)
	}
	if m.FieldCleared(logs.FieldAPI) {
		fields = append(fields, logs.FieldAPI)
	}
	if m.FieldCleared(logs.FieldSuccess) {
		fields = append(fields, logs.FieldSuccess)
	}
	if m.FieldCleared(logs.FieldReqContent) {
		fields = append(fields, logs.FieldReqContent)
	}
	if m.FieldCleared(logs.FieldRespContent) {
		fields = append(fields, logs.FieldRespContent)
	}
	if m.FieldCleared(logs.FieldIP) {
		fields = append(fields, logs.FieldIP)
	}
	if m.FieldCleared(logs.FieldUserAgent) {
		fields = append(fields, logs.FieldUserAgent)
	}
	if m.FieldCleared(logs.FieldOperatorsr) {
		fields = append(fields, logs.FieldOperatorsr)
	}
	if m.FieldCleared(logs.FieldTime) {
		fields = append(fields, logs.FieldTime)
	}
	if m.FieldCleared(logs.FieldIdentity) {
		fields = append(fields, logs.FieldIdentity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogsMutation) ClearField(name string) error {
	switch name {
	case logs.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case logs.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case logs.FieldDelete:
		m.ClearDelete()
		return nil
	case logs.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case logs.FieldType:
		m.ClearType()
		return nil
	case logs.FieldMethod:
		m.ClearMethod()
		return nil
	case logs.FieldAPI:
		m.ClearAPI()
		return nil
	case logs.FieldSuccess:
		m.ClearSuccess()
		return nil
	case logs.FieldReqContent:
		m.ClearReqContent()
		return nil
	case logs.FieldRespContent:
		m.ClearRespContent()
		return nil
	case logs.FieldIP:
		m.ClearIP()
		return nil
	case logs.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case logs.FieldOperatorsr:
		m.ClearOperatorsr()
		return nil
	case logs.FieldTime:
		m.ClearTime()
		return nil
	case logs.FieldIdentity:
		m.ClearIdentity()
		return nil
	}
	return fmt.Errorf("unknown Logs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogsMutation) ResetField(name string) error {
	switch name {
	case logs.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case logs.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case logs.FieldDelete:
		m.ResetDelete()
		return nil
	case logs.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case logs.FieldType:
		m.ResetType()
		return nil
	case logs.FieldMethod:
		m.ResetMethod()
		return nil
	case logs.FieldAPI:
		m.ResetAPI()
		return nil
	case logs.FieldSuccess:
		m.ResetSuccess()
		return nil
	case logs.FieldReqContent:
		m.ResetReqContent()
		return nil
	case logs.FieldRespContent:
		m.ResetRespContent()
		return nil
	case logs.FieldIP:
		m.ResetIP()
		return nil
	case logs.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case logs.FieldOperatorsr:
		m.ResetOperatorsr()
		return nil
	case logs.FieldTime:
		m.ResetTime()
		return nil
	case logs.FieldIdentity:
		m.ResetIdentity()
		return nil
	}
	return fmt.Errorf("unknown Logs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Logs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Logs edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	status          *int64
	addstatus       *int64
	_path           *string
	name            *string
	component       *string
	redirect        *string
	icon            *string
	order_no        *int64
	addorder_no     *int64
	ignore          *int64
	addignore       *int64
	menu_type       *int64
	addmenu_type    *int64
	level           *int64
	addlevel        *int64
	clearedFields   map[string]struct{}
	roles           map[int64]struct{}
	removedroles    map[int64]struct{}
	clearedroles    bool
	parent          *int64
	clearedparent   bool
	children        map[int64]struct{}
	removedchildren map[int64]struct{}
	clearedchildren bool
	done            bool
	oldValue        func(context.Context) (*Menu, error)
	predicates      []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id int64) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MenuMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[menu.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MenuMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[menu.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, menu.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MenuMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[menu.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MenuMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[menu.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, menu.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MenuMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MenuMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MenuMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MenuMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MenuMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[menu.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MenuMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[menu.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MenuMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, menu.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MenuMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MenuMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MenuMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MenuMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MenuMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[menu.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MenuMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MenuMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, menu.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MenuMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MenuMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MenuMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MenuMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MenuMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[menu.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MenuMutation) StatusCleared() bool {
	_, ok := m.clearedFields[menu.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MenuMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, menu.FieldStatus)
}

// SetPath sets the "path" field.
func (m *MenuMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *MenuMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *MenuMutation) ClearPath() {
	m._path = nil
	m.clearedFields[menu.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *MenuMutation) PathCleared() bool {
	_, ok := m.clearedFields[menu.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *MenuMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, menu.FieldPath)
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MenuMutation) ClearName() {
	m.name = nil
	m.clearedFields[menu.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MenuMutation) NameCleared() bool {
	_, ok := m.clearedFields[menu.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, menu.FieldName)
}

// SetComponent sets the "component" field.
func (m *MenuMutation) SetComponent(s string) {
	m.component = &s
}

// Component returns the value of the "component" field in the mutation.
func (m *MenuMutation) Component() (r string, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old "component" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldComponent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ClearComponent clears the value of the "component" field.
func (m *MenuMutation) ClearComponent() {
	m.component = nil
	m.clearedFields[menu.FieldComponent] = struct{}{}
}

// ComponentCleared returns if the "component" field was cleared in this mutation.
func (m *MenuMutation) ComponentCleared() bool {
	_, ok := m.clearedFields[menu.FieldComponent]
	return ok
}

// ResetComponent resets all changes to the "component" field.
func (m *MenuMutation) ResetComponent() {
	m.component = nil
	delete(m.clearedFields, menu.FieldComponent)
}

// SetRedirect sets the "redirect" field.
func (m *MenuMutation) SetRedirect(s string) {
	m.redirect = &s
}

// Redirect returns the value of the "redirect" field in the mutation.
func (m *MenuMutation) Redirect() (r string, exists bool) {
	v := m.redirect
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirect returns the old "redirect" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldRedirect(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirect: %w", err)
	}
	return oldValue.Redirect, nil
}

// ClearRedirect clears the value of the "redirect" field.
func (m *MenuMutation) ClearRedirect() {
	m.redirect = nil
	m.clearedFields[menu.FieldRedirect] = struct{}{}
}

// RedirectCleared returns if the "redirect" field was cleared in this mutation.
func (m *MenuMutation) RedirectCleared() bool {
	_, ok := m.clearedFields[menu.FieldRedirect]
	return ok
}

// ResetRedirect resets all changes to the "redirect" field.
func (m *MenuMutation) ResetRedirect() {
	m.redirect = nil
	delete(m.clearedFields, menu.FieldRedirect)
}

// SetIcon sets the "icon" field.
func (m *MenuMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *MenuMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *MenuMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[menu.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *MenuMutation) IconCleared() bool {
	_, ok := m.clearedFields[menu.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *MenuMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, menu.FieldIcon)
}

// SetParentID sets the "parent_id" field.
func (m *MenuMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *MenuMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *MenuMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *MenuMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *MenuMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, menu.FieldParentID)
}

// SetOrderNo sets the "order_no" field.
func (m *MenuMutation) SetOrderNo(i int64) {
	m.order_no = &i
	m.addorder_no = nil
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *MenuMutation) OrderNo() (r int64, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldOrderNo(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// AddOrderNo adds i to the "order_no" field.
func (m *MenuMutation) AddOrderNo(i int64) {
	if m.addorder_no != nil {
		*m.addorder_no += i
	} else {
		m.addorder_no = &i
	}
}

// AddedOrderNo returns the value that was added to the "order_no" field in this mutation.
func (m *MenuMutation) AddedOrderNo() (r int64, exists bool) {
	v := m.addorder_no
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderNo clears the value of the "order_no" field.
func (m *MenuMutation) ClearOrderNo() {
	m.order_no = nil
	m.addorder_no = nil
	m.clearedFields[menu.FieldOrderNo] = struct{}{}
}

// OrderNoCleared returns if the "order_no" field was cleared in this mutation.
func (m *MenuMutation) OrderNoCleared() bool {
	_, ok := m.clearedFields[menu.FieldOrderNo]
	return ok
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *MenuMutation) ResetOrderNo() {
	m.order_no = nil
	m.addorder_no = nil
	delete(m.clearedFields, menu.FieldOrderNo)
}

// SetIgnore sets the "ignore" field.
func (m *MenuMutation) SetIgnore(i int64) {
	m.ignore = &i
	m.addignore = nil
}

// Ignore returns the value of the "ignore" field in the mutation.
func (m *MenuMutation) Ignore() (r int64, exists bool) {
	v := m.ignore
	if v == nil {
		return
	}
	return *v, true
}

// OldIgnore returns the old "ignore" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIgnore(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIgnore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIgnore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIgnore: %w", err)
	}
	return oldValue.Ignore, nil
}

// AddIgnore adds i to the "ignore" field.
func (m *MenuMutation) AddIgnore(i int64) {
	if m.addignore != nil {
		*m.addignore += i
	} else {
		m.addignore = &i
	}
}

// AddedIgnore returns the value that was added to the "ignore" field in this mutation.
func (m *MenuMutation) AddedIgnore() (r int64, exists bool) {
	v := m.addignore
	if v == nil {
		return
	}
	return *v, true
}

// ClearIgnore clears the value of the "ignore" field.
func (m *MenuMutation) ClearIgnore() {
	m.ignore = nil
	m.addignore = nil
	m.clearedFields[menu.FieldIgnore] = struct{}{}
}

// IgnoreCleared returns if the "ignore" field was cleared in this mutation.
func (m *MenuMutation) IgnoreCleared() bool {
	_, ok := m.clearedFields[menu.FieldIgnore]
	return ok
}

// ResetIgnore resets all changes to the "ignore" field.
func (m *MenuMutation) ResetIgnore() {
	m.ignore = nil
	m.addignore = nil
	delete(m.clearedFields, menu.FieldIgnore)
}

// SetMenuType sets the "menu_type" field.
func (m *MenuMutation) SetMenuType(i int64) {
	m.menu_type = &i
	m.addmenu_type = nil
}

// MenuType returns the value of the "menu_type" field in the mutation.
func (m *MenuMutation) MenuType() (r int64, exists bool) {
	v := m.menu_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuType returns the old "menu_type" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMenuType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuType: %w", err)
	}
	return oldValue.MenuType, nil
}

// AddMenuType adds i to the "menu_type" field.
func (m *MenuMutation) AddMenuType(i int64) {
	if m.addmenu_type != nil {
		*m.addmenu_type += i
	} else {
		m.addmenu_type = &i
	}
}

// AddedMenuType returns the value that was added to the "menu_type" field in this mutation.
func (m *MenuMutation) AddedMenuType() (r int64, exists bool) {
	v := m.addmenu_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearMenuType clears the value of the "menu_type" field.
func (m *MenuMutation) ClearMenuType() {
	m.menu_type = nil
	m.addmenu_type = nil
	m.clearedFields[menu.FieldMenuType] = struct{}{}
}

// MenuTypeCleared returns if the "menu_type" field was cleared in this mutation.
func (m *MenuMutation) MenuTypeCleared() bool {
	_, ok := m.clearedFields[menu.FieldMenuType]
	return ok
}

// ResetMenuType resets all changes to the "menu_type" field.
func (m *MenuMutation) ResetMenuType() {
	m.menu_type = nil
	m.addmenu_type = nil
	delete(m.clearedFields, menu.FieldMenuType)
}

// SetLevel sets the "level" field.
func (m *MenuMutation) SetLevel(i int64) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *MenuMutation) Level() (r int64, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldLevel(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *MenuMutation) AddLevel(i int64) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *MenuMutation) AddedLevel() (r int64, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevel clears the value of the "level" field.
func (m *MenuMutation) ClearLevel() {
	m.level = nil
	m.addlevel = nil
	m.clearedFields[menu.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *MenuMutation) LevelCleared() bool {
	_, ok := m.clearedFields[menu.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *MenuMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
	delete(m.clearedFields, menu.FieldLevel)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *MenuMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *MenuMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *MenuMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *MenuMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *MenuMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *MenuMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *MenuMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// ClearParent clears the "parent" edge to the Menu entity.
func (m *MenuMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Menu entity was cleared.
func (m *MenuMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *MenuMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Menu entity by ids.
func (m *MenuMutation) AddChildIDs(ids ...int64) {
	if m.children == nil {
		m.children = make(map[int64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Menu entity.
func (m *MenuMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Menu entity was cleared.
func (m *MenuMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Menu entity by IDs.
func (m *MenuMutation) RemoveChildIDs(ids ...int64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Menu entity.
func (m *MenuMutation) RemovedChildrenIDs() (ids []int64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *MenuMutation) ChildrenIDs() (ids []int64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *MenuMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, menu.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, menu.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, menu.FieldStatus)
	}
	if m._path != nil {
		fields = append(fields, menu.FieldPath)
	}
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.component != nil {
		fields = append(fields, menu.FieldComponent)
	}
	if m.redirect != nil {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.icon != nil {
		fields = append(fields, menu.FieldIcon)
	}
	if m.parent != nil {
		fields = append(fields, menu.FieldParentID)
	}
	if m.order_no != nil {
		fields = append(fields, menu.FieldOrderNo)
	}
	if m.ignore != nil {
		fields = append(fields, menu.FieldIgnore)
	}
	if m.menu_type != nil {
		fields = append(fields, menu.FieldMenuType)
	}
	if m.level != nil {
		fields = append(fields, menu.FieldLevel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreatedAt:
		return m.CreatedAt()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	case menu.FieldDelete:
		return m.Delete()
	case menu.FieldCreatedID:
		return m.CreatedID()
	case menu.FieldStatus:
		return m.Status()
	case menu.FieldPath:
		return m.Path()
	case menu.FieldName:
		return m.Name()
	case menu.FieldComponent:
		return m.Component()
	case menu.FieldRedirect:
		return m.Redirect()
	case menu.FieldIcon:
		return m.Icon()
	case menu.FieldParentID:
		return m.ParentID()
	case menu.FieldOrderNo:
		return m.OrderNo()
	case menu.FieldIgnore:
		return m.Ignore()
	case menu.FieldMenuType:
		return m.MenuType()
	case menu.FieldLevel:
		return m.Level()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menu.FieldDelete:
		return m.OldDelete(ctx)
	case menu.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case menu.FieldStatus:
		return m.OldStatus(ctx)
	case menu.FieldPath:
		return m.OldPath(ctx)
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldComponent:
		return m.OldComponent(ctx)
	case menu.FieldRedirect:
		return m.OldRedirect(ctx)
	case menu.FieldIcon:
		return m.OldIcon(ctx)
	case menu.FieldParentID:
		return m.OldParentID(ctx)
	case menu.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case menu.FieldIgnore:
		return m.OldIgnore(ctx)
	case menu.FieldMenuType:
		return m.OldMenuType(ctx)
	case menu.FieldLevel:
		return m.OldLevel(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menu.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case menu.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case menu.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case menu.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldComponent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	case menu.FieldRedirect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirect(v)
		return nil
	case menu.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case menu.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case menu.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case menu.FieldIgnore:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIgnore(v)
		return nil
	case menu.FieldMenuType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuType(v)
		return nil
	case menu.FieldLevel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, menu.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, menu.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, menu.FieldStatus)
	}
	if m.addorder_no != nil {
		fields = append(fields, menu.FieldOrderNo)
	}
	if m.addignore != nil {
		fields = append(fields, menu.FieldIgnore)
	}
	if m.addmenu_type != nil {
		fields = append(fields, menu.FieldMenuType)
	}
	if m.addlevel != nil {
		fields = append(fields, menu.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldDelete:
		return m.AddedDelete()
	case menu.FieldCreatedID:
		return m.AddedCreatedID()
	case menu.FieldStatus:
		return m.AddedStatus()
	case menu.FieldOrderNo:
		return m.AddedOrderNo()
	case menu.FieldIgnore:
		return m.AddedIgnore()
	case menu.FieldMenuType:
		return m.AddedMenuType()
	case menu.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case menu.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case menu.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case menu.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNo(v)
		return nil
	case menu.FieldIgnore:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIgnore(v)
		return nil
	case menu.FieldMenuType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMenuType(v)
		return nil
	case menu.FieldLevel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldCreatedAt) {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.FieldCleared(menu.FieldUpdatedAt) {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.FieldCleared(menu.FieldDelete) {
		fields = append(fields, menu.FieldDelete)
	}
	if m.FieldCleared(menu.FieldCreatedID) {
		fields = append(fields, menu.FieldCreatedID)
	}
	if m.FieldCleared(menu.FieldStatus) {
		fields = append(fields, menu.FieldStatus)
	}
	if m.FieldCleared(menu.FieldPath) {
		fields = append(fields, menu.FieldPath)
	}
	if m.FieldCleared(menu.FieldName) {
		fields = append(fields, menu.FieldName)
	}
	if m.FieldCleared(menu.FieldComponent) {
		fields = append(fields, menu.FieldComponent)
	}
	if m.FieldCleared(menu.FieldRedirect) {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.FieldCleared(menu.FieldIcon) {
		fields = append(fields, menu.FieldIcon)
	}
	if m.FieldCleared(menu.FieldParentID) {
		fields = append(fields, menu.FieldParentID)
	}
	if m.FieldCleared(menu.FieldOrderNo) {
		fields = append(fields, menu.FieldOrderNo)
	}
	if m.FieldCleared(menu.FieldIgnore) {
		fields = append(fields, menu.FieldIgnore)
	}
	if m.FieldCleared(menu.FieldMenuType) {
		fields = append(fields, menu.FieldMenuType)
	}
	if m.FieldCleared(menu.FieldLevel) {
		fields = append(fields, menu.FieldLevel)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case menu.FieldDelete:
		m.ClearDelete()
		return nil
	case menu.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case menu.FieldStatus:
		m.ClearStatus()
		return nil
	case menu.FieldPath:
		m.ClearPath()
		return nil
	case menu.FieldName:
		m.ClearName()
		return nil
	case menu.FieldComponent:
		m.ClearComponent()
		return nil
	case menu.FieldRedirect:
		m.ClearRedirect()
		return nil
	case menu.FieldIcon:
		m.ClearIcon()
		return nil
	case menu.FieldParentID:
		m.ClearParentID()
		return nil
	case menu.FieldOrderNo:
		m.ClearOrderNo()
		return nil
	case menu.FieldIgnore:
		m.ClearIgnore()
		return nil
	case menu.FieldMenuType:
		m.ClearMenuType()
		return nil
	case menu.FieldLevel:
		m.ClearLevel()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menu.FieldDelete:
		m.ResetDelete()
		return nil
	case menu.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case menu.FieldStatus:
		m.ResetStatus()
		return nil
	case menu.FieldPath:
		m.ResetPath()
		return nil
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldComponent:
		m.ResetComponent()
		return nil
	case menu.FieldRedirect:
		m.ResetRedirect()
		return nil
	case menu.FieldIcon:
		m.ResetIcon()
		return nil
	case menu.FieldParentID:
		m.ResetParentID()
		return nil
	case menu.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case menu.FieldIgnore:
		m.ResetIgnore()
		return nil
	case menu.FieldMenuType:
		m.ResetMenuType()
		return nil
	case menu.FieldLevel:
		m.ResetLevel()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.roles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.parent != nil {
		edges = append(edges, menu.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedroles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.removedchildren != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedroles {
		edges = append(edges, menu.EdgeRoles)
	}
	if m.clearedparent {
		edges = append(edges, menu.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, menu.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeRoles:
		return m.clearedroles
	case menu.EdgeParent:
		return m.clearedparent
	case menu.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeRoles:
		m.ResetRoles()
		return nil
	case menu.EdgeParent:
		m.ResetParent()
		return nil
	case menu.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// MessagesMutation represents an operation that mutates the Messages nodes in the graph.
type MessagesMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	_type         *string
	to_user_id    *string
	from_user_id  *string
	content       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Messages, error)
	predicates    []predicate.Messages
}

var _ ent.Mutation = (*MessagesMutation)(nil)

// messagesOption allows management of the mutation configuration using functional options.
type messagesOption func(*MessagesMutation)

// newMessagesMutation creates new mutation for the Messages entity.
func newMessagesMutation(c config, op Op, opts ...messagesOption) *MessagesMutation {
	m := &MessagesMutation{
		config:        c,
		op:            op,
		typ:           TypeMessages,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessagesID sets the ID field of the mutation.
func withMessagesID(id int64) messagesOption {
	return func(m *MessagesMutation) {
		var (
			err   error
			once  sync.Once
			value *Messages
		)
		m.oldValue = func(ctx context.Context) (*Messages, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Messages.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessages sets the old Messages of the mutation.
func withMessages(node *Messages) messagesOption {
	return func(m *MessagesMutation) {
		m.oldValue = func(context.Context) (*Messages, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessagesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessagesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Messages entities.
func (m *MessagesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessagesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessagesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Messages.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessagesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessagesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MessagesMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[messages.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MessagesMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[messages.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessagesMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, messages.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessagesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessagesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MessagesMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[messages.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MessagesMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[messages.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessagesMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, messages.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MessagesMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MessagesMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MessagesMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MessagesMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MessagesMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[messages.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MessagesMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[messages.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MessagesMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, messages.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MessagesMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MessagesMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MessagesMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MessagesMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MessagesMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[messages.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MessagesMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[messages.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MessagesMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, messages.FieldCreatedID)
}

// SetType sets the "type" field.
func (m *MessagesMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessagesMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *MessagesMutation) ClearType() {
	m._type = nil
	m.clearedFields[messages.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *MessagesMutation) TypeCleared() bool {
	_, ok := m.clearedFields[messages.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *MessagesMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, messages.FieldType)
}

// SetToUserID sets the "to_user_id" field.
func (m *MessagesMutation) SetToUserID(s string) {
	m.to_user_id = &s
}

// ToUserID returns the value of the "to_user_id" field in the mutation.
func (m *MessagesMutation) ToUserID() (r string, exists bool) {
	v := m.to_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToUserID returns the old "to_user_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldToUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToUserID: %w", err)
	}
	return oldValue.ToUserID, nil
}

// ClearToUserID clears the value of the "to_user_id" field.
func (m *MessagesMutation) ClearToUserID() {
	m.to_user_id = nil
	m.clearedFields[messages.FieldToUserID] = struct{}{}
}

// ToUserIDCleared returns if the "to_user_id" field was cleared in this mutation.
func (m *MessagesMutation) ToUserIDCleared() bool {
	_, ok := m.clearedFields[messages.FieldToUserID]
	return ok
}

// ResetToUserID resets all changes to the "to_user_id" field.
func (m *MessagesMutation) ResetToUserID() {
	m.to_user_id = nil
	delete(m.clearedFields, messages.FieldToUserID)
}

// SetFromUserID sets the "from_user_id" field.
func (m *MessagesMutation) SetFromUserID(s string) {
	m.from_user_id = &s
}

// FromUserID returns the value of the "from_user_id" field in the mutation.
func (m *MessagesMutation) FromUserID() (r string, exists bool) {
	v := m.from_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromUserID returns the old "from_user_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldFromUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromUserID: %w", err)
	}
	return oldValue.FromUserID, nil
}

// ClearFromUserID clears the value of the "from_user_id" field.
func (m *MessagesMutation) ClearFromUserID() {
	m.from_user_id = nil
	m.clearedFields[messages.FieldFromUserID] = struct{}{}
}

// FromUserIDCleared returns if the "from_user_id" field was cleared in this mutation.
func (m *MessagesMutation) FromUserIDCleared() bool {
	_, ok := m.clearedFields[messages.FieldFromUserID]
	return ok
}

// ResetFromUserID resets all changes to the "from_user_id" field.
func (m *MessagesMutation) ResetFromUserID() {
	m.from_user_id = nil
	delete(m.clearedFields, messages.FieldFromUserID)
}

// SetContent sets the "content" field.
func (m *MessagesMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessagesMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *MessagesMutation) ClearContent() {
	m.content = nil
	m.clearedFields[messages.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *MessagesMutation) ContentCleared() bool {
	_, ok := m.clearedFields[messages.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *MessagesMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, messages.FieldContent)
}

// Where appends a list predicates to the MessagesMutation builder.
func (m *MessagesMutation) Where(ps ...predicate.Messages) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessagesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessagesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Messages, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessagesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessagesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Messages).
func (m *MessagesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessagesMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, messages.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, messages.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, messages.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, messages.FieldCreatedID)
	}
	if m._type != nil {
		fields = append(fields, messages.FieldType)
	}
	if m.to_user_id != nil {
		fields = append(fields, messages.FieldToUserID)
	}
	if m.from_user_id != nil {
		fields = append(fields, messages.FieldFromUserID)
	}
	if m.content != nil {
		fields = append(fields, messages.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessagesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messages.FieldCreatedAt:
		return m.CreatedAt()
	case messages.FieldUpdatedAt:
		return m.UpdatedAt()
	case messages.FieldDelete:
		return m.Delete()
	case messages.FieldCreatedID:
		return m.CreatedID()
	case messages.FieldType:
		return m.GetType()
	case messages.FieldToUserID:
		return m.ToUserID()
	case messages.FieldFromUserID:
		return m.FromUserID()
	case messages.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessagesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messages.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case messages.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case messages.FieldDelete:
		return m.OldDelete(ctx)
	case messages.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case messages.FieldType:
		return m.OldType(ctx)
	case messages.FieldToUserID:
		return m.OldToUserID(ctx)
	case messages.FieldFromUserID:
		return m.OldFromUserID(ctx)
	case messages.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Messages field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messages.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case messages.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case messages.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case messages.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case messages.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case messages.FieldToUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToUserID(v)
		return nil
	case messages.FieldFromUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromUserID(v)
		return nil
	case messages.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Messages field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessagesMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, messages.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, messages.FieldCreatedID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessagesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case messages.FieldDelete:
		return m.AddedDelete()
	case messages.FieldCreatedID:
		return m.AddedCreatedID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case messages.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case messages.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	}
	return fmt.Errorf("unknown Messages numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessagesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(messages.FieldCreatedAt) {
		fields = append(fields, messages.FieldCreatedAt)
	}
	if m.FieldCleared(messages.FieldUpdatedAt) {
		fields = append(fields, messages.FieldUpdatedAt)
	}
	if m.FieldCleared(messages.FieldDelete) {
		fields = append(fields, messages.FieldDelete)
	}
	if m.FieldCleared(messages.FieldCreatedID) {
		fields = append(fields, messages.FieldCreatedID)
	}
	if m.FieldCleared(messages.FieldType) {
		fields = append(fields, messages.FieldType)
	}
	if m.FieldCleared(messages.FieldToUserID) {
		fields = append(fields, messages.FieldToUserID)
	}
	if m.FieldCleared(messages.FieldFromUserID) {
		fields = append(fields, messages.FieldFromUserID)
	}
	if m.FieldCleared(messages.FieldContent) {
		fields = append(fields, messages.FieldContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessagesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessagesMutation) ClearField(name string) error {
	switch name {
	case messages.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case messages.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case messages.FieldDelete:
		m.ClearDelete()
		return nil
	case messages.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case messages.FieldType:
		m.ClearType()
		return nil
	case messages.FieldToUserID:
		m.ClearToUserID()
		return nil
	case messages.FieldFromUserID:
		m.ClearFromUserID()
		return nil
	case messages.FieldContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown Messages nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessagesMutation) ResetField(name string) error {
	switch name {
	case messages.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case messages.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case messages.FieldDelete:
		m.ResetDelete()
		return nil
	case messages.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case messages.FieldType:
		m.ResetType()
		return nil
	case messages.FieldToUserID:
		m.ResetToUserID()
		return nil
	case messages.FieldFromUserID:
		m.ResetFromUserID()
		return nil
	case messages.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Messages field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessagesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessagesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessagesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessagesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessagesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessagesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessagesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Messages unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessagesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Messages edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	name          *string
	code          *string
	desc          *string
	order_no      *int64
	addorder_no   *int64
	menus         *[]int64
	appendmenus   []int64
	apis          *[]int64
	appendapis    []int64
	clearedFields map[string]struct{}
	menu          map[int64]struct{}
	removedmenu   map[int64]struct{}
	clearedmenu   bool
	api           map[int64]struct{}
	removedapi    map[int64]struct{}
	clearedapi    bool
	done          bool
	oldValue      func(context.Context) (*Role, error)
	predicates    []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int64) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RoleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[role.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RoleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, role.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[role.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, role.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *RoleMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *RoleMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *RoleMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *RoleMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *RoleMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[role.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *RoleMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[role.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *RoleMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, role.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *RoleMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *RoleMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *RoleMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *RoleMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *RoleMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[role.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *RoleMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[role.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *RoleMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, role.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *RoleMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RoleMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *RoleMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RoleMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *RoleMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[role.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RoleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[role.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RoleMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, role.FieldStatus)
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *RoleMutation) ClearName() {
	m.name = nil
	m.clearedFields[role.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *RoleMutation) NameCleared() bool {
	_, ok := m.clearedFields[role.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, role.FieldName)
}

// SetCode sets the "code" field.
func (m *RoleMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RoleMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *RoleMutation) ClearCode() {
	m.code = nil
	m.clearedFields[role.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *RoleMutation) CodeCleared() bool {
	_, ok := m.clearedFields[role.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *RoleMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, role.FieldCode)
}

// SetDesc sets the "desc" field.
func (m *RoleMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *RoleMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *RoleMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[role.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *RoleMutation) DescCleared() bool {
	_, ok := m.clearedFields[role.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *RoleMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, role.FieldDesc)
}

// SetOrderNo sets the "order_no" field.
func (m *RoleMutation) SetOrderNo(i int64) {
	m.order_no = &i
	m.addorder_no = nil
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *RoleMutation) OrderNo() (r int64, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldOrderNo(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// AddOrderNo adds i to the "order_no" field.
func (m *RoleMutation) AddOrderNo(i int64) {
	if m.addorder_no != nil {
		*m.addorder_no += i
	} else {
		m.addorder_no = &i
	}
}

// AddedOrderNo returns the value that was added to the "order_no" field in this mutation.
func (m *RoleMutation) AddedOrderNo() (r int64, exists bool) {
	v := m.addorder_no
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderNo clears the value of the "order_no" field.
func (m *RoleMutation) ClearOrderNo() {
	m.order_no = nil
	m.addorder_no = nil
	m.clearedFields[role.FieldOrderNo] = struct{}{}
}

// OrderNoCleared returns if the "order_no" field was cleared in this mutation.
func (m *RoleMutation) OrderNoCleared() bool {
	_, ok := m.clearedFields[role.FieldOrderNo]
	return ok
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *RoleMutation) ResetOrderNo() {
	m.order_no = nil
	m.addorder_no = nil
	delete(m.clearedFields, role.FieldOrderNo)
}

// SetMenus sets the "menus" field.
func (m *RoleMutation) SetMenus(i []int64) {
	m.menus = &i
	m.appendmenus = nil
}

// Menus returns the value of the "menus" field in the mutation.
func (m *RoleMutation) Menus() (r []int64, exists bool) {
	v := m.menus
	if v == nil {
		return
	}
	return *v, true
}

// OldMenus returns the old "menus" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldMenus(ctx context.Context) (v []int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenus: %w", err)
	}
	return oldValue.Menus, nil
}

// AppendMenus adds i to the "menus" field.
func (m *RoleMutation) AppendMenus(i []int64) {
	m.appendmenus = append(m.appendmenus, i...)
}

// AppendedMenus returns the list of values that were appended to the "menus" field in this mutation.
func (m *RoleMutation) AppendedMenus() ([]int64, bool) {
	if len(m.appendmenus) == 0 {
		return nil, false
	}
	return m.appendmenus, true
}

// ClearMenus clears the value of the "menus" field.
func (m *RoleMutation) ClearMenus() {
	m.menus = nil
	m.appendmenus = nil
	m.clearedFields[role.FieldMenus] = struct{}{}
}

// MenusCleared returns if the "menus" field was cleared in this mutation.
func (m *RoleMutation) MenusCleared() bool {
	_, ok := m.clearedFields[role.FieldMenus]
	return ok
}

// ResetMenus resets all changes to the "menus" field.
func (m *RoleMutation) ResetMenus() {
	m.menus = nil
	m.appendmenus = nil
	delete(m.clearedFields, role.FieldMenus)
}

// SetApis sets the "apis" field.
func (m *RoleMutation) SetApis(i []int64) {
	m.apis = &i
	m.appendapis = nil
}

// Apis returns the value of the "apis" field in the mutation.
func (m *RoleMutation) Apis() (r []int64, exists bool) {
	v := m.apis
	if v == nil {
		return
	}
	return *v, true
}

// OldApis returns the old "apis" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldApis(ctx context.Context) (v []int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApis: %w", err)
	}
	return oldValue.Apis, nil
}

// AppendApis adds i to the "apis" field.
func (m *RoleMutation) AppendApis(i []int64) {
	m.appendapis = append(m.appendapis, i...)
}

// AppendedApis returns the list of values that were appended to the "apis" field in this mutation.
func (m *RoleMutation) AppendedApis() ([]int64, bool) {
	if len(m.appendapis) == 0 {
		return nil, false
	}
	return m.appendapis, true
}

// ClearApis clears the value of the "apis" field.
func (m *RoleMutation) ClearApis() {
	m.apis = nil
	m.appendapis = nil
	m.clearedFields[role.FieldApis] = struct{}{}
}

// ApisCleared returns if the "apis" field was cleared in this mutation.
func (m *RoleMutation) ApisCleared() bool {
	_, ok := m.clearedFields[role.FieldApis]
	return ok
}

// ResetApis resets all changes to the "apis" field.
func (m *RoleMutation) ResetApis() {
	m.apis = nil
	m.appendapis = nil
	delete(m.clearedFields, role.FieldApis)
}

// AddMenuIDs adds the "menu" edge to the Menu entity by ids.
func (m *RoleMutation) AddMenuIDs(ids ...int64) {
	if m.menu == nil {
		m.menu = make(map[int64]struct{})
	}
	for i := range ids {
		m.menu[ids[i]] = struct{}{}
	}
}

// ClearMenu clears the "menu" edge to the Menu entity.
func (m *RoleMutation) ClearMenu() {
	m.clearedmenu = true
}

// MenuCleared reports if the "menu" edge to the Menu entity was cleared.
func (m *RoleMutation) MenuCleared() bool {
	return m.clearedmenu
}

// RemoveMenuIDs removes the "menu" edge to the Menu entity by IDs.
func (m *RoleMutation) RemoveMenuIDs(ids ...int64) {
	if m.removedmenu == nil {
		m.removedmenu = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.menu, ids[i])
		m.removedmenu[ids[i]] = struct{}{}
	}
}

// RemovedMenu returns the removed IDs of the "menu" edge to the Menu entity.
func (m *RoleMutation) RemovedMenuIDs() (ids []int64) {
	for id := range m.removedmenu {
		ids = append(ids, id)
	}
	return
}

// MenuIDs returns the "menu" edge IDs in the mutation.
func (m *RoleMutation) MenuIDs() (ids []int64) {
	for id := range m.menu {
		ids = append(ids, id)
	}
	return
}

// ResetMenu resets all changes to the "menu" edge.
func (m *RoleMutation) ResetMenu() {
	m.menu = nil
	m.clearedmenu = false
	m.removedmenu = nil
}

// AddAPIIDs adds the "api" edge to the API entity by ids.
func (m *RoleMutation) AddAPIIDs(ids ...int64) {
	if m.api == nil {
		m.api = make(map[int64]struct{})
	}
	for i := range ids {
		m.api[ids[i]] = struct{}{}
	}
}

// ClearAPI clears the "api" edge to the API entity.
func (m *RoleMutation) ClearAPI() {
	m.clearedapi = true
}

// APICleared reports if the "api" edge to the API entity was cleared.
func (m *RoleMutation) APICleared() bool {
	return m.clearedapi
}

// RemoveAPIIDs removes the "api" edge to the API entity by IDs.
func (m *RoleMutation) RemoveAPIIDs(ids ...int64) {
	if m.removedapi == nil {
		m.removedapi = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.api, ids[i])
		m.removedapi[ids[i]] = struct{}{}
	}
}

// RemovedAPI returns the removed IDs of the "api" edge to the API entity.
func (m *RoleMutation) RemovedAPIIDs() (ids []int64) {
	for id := range m.removedapi {
		ids = append(ids, id)
	}
	return
}

// APIIDs returns the "api" edge IDs in the mutation.
func (m *RoleMutation) APIIDs() (ids []int64) {
	for id := range m.api {
		ids = append(ids, id)
	}
	return
}

// ResetAPI resets all changes to the "api" edge.
func (m *RoleMutation) ResetAPI() {
	m.api = nil
	m.clearedapi = false
	m.removedapi = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, role.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, role.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.code != nil {
		fields = append(fields, role.FieldCode)
	}
	if m.desc != nil {
		fields = append(fields, role.FieldDesc)
	}
	if m.order_no != nil {
		fields = append(fields, role.FieldOrderNo)
	}
	if m.menus != nil {
		fields = append(fields, role.FieldMenus)
	}
	if m.apis != nil {
		fields = append(fields, role.FieldApis)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDelete:
		return m.Delete()
	case role.FieldCreatedID:
		return m.CreatedID()
	case role.FieldStatus:
		return m.Status()
	case role.FieldName:
		return m.Name()
	case role.FieldCode:
		return m.Code()
	case role.FieldDesc:
		return m.Desc()
	case role.FieldOrderNo:
		return m.OrderNo()
	case role.FieldMenus:
		return m.Menus()
	case role.FieldApis:
		return m.Apis()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDelete:
		return m.OldDelete(ctx)
	case role.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case role.FieldStatus:
		return m.OldStatus(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldCode:
		return m.OldCode(ctx)
	case role.FieldDesc:
		return m.OldDesc(ctx)
	case role.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case role.FieldMenus:
		return m.OldMenus(ctx)
	case role.FieldApis:
		return m.OldApis(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case role.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case role.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case role.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case role.FieldMenus:
		v, ok := value.([]int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenus(v)
		return nil
	case role.FieldApis:
		v, ok := value.([]int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApis(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, role.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, role.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.addorder_no != nil {
		fields = append(fields, role.FieldOrderNo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldDelete:
		return m.AddedDelete()
	case role.FieldCreatedID:
		return m.AddedCreatedID()
	case role.FieldStatus:
		return m.AddedStatus()
	case role.FieldOrderNo:
		return m.AddedOrderNo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case role.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case role.FieldOrderNo:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderNo(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldCreatedAt) {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.FieldCleared(role.FieldUpdatedAt) {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.FieldCleared(role.FieldDelete) {
		fields = append(fields, role.FieldDelete)
	}
	if m.FieldCleared(role.FieldCreatedID) {
		fields = append(fields, role.FieldCreatedID)
	}
	if m.FieldCleared(role.FieldStatus) {
		fields = append(fields, role.FieldStatus)
	}
	if m.FieldCleared(role.FieldName) {
		fields = append(fields, role.FieldName)
	}
	if m.FieldCleared(role.FieldCode) {
		fields = append(fields, role.FieldCode)
	}
	if m.FieldCleared(role.FieldDesc) {
		fields = append(fields, role.FieldDesc)
	}
	if m.FieldCleared(role.FieldOrderNo) {
		fields = append(fields, role.FieldOrderNo)
	}
	if m.FieldCleared(role.FieldMenus) {
		fields = append(fields, role.FieldMenus)
	}
	if m.FieldCleared(role.FieldApis) {
		fields = append(fields, role.FieldApis)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case role.FieldDelete:
		m.ClearDelete()
		return nil
	case role.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case role.FieldStatus:
		m.ClearStatus()
		return nil
	case role.FieldName:
		m.ClearName()
		return nil
	case role.FieldCode:
		m.ClearCode()
		return nil
	case role.FieldDesc:
		m.ClearDesc()
		return nil
	case role.FieldOrderNo:
		m.ClearOrderNo()
		return nil
	case role.FieldMenus:
		m.ClearMenus()
		return nil
	case role.FieldApis:
		m.ClearApis()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDelete:
		m.ResetDelete()
		return nil
	case role.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case role.FieldStatus:
		m.ResetStatus()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldCode:
		m.ResetCode()
		return nil
	case role.FieldDesc:
		m.ResetDesc()
		return nil
	case role.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case role.FieldMenus:
		m.ResetMenus()
		return nil
	case role.FieldApis:
		m.ResetApis()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.menu != nil {
		edges = append(edges, role.EdgeMenu)
	}
	if m.api != nil {
		edges = append(edges, role.EdgeAPI)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenu:
		ids := make([]ent.Value, 0, len(m.menu))
		for id := range m.menu {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeAPI:
		ids := make([]ent.Value, 0, len(m.api))
		for id := range m.api {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmenu != nil {
		edges = append(edges, role.EdgeMenu)
	}
	if m.removedapi != nil {
		edges = append(edges, role.EdgeAPI)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenu:
		ids := make([]ent.Value, 0, len(m.removedmenu))
		for id := range m.removedmenu {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeAPI:
		ids := make([]ent.Value, 0, len(m.removedapi))
		for id := range m.removedapi {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmenu {
		edges = append(edges, role.EdgeMenu)
	}
	if m.clearedapi {
		edges = append(edges, role.EdgeAPI)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeMenu:
		return m.clearedmenu
	case role.EdgeAPI:
		return m.clearedapi
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeMenu:
		m.ResetMenu()
		return nil
	case role.EdgeAPI:
		m.ResetAPI()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SmsMutation represents an operation that mutates the Sms nodes in the graph.
type SmsMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	status          *int64
	addstatus       *int64
	notice_count    *int64
	addnotice_count *int64
	used_notice     *int64
	addused_notice  *int64
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Sms, error)
	predicates      []predicate.Sms
}

var _ ent.Mutation = (*SmsMutation)(nil)

// smsOption allows management of the mutation configuration using functional options.
type smsOption func(*SmsMutation)

// newSmsMutation creates new mutation for the Sms entity.
func newSmsMutation(c config, op Op, opts ...smsOption) *SmsMutation {
	m := &SmsMutation{
		config:        c,
		op:            op,
		typ:           TypeSms,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSmsID sets the ID field of the mutation.
func withSmsID(id int64) smsOption {
	return func(m *SmsMutation) {
		var (
			err   error
			once  sync.Once
			value *Sms
		)
		m.oldValue = func(ctx context.Context) (*Sms, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Sms.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSms sets the old Sms of the mutation.
func withSms(node *Sms) smsOption {
	return func(m *SmsMutation) {
		m.oldValue = func(context.Context) (*Sms, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SmsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SmsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Sms entities.
func (m *SmsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SmsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SmsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Sms.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SmsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SmsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Sms entity.
// If the Sms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SmsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[sms.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SmsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[sms.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SmsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, sms.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SmsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SmsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Sms entity.
// If the Sms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SmsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[sms.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SmsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[sms.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SmsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, sms.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *SmsMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *SmsMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Sms entity.
// If the Sms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *SmsMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *SmsMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *SmsMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[sms.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *SmsMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[sms.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *SmsMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, sms.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *SmsMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *SmsMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Sms entity.
// If the Sms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *SmsMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *SmsMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *SmsMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[sms.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *SmsMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[sms.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *SmsMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, sms.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *SmsMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SmsMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Sms entity.
// If the Sms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SmsMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SmsMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *SmsMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[sms.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *SmsMutation) StatusCleared() bool {
	_, ok := m.clearedFields[sms.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *SmsMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, sms.FieldStatus)
}

// SetNoticeCount sets the "notice_count" field.
func (m *SmsMutation) SetNoticeCount(i int64) {
	m.notice_count = &i
	m.addnotice_count = nil
}

// NoticeCount returns the value of the "notice_count" field in the mutation.
func (m *SmsMutation) NoticeCount() (r int64, exists bool) {
	v := m.notice_count
	if v == nil {
		return
	}
	return *v, true
}

// OldNoticeCount returns the old "notice_count" field's value of the Sms entity.
// If the Sms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsMutation) OldNoticeCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoticeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoticeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoticeCount: %w", err)
	}
	return oldValue.NoticeCount, nil
}

// AddNoticeCount adds i to the "notice_count" field.
func (m *SmsMutation) AddNoticeCount(i int64) {
	if m.addnotice_count != nil {
		*m.addnotice_count += i
	} else {
		m.addnotice_count = &i
	}
}

// AddedNoticeCount returns the value that was added to the "notice_count" field in this mutation.
func (m *SmsMutation) AddedNoticeCount() (r int64, exists bool) {
	v := m.addnotice_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearNoticeCount clears the value of the "notice_count" field.
func (m *SmsMutation) ClearNoticeCount() {
	m.notice_count = nil
	m.addnotice_count = nil
	m.clearedFields[sms.FieldNoticeCount] = struct{}{}
}

// NoticeCountCleared returns if the "notice_count" field was cleared in this mutation.
func (m *SmsMutation) NoticeCountCleared() bool {
	_, ok := m.clearedFields[sms.FieldNoticeCount]
	return ok
}

// ResetNoticeCount resets all changes to the "notice_count" field.
func (m *SmsMutation) ResetNoticeCount() {
	m.notice_count = nil
	m.addnotice_count = nil
	delete(m.clearedFields, sms.FieldNoticeCount)
}

// SetUsedNotice sets the "used_notice" field.
func (m *SmsMutation) SetUsedNotice(i int64) {
	m.used_notice = &i
	m.addused_notice = nil
}

// UsedNotice returns the value of the "used_notice" field in the mutation.
func (m *SmsMutation) UsedNotice() (r int64, exists bool) {
	v := m.used_notice
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedNotice returns the old "used_notice" field's value of the Sms entity.
// If the Sms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsMutation) OldUsedNotice(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedNotice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedNotice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedNotice: %w", err)
	}
	return oldValue.UsedNotice, nil
}

// AddUsedNotice adds i to the "used_notice" field.
func (m *SmsMutation) AddUsedNotice(i int64) {
	if m.addused_notice != nil {
		*m.addused_notice += i
	} else {
		m.addused_notice = &i
	}
}

// AddedUsedNotice returns the value that was added to the "used_notice" field in this mutation.
func (m *SmsMutation) AddedUsedNotice() (r int64, exists bool) {
	v := m.addused_notice
	if v == nil {
		return
	}
	return *v, true
}

// ClearUsedNotice clears the value of the "used_notice" field.
func (m *SmsMutation) ClearUsedNotice() {
	m.used_notice = nil
	m.addused_notice = nil
	m.clearedFields[sms.FieldUsedNotice] = struct{}{}
}

// UsedNoticeCleared returns if the "used_notice" field was cleared in this mutation.
func (m *SmsMutation) UsedNoticeCleared() bool {
	_, ok := m.clearedFields[sms.FieldUsedNotice]
	return ok
}

// ResetUsedNotice resets all changes to the "used_notice" field.
func (m *SmsMutation) ResetUsedNotice() {
	m.used_notice = nil
	m.addused_notice = nil
	delete(m.clearedFields, sms.FieldUsedNotice)
}

// Where appends a list predicates to the SmsMutation builder.
func (m *SmsMutation) Where(ps ...predicate.Sms) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SmsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SmsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Sms, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SmsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SmsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Sms).
func (m *SmsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SmsMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, sms.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sms.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, sms.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, sms.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, sms.FieldStatus)
	}
	if m.notice_count != nil {
		fields = append(fields, sms.FieldNoticeCount)
	}
	if m.used_notice != nil {
		fields = append(fields, sms.FieldUsedNotice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SmsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sms.FieldCreatedAt:
		return m.CreatedAt()
	case sms.FieldUpdatedAt:
		return m.UpdatedAt()
	case sms.FieldDelete:
		return m.Delete()
	case sms.FieldCreatedID:
		return m.CreatedID()
	case sms.FieldStatus:
		return m.Status()
	case sms.FieldNoticeCount:
		return m.NoticeCount()
	case sms.FieldUsedNotice:
		return m.UsedNotice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SmsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sms.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sms.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sms.FieldDelete:
		return m.OldDelete(ctx)
	case sms.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case sms.FieldStatus:
		return m.OldStatus(ctx)
	case sms.FieldNoticeCount:
		return m.OldNoticeCount(ctx)
	case sms.FieldUsedNotice:
		return m.OldUsedNotice(ctx)
	}
	return nil, fmt.Errorf("unknown Sms field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SmsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sms.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sms.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sms.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case sms.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case sms.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sms.FieldNoticeCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoticeCount(v)
		return nil
	case sms.FieldUsedNotice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedNotice(v)
		return nil
	}
	return fmt.Errorf("unknown Sms field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SmsMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, sms.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, sms.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, sms.FieldStatus)
	}
	if m.addnotice_count != nil {
		fields = append(fields, sms.FieldNoticeCount)
	}
	if m.addused_notice != nil {
		fields = append(fields, sms.FieldUsedNotice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SmsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sms.FieldDelete:
		return m.AddedDelete()
	case sms.FieldCreatedID:
		return m.AddedCreatedID()
	case sms.FieldStatus:
		return m.AddedStatus()
	case sms.FieldNoticeCount:
		return m.AddedNoticeCount()
	case sms.FieldUsedNotice:
		return m.AddedUsedNotice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SmsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sms.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case sms.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case sms.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case sms.FieldNoticeCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNoticeCount(v)
		return nil
	case sms.FieldUsedNotice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedNotice(v)
		return nil
	}
	return fmt.Errorf("unknown Sms numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SmsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sms.FieldCreatedAt) {
		fields = append(fields, sms.FieldCreatedAt)
	}
	if m.FieldCleared(sms.FieldUpdatedAt) {
		fields = append(fields, sms.FieldUpdatedAt)
	}
	if m.FieldCleared(sms.FieldDelete) {
		fields = append(fields, sms.FieldDelete)
	}
	if m.FieldCleared(sms.FieldCreatedID) {
		fields = append(fields, sms.FieldCreatedID)
	}
	if m.FieldCleared(sms.FieldStatus) {
		fields = append(fields, sms.FieldStatus)
	}
	if m.FieldCleared(sms.FieldNoticeCount) {
		fields = append(fields, sms.FieldNoticeCount)
	}
	if m.FieldCleared(sms.FieldUsedNotice) {
		fields = append(fields, sms.FieldUsedNotice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SmsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SmsMutation) ClearField(name string) error {
	switch name {
	case sms.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case sms.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case sms.FieldDelete:
		m.ClearDelete()
		return nil
	case sms.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case sms.FieldStatus:
		m.ClearStatus()
		return nil
	case sms.FieldNoticeCount:
		m.ClearNoticeCount()
		return nil
	case sms.FieldUsedNotice:
		m.ClearUsedNotice()
		return nil
	}
	return fmt.Errorf("unknown Sms nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SmsMutation) ResetField(name string) error {
	switch name {
	case sms.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sms.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sms.FieldDelete:
		m.ResetDelete()
		return nil
	case sms.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case sms.FieldStatus:
		m.ResetStatus()
		return nil
	case sms.FieldNoticeCount:
		m.ResetNoticeCount()
		return nil
	case sms.FieldUsedNotice:
		m.ResetUsedNotice()
		return nil
	}
	return fmt.Errorf("unknown Sms field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SmsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SmsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SmsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SmsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SmsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SmsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SmsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Sms unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SmsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Sms edge %s", name)
}

// SmsLogMutation represents an operation that mutates the SmsLog nodes in the graph.
type SmsLogMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	delete         *int64
	adddelete      *int64
	created_id     *int64
	addcreated_id  *int64
	status         *int64
	addstatus      *int64
	mobile         *string
	biz_id         *string
	code           *string
	content        *string
	notify_type    *int64
	addnotify_type *int64
	template       *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*SmsLog, error)
	predicates     []predicate.SmsLog
}

var _ ent.Mutation = (*SmsLogMutation)(nil)

// smslogOption allows management of the mutation configuration using functional options.
type smslogOption func(*SmsLogMutation)

// newSmsLogMutation creates new mutation for the SmsLog entity.
func newSmsLogMutation(c config, op Op, opts ...smslogOption) *SmsLogMutation {
	m := &SmsLogMutation{
		config:        c,
		op:            op,
		typ:           TypeSmsLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSmsLogID sets the ID field of the mutation.
func withSmsLogID(id int64) smslogOption {
	return func(m *SmsLogMutation) {
		var (
			err   error
			once  sync.Once
			value *SmsLog
		)
		m.oldValue = func(ctx context.Context) (*SmsLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SmsLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSmsLog sets the old SmsLog of the mutation.
func withSmsLog(node *SmsLog) smslogOption {
	return func(m *SmsLogMutation) {
		m.oldValue = func(context.Context) (*SmsLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SmsLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SmsLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SmsLog entities.
func (m *SmsLogMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SmsLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SmsLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SmsLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SmsLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SmsLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SmsLogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[smslog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SmsLogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[smslog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SmsLogMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, smslog.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SmsLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SmsLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SmsLogMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[smslog.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SmsLogMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[smslog.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SmsLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, smslog.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *SmsLogMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *SmsLogMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *SmsLogMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *SmsLogMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *SmsLogMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[smslog.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *SmsLogMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[smslog.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *SmsLogMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, smslog.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *SmsLogMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *SmsLogMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *SmsLogMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *SmsLogMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *SmsLogMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[smslog.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *SmsLogMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[smslog.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *SmsLogMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, smslog.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *SmsLogMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SmsLogMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SmsLogMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SmsLogMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *SmsLogMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[smslog.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *SmsLogMutation) StatusCleared() bool {
	_, ok := m.clearedFields[smslog.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *SmsLogMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, smslog.FieldStatus)
}

// SetMobile sets the "mobile" field.
func (m *SmsLogMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *SmsLogMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *SmsLogMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[smslog.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *SmsLogMutation) MobileCleared() bool {
	_, ok := m.clearedFields[smslog.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *SmsLogMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, smslog.FieldMobile)
}

// SetBizID sets the "biz_id" field.
func (m *SmsLogMutation) SetBizID(s string) {
	m.biz_id = &s
}

// BizID returns the value of the "biz_id" field in the mutation.
func (m *SmsLogMutation) BizID() (r string, exists bool) {
	v := m.biz_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBizID returns the old "biz_id" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldBizID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizID: %w", err)
	}
	return oldValue.BizID, nil
}

// ClearBizID clears the value of the "biz_id" field.
func (m *SmsLogMutation) ClearBizID() {
	m.biz_id = nil
	m.clearedFields[smslog.FieldBizID] = struct{}{}
}

// BizIDCleared returns if the "biz_id" field was cleared in this mutation.
func (m *SmsLogMutation) BizIDCleared() bool {
	_, ok := m.clearedFields[smslog.FieldBizID]
	return ok
}

// ResetBizID resets all changes to the "biz_id" field.
func (m *SmsLogMutation) ResetBizID() {
	m.biz_id = nil
	delete(m.clearedFields, smslog.FieldBizID)
}

// SetCode sets the "code" field.
func (m *SmsLogMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *SmsLogMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *SmsLogMutation) ClearCode() {
	m.code = nil
	m.clearedFields[smslog.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *SmsLogMutation) CodeCleared() bool {
	_, ok := m.clearedFields[smslog.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *SmsLogMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, smslog.FieldCode)
}

// SetContent sets the "content" field.
func (m *SmsLogMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *SmsLogMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *SmsLogMutation) ClearContent() {
	m.content = nil
	m.clearedFields[smslog.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *SmsLogMutation) ContentCleared() bool {
	_, ok := m.clearedFields[smslog.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *SmsLogMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, smslog.FieldContent)
}

// SetNotifyType sets the "notify_type" field.
func (m *SmsLogMutation) SetNotifyType(i int64) {
	m.notify_type = &i
	m.addnotify_type = nil
}

// NotifyType returns the value of the "notify_type" field in the mutation.
func (m *SmsLogMutation) NotifyType() (r int64, exists bool) {
	v := m.notify_type
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyType returns the old "notify_type" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldNotifyType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyType: %w", err)
	}
	return oldValue.NotifyType, nil
}

// AddNotifyType adds i to the "notify_type" field.
func (m *SmsLogMutation) AddNotifyType(i int64) {
	if m.addnotify_type != nil {
		*m.addnotify_type += i
	} else {
		m.addnotify_type = &i
	}
}

// AddedNotifyType returns the value that was added to the "notify_type" field in this mutation.
func (m *SmsLogMutation) AddedNotifyType() (r int64, exists bool) {
	v := m.addnotify_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearNotifyType clears the value of the "notify_type" field.
func (m *SmsLogMutation) ClearNotifyType() {
	m.notify_type = nil
	m.addnotify_type = nil
	m.clearedFields[smslog.FieldNotifyType] = struct{}{}
}

// NotifyTypeCleared returns if the "notify_type" field was cleared in this mutation.
func (m *SmsLogMutation) NotifyTypeCleared() bool {
	_, ok := m.clearedFields[smslog.FieldNotifyType]
	return ok
}

// ResetNotifyType resets all changes to the "notify_type" field.
func (m *SmsLogMutation) ResetNotifyType() {
	m.notify_type = nil
	m.addnotify_type = nil
	delete(m.clearedFields, smslog.FieldNotifyType)
}

// SetTemplate sets the "template" field.
func (m *SmsLogMutation) SetTemplate(s string) {
	m.template = &s
}

// Template returns the value of the "template" field in the mutation.
func (m *SmsLogMutation) Template() (r string, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old "template" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ClearTemplate clears the value of the "template" field.
func (m *SmsLogMutation) ClearTemplate() {
	m.template = nil
	m.clearedFields[smslog.FieldTemplate] = struct{}{}
}

// TemplateCleared returns if the "template" field was cleared in this mutation.
func (m *SmsLogMutation) TemplateCleared() bool {
	_, ok := m.clearedFields[smslog.FieldTemplate]
	return ok
}

// ResetTemplate resets all changes to the "template" field.
func (m *SmsLogMutation) ResetTemplate() {
	m.template = nil
	delete(m.clearedFields, smslog.FieldTemplate)
}

// Where appends a list predicates to the SmsLogMutation builder.
func (m *SmsLogMutation) Where(ps ...predicate.SmsLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SmsLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SmsLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SmsLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SmsLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SmsLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SmsLog).
func (m *SmsLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SmsLogMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, smslog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, smslog.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, smslog.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, smslog.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, smslog.FieldStatus)
	}
	if m.mobile != nil {
		fields = append(fields, smslog.FieldMobile)
	}
	if m.biz_id != nil {
		fields = append(fields, smslog.FieldBizID)
	}
	if m.code != nil {
		fields = append(fields, smslog.FieldCode)
	}
	if m.content != nil {
		fields = append(fields, smslog.FieldContent)
	}
	if m.notify_type != nil {
		fields = append(fields, smslog.FieldNotifyType)
	}
	if m.template != nil {
		fields = append(fields, smslog.FieldTemplate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SmsLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case smslog.FieldCreatedAt:
		return m.CreatedAt()
	case smslog.FieldUpdatedAt:
		return m.UpdatedAt()
	case smslog.FieldDelete:
		return m.Delete()
	case smslog.FieldCreatedID:
		return m.CreatedID()
	case smslog.FieldStatus:
		return m.Status()
	case smslog.FieldMobile:
		return m.Mobile()
	case smslog.FieldBizID:
		return m.BizID()
	case smslog.FieldCode:
		return m.Code()
	case smslog.FieldContent:
		return m.Content()
	case smslog.FieldNotifyType:
		return m.NotifyType()
	case smslog.FieldTemplate:
		return m.Template()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SmsLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case smslog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case smslog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case smslog.FieldDelete:
		return m.OldDelete(ctx)
	case smslog.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case smslog.FieldStatus:
		return m.OldStatus(ctx)
	case smslog.FieldMobile:
		return m.OldMobile(ctx)
	case smslog.FieldBizID:
		return m.OldBizID(ctx)
	case smslog.FieldCode:
		return m.OldCode(ctx)
	case smslog.FieldContent:
		return m.OldContent(ctx)
	case smslog.FieldNotifyType:
		return m.OldNotifyType(ctx)
	case smslog.FieldTemplate:
		return m.OldTemplate(ctx)
	}
	return nil, fmt.Errorf("unknown SmsLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SmsLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case smslog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case smslog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case smslog.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case smslog.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case smslog.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case smslog.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case smslog.FieldBizID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizID(v)
		return nil
	case smslog.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case smslog.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case smslog.FieldNotifyType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyType(v)
		return nil
	case smslog.FieldTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	}
	return fmt.Errorf("unknown SmsLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SmsLogMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, smslog.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, smslog.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, smslog.FieldStatus)
	}
	if m.addnotify_type != nil {
		fields = append(fields, smslog.FieldNotifyType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SmsLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case smslog.FieldDelete:
		return m.AddedDelete()
	case smslog.FieldCreatedID:
		return m.AddedCreatedID()
	case smslog.FieldStatus:
		return m.AddedStatus()
	case smslog.FieldNotifyType:
		return m.AddedNotifyType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SmsLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case smslog.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case smslog.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case smslog.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case smslog.FieldNotifyType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotifyType(v)
		return nil
	}
	return fmt.Errorf("unknown SmsLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SmsLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(smslog.FieldCreatedAt) {
		fields = append(fields, smslog.FieldCreatedAt)
	}
	if m.FieldCleared(smslog.FieldUpdatedAt) {
		fields = append(fields, smslog.FieldUpdatedAt)
	}
	if m.FieldCleared(smslog.FieldDelete) {
		fields = append(fields, smslog.FieldDelete)
	}
	if m.FieldCleared(smslog.FieldCreatedID) {
		fields = append(fields, smslog.FieldCreatedID)
	}
	if m.FieldCleared(smslog.FieldStatus) {
		fields = append(fields, smslog.FieldStatus)
	}
	if m.FieldCleared(smslog.FieldMobile) {
		fields = append(fields, smslog.FieldMobile)
	}
	if m.FieldCleared(smslog.FieldBizID) {
		fields = append(fields, smslog.FieldBizID)
	}
	if m.FieldCleared(smslog.FieldCode) {
		fields = append(fields, smslog.FieldCode)
	}
	if m.FieldCleared(smslog.FieldContent) {
		fields = append(fields, smslog.FieldContent)
	}
	if m.FieldCleared(smslog.FieldNotifyType) {
		fields = append(fields, smslog.FieldNotifyType)
	}
	if m.FieldCleared(smslog.FieldTemplate) {
		fields = append(fields, smslog.FieldTemplate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SmsLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SmsLogMutation) ClearField(name string) error {
	switch name {
	case smslog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case smslog.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case smslog.FieldDelete:
		m.ClearDelete()
		return nil
	case smslog.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case smslog.FieldStatus:
		m.ClearStatus()
		return nil
	case smslog.FieldMobile:
		m.ClearMobile()
		return nil
	case smslog.FieldBizID:
		m.ClearBizID()
		return nil
	case smslog.FieldCode:
		m.ClearCode()
		return nil
	case smslog.FieldContent:
		m.ClearContent()
		return nil
	case smslog.FieldNotifyType:
		m.ClearNotifyType()
		return nil
	case smslog.FieldTemplate:
		m.ClearTemplate()
		return nil
	}
	return fmt.Errorf("unknown SmsLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SmsLogMutation) ResetField(name string) error {
	switch name {
	case smslog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case smslog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case smslog.FieldDelete:
		m.ResetDelete()
		return nil
	case smslog.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case smslog.FieldStatus:
		m.ResetStatus()
		return nil
	case smslog.FieldMobile:
		m.ResetMobile()
		return nil
	case smslog.FieldBizID:
		m.ResetBizID()
		return nil
	case smslog.FieldCode:
		m.ResetCode()
		return nil
	case smslog.FieldContent:
		m.ResetContent()
		return nil
	case smslog.FieldNotifyType:
		m.ResetNotifyType()
		return nil
	case smslog.FieldTemplate:
		m.ResetTemplate()
		return nil
	}
	return fmt.Errorf("unknown SmsLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SmsLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SmsLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SmsLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SmsLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SmsLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SmsLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SmsLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SmsLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SmsLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SmsLog edge %s", name)
}

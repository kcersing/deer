// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"member/biz/dal/db/ent/member"
	"member/biz/dal/db/ent/membercontract"
	"member/biz/dal/db/ent/membercontractcontent"
	"member/biz/dal/db/ent/membernote"
	"member/biz/dal/db/ent/memberproduct"
	"member/biz/dal/db/ent/memberproductproperty"
	"member/biz/dal/db/ent/memberprofile"
	"member/biz/dal/db/ent/predicate"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMember                = "Member"
	TypeMemberContract        = "MemberContract"
	TypeMemberContractContent = "MemberContractContent"
	TypeMemberNote            = "MemberNote"
	TypeMemberProduct         = "MemberProduct"
	TypeMemberProductProperty = "MemberProductProperty"
	TypeMemberProfile         = "MemberProfile"
)

// MemberMutation represents an operation that mutates the Member nodes in the graph.
type MemberMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	created_at             *time.Time
	updated_at             *time.Time
	delete                 *int64
	adddelete              *int64
	created_id             *int64
	addcreated_id          *int64
	status                 *int64
	addstatus              *int64
	password               *string
	username               *string
	mobile                 *string
	name                   *string
	avatar                 *string
	condition              *int64
	addcondition           *int64
	clearedFields          map[string]struct{}
	member_profile         map[int64]struct{}
	removedmember_profile  map[int64]struct{}
	clearedmember_profile  bool
	member_notes           map[int64]struct{}
	removedmember_notes    map[int64]struct{}
	clearedmember_notes    bool
	member_products        map[int64]struct{}
	removedmember_products map[int64]struct{}
	clearedmember_products bool
	member_contents        map[int64]struct{}
	removedmember_contents map[int64]struct{}
	clearedmember_contents bool
	done                   bool
	oldValue               func(context.Context) (*Member, error)
	predicates             []predicate.Member
}

var _ ent.Mutation = (*MemberMutation)(nil)

// memberOption allows management of the mutation configuration using functional options.
type memberOption func(*MemberMutation)

// newMemberMutation creates new mutation for the Member entity.
func newMemberMutation(c config, op Op, opts ...memberOption) *MemberMutation {
	m := &MemberMutation{
		config:        c,
		op:            op,
		typ:           TypeMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberID sets the ID field of the mutation.
func withMemberID(id int64) memberOption {
	return func(m *MemberMutation) {
		var (
			err   error
			once  sync.Once
			value *Member
		)
		m.oldValue = func(ctx context.Context) (*Member, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Member.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMember sets the old Member of the mutation.
func withMember(node *Member) memberOption {
	return func(m *MemberMutation) {
		m.oldValue = func(context.Context) (*Member, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Member entities.
func (m *MemberMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Member.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[member.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[member.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, member.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[member.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[member.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, member.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[member.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[member.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, member.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[member.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[member.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, member.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MemberMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[member.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberMutation) StatusCleared() bool {
	_, ok := m.clearedFields[member.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, member.FieldStatus)
}

// SetPassword sets the "password" field.
func (m *MemberMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *MemberMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *MemberMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[member.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *MemberMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[member.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *MemberMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, member.FieldPassword)
}

// SetUsername sets the "username" field.
func (m *MemberMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *MemberMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *MemberMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[member.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *MemberMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[member.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *MemberMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, member.FieldUsername)
}

// SetMobile sets the "mobile" field.
func (m *MemberMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *MemberMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *MemberMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[member.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *MemberMutation) MobileCleared() bool {
	_, ok := m.clearedFields[member.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *MemberMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, member.FieldMobile)
}

// SetName sets the "name" field.
func (m *MemberMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberMutation) ClearName() {
	m.name = nil
	m.clearedFields[member.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberMutation) NameCleared() bool {
	_, ok := m.clearedFields[member.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, member.FieldName)
}

// SetAvatar sets the "avatar" field.
func (m *MemberMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *MemberMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *MemberMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[member.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *MemberMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[member.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *MemberMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, member.FieldAvatar)
}

// SetCondition sets the "condition" field.
func (m *MemberMutation) SetCondition(i int64) {
	m.condition = &i
	m.addcondition = nil
}

// Condition returns the value of the "condition" field in the mutation.
func (m *MemberMutation) Condition() (r int64, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCondition(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// AddCondition adds i to the "condition" field.
func (m *MemberMutation) AddCondition(i int64) {
	if m.addcondition != nil {
		*m.addcondition += i
	} else {
		m.addcondition = &i
	}
}

// AddedCondition returns the value that was added to the "condition" field in this mutation.
func (m *MemberMutation) AddedCondition() (r int64, exists bool) {
	v := m.addcondition
	if v == nil {
		return
	}
	return *v, true
}

// ClearCondition clears the value of the "condition" field.
func (m *MemberMutation) ClearCondition() {
	m.condition = nil
	m.addcondition = nil
	m.clearedFields[member.FieldCondition] = struct{}{}
}

// ConditionCleared returns if the "condition" field was cleared in this mutation.
func (m *MemberMutation) ConditionCleared() bool {
	_, ok := m.clearedFields[member.FieldCondition]
	return ok
}

// ResetCondition resets all changes to the "condition" field.
func (m *MemberMutation) ResetCondition() {
	m.condition = nil
	m.addcondition = nil
	delete(m.clearedFields, member.FieldCondition)
}

// AddMemberProfileIDs adds the "member_profile" edge to the MemberProfile entity by ids.
func (m *MemberMutation) AddMemberProfileIDs(ids ...int64) {
	if m.member_profile == nil {
		m.member_profile = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_profile[ids[i]] = struct{}{}
	}
}

// ClearMemberProfile clears the "member_profile" edge to the MemberProfile entity.
func (m *MemberMutation) ClearMemberProfile() {
	m.clearedmember_profile = true
}

// MemberProfileCleared reports if the "member_profile" edge to the MemberProfile entity was cleared.
func (m *MemberMutation) MemberProfileCleared() bool {
	return m.clearedmember_profile
}

// RemoveMemberProfileIDs removes the "member_profile" edge to the MemberProfile entity by IDs.
func (m *MemberMutation) RemoveMemberProfileIDs(ids ...int64) {
	if m.removedmember_profile == nil {
		m.removedmember_profile = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_profile, ids[i])
		m.removedmember_profile[ids[i]] = struct{}{}
	}
}

// RemovedMemberProfile returns the removed IDs of the "member_profile" edge to the MemberProfile entity.
func (m *MemberMutation) RemovedMemberProfileIDs() (ids []int64) {
	for id := range m.removedmember_profile {
		ids = append(ids, id)
	}
	return
}

// MemberProfileIDs returns the "member_profile" edge IDs in the mutation.
func (m *MemberMutation) MemberProfileIDs() (ids []int64) {
	for id := range m.member_profile {
		ids = append(ids, id)
	}
	return
}

// ResetMemberProfile resets all changes to the "member_profile" edge.
func (m *MemberMutation) ResetMemberProfile() {
	m.member_profile = nil
	m.clearedmember_profile = false
	m.removedmember_profile = nil
}

// AddMemberNoteIDs adds the "member_notes" edge to the MemberNote entity by ids.
func (m *MemberMutation) AddMemberNoteIDs(ids ...int64) {
	if m.member_notes == nil {
		m.member_notes = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_notes[ids[i]] = struct{}{}
	}
}

// ClearMemberNotes clears the "member_notes" edge to the MemberNote entity.
func (m *MemberMutation) ClearMemberNotes() {
	m.clearedmember_notes = true
}

// MemberNotesCleared reports if the "member_notes" edge to the MemberNote entity was cleared.
func (m *MemberMutation) MemberNotesCleared() bool {
	return m.clearedmember_notes
}

// RemoveMemberNoteIDs removes the "member_notes" edge to the MemberNote entity by IDs.
func (m *MemberMutation) RemoveMemberNoteIDs(ids ...int64) {
	if m.removedmember_notes == nil {
		m.removedmember_notes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_notes, ids[i])
		m.removedmember_notes[ids[i]] = struct{}{}
	}
}

// RemovedMemberNotes returns the removed IDs of the "member_notes" edge to the MemberNote entity.
func (m *MemberMutation) RemovedMemberNotesIDs() (ids []int64) {
	for id := range m.removedmember_notes {
		ids = append(ids, id)
	}
	return
}

// MemberNotesIDs returns the "member_notes" edge IDs in the mutation.
func (m *MemberMutation) MemberNotesIDs() (ids []int64) {
	for id := range m.member_notes {
		ids = append(ids, id)
	}
	return
}

// ResetMemberNotes resets all changes to the "member_notes" edge.
func (m *MemberMutation) ResetMemberNotes() {
	m.member_notes = nil
	m.clearedmember_notes = false
	m.removedmember_notes = nil
}

// AddMemberProductIDs adds the "member_products" edge to the MemberProduct entity by ids.
func (m *MemberMutation) AddMemberProductIDs(ids ...int64) {
	if m.member_products == nil {
		m.member_products = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_products[ids[i]] = struct{}{}
	}
}

// ClearMemberProducts clears the "member_products" edge to the MemberProduct entity.
func (m *MemberMutation) ClearMemberProducts() {
	m.clearedmember_products = true
}

// MemberProductsCleared reports if the "member_products" edge to the MemberProduct entity was cleared.
func (m *MemberMutation) MemberProductsCleared() bool {
	return m.clearedmember_products
}

// RemoveMemberProductIDs removes the "member_products" edge to the MemberProduct entity by IDs.
func (m *MemberMutation) RemoveMemberProductIDs(ids ...int64) {
	if m.removedmember_products == nil {
		m.removedmember_products = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_products, ids[i])
		m.removedmember_products[ids[i]] = struct{}{}
	}
}

// RemovedMemberProducts returns the removed IDs of the "member_products" edge to the MemberProduct entity.
func (m *MemberMutation) RemovedMemberProductsIDs() (ids []int64) {
	for id := range m.removedmember_products {
		ids = append(ids, id)
	}
	return
}

// MemberProductsIDs returns the "member_products" edge IDs in the mutation.
func (m *MemberMutation) MemberProductsIDs() (ids []int64) {
	for id := range m.member_products {
		ids = append(ids, id)
	}
	return
}

// ResetMemberProducts resets all changes to the "member_products" edge.
func (m *MemberMutation) ResetMemberProducts() {
	m.member_products = nil
	m.clearedmember_products = false
	m.removedmember_products = nil
}

// AddMemberContentIDs adds the "member_contents" edge to the MemberContract entity by ids.
func (m *MemberMutation) AddMemberContentIDs(ids ...int64) {
	if m.member_contents == nil {
		m.member_contents = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_contents[ids[i]] = struct{}{}
	}
}

// ClearMemberContents clears the "member_contents" edge to the MemberContract entity.
func (m *MemberMutation) ClearMemberContents() {
	m.clearedmember_contents = true
}

// MemberContentsCleared reports if the "member_contents" edge to the MemberContract entity was cleared.
func (m *MemberMutation) MemberContentsCleared() bool {
	return m.clearedmember_contents
}

// RemoveMemberContentIDs removes the "member_contents" edge to the MemberContract entity by IDs.
func (m *MemberMutation) RemoveMemberContentIDs(ids ...int64) {
	if m.removedmember_contents == nil {
		m.removedmember_contents = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_contents, ids[i])
		m.removedmember_contents[ids[i]] = struct{}{}
	}
}

// RemovedMemberContents returns the removed IDs of the "member_contents" edge to the MemberContract entity.
func (m *MemberMutation) RemovedMemberContentsIDs() (ids []int64) {
	for id := range m.removedmember_contents {
		ids = append(ids, id)
	}
	return
}

// MemberContentsIDs returns the "member_contents" edge IDs in the mutation.
func (m *MemberMutation) MemberContentsIDs() (ids []int64) {
	for id := range m.member_contents {
		ids = append(ids, id)
	}
	return
}

// ResetMemberContents resets all changes to the "member_contents" edge.
func (m *MemberMutation) ResetMemberContents() {
	m.member_contents = nil
	m.clearedmember_contents = false
	m.removedmember_contents = nil
}

// Where appends a list predicates to the MemberMutation builder.
func (m *MemberMutation) Where(ps ...predicate.Member) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Member, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Member).
func (m *MemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, member.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, member.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, member.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, member.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, member.FieldStatus)
	}
	if m.password != nil {
		fields = append(fields, member.FieldPassword)
	}
	if m.username != nil {
		fields = append(fields, member.FieldUsername)
	}
	if m.mobile != nil {
		fields = append(fields, member.FieldMobile)
	}
	if m.name != nil {
		fields = append(fields, member.FieldName)
	}
	if m.avatar != nil {
		fields = append(fields, member.FieldAvatar)
	}
	if m.condition != nil {
		fields = append(fields, member.FieldCondition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case member.FieldCreatedAt:
		return m.CreatedAt()
	case member.FieldUpdatedAt:
		return m.UpdatedAt()
	case member.FieldDelete:
		return m.Delete()
	case member.FieldCreatedID:
		return m.CreatedID()
	case member.FieldStatus:
		return m.Status()
	case member.FieldPassword:
		return m.Password()
	case member.FieldUsername:
		return m.Username()
	case member.FieldMobile:
		return m.Mobile()
	case member.FieldName:
		return m.Name()
	case member.FieldAvatar:
		return m.Avatar()
	case member.FieldCondition:
		return m.Condition()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case member.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case member.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case member.FieldDelete:
		return m.OldDelete(ctx)
	case member.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case member.FieldStatus:
		return m.OldStatus(ctx)
	case member.FieldPassword:
		return m.OldPassword(ctx)
	case member.FieldUsername:
		return m.OldUsername(ctx)
	case member.FieldMobile:
		return m.OldMobile(ctx)
	case member.FieldName:
		return m.OldName(ctx)
	case member.FieldAvatar:
		return m.OldAvatar(ctx)
	case member.FieldCondition:
		return m.OldCondition(ctx)
	}
	return nil, fmt.Errorf("unknown Member field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case member.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case member.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case member.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case member.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case member.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case member.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case member.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case member.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case member.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case member.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case member.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, member.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, member.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, member.FieldStatus)
	}
	if m.addcondition != nil {
		fields = append(fields, member.FieldCondition)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case member.FieldDelete:
		return m.AddedDelete()
	case member.FieldCreatedID:
		return m.AddedCreatedID()
	case member.FieldStatus:
		return m.AddedStatus()
	case member.FieldCondition:
		return m.AddedCondition()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case member.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case member.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case member.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case member.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCondition(v)
		return nil
	}
	return fmt.Errorf("unknown Member numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(member.FieldCreatedAt) {
		fields = append(fields, member.FieldCreatedAt)
	}
	if m.FieldCleared(member.FieldUpdatedAt) {
		fields = append(fields, member.FieldUpdatedAt)
	}
	if m.FieldCleared(member.FieldDelete) {
		fields = append(fields, member.FieldDelete)
	}
	if m.FieldCleared(member.FieldCreatedID) {
		fields = append(fields, member.FieldCreatedID)
	}
	if m.FieldCleared(member.FieldStatus) {
		fields = append(fields, member.FieldStatus)
	}
	if m.FieldCleared(member.FieldPassword) {
		fields = append(fields, member.FieldPassword)
	}
	if m.FieldCleared(member.FieldUsername) {
		fields = append(fields, member.FieldUsername)
	}
	if m.FieldCleared(member.FieldMobile) {
		fields = append(fields, member.FieldMobile)
	}
	if m.FieldCleared(member.FieldName) {
		fields = append(fields, member.FieldName)
	}
	if m.FieldCleared(member.FieldAvatar) {
		fields = append(fields, member.FieldAvatar)
	}
	if m.FieldCleared(member.FieldCondition) {
		fields = append(fields, member.FieldCondition)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberMutation) ClearField(name string) error {
	switch name {
	case member.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case member.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case member.FieldDelete:
		m.ClearDelete()
		return nil
	case member.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case member.FieldStatus:
		m.ClearStatus()
		return nil
	case member.FieldPassword:
		m.ClearPassword()
		return nil
	case member.FieldUsername:
		m.ClearUsername()
		return nil
	case member.FieldMobile:
		m.ClearMobile()
		return nil
	case member.FieldName:
		m.ClearName()
		return nil
	case member.FieldAvatar:
		m.ClearAvatar()
		return nil
	case member.FieldCondition:
		m.ClearCondition()
		return nil
	}
	return fmt.Errorf("unknown Member nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberMutation) ResetField(name string) error {
	switch name {
	case member.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case member.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case member.FieldDelete:
		m.ResetDelete()
		return nil
	case member.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case member.FieldStatus:
		m.ResetStatus()
		return nil
	case member.FieldPassword:
		m.ResetPassword()
		return nil
	case member.FieldUsername:
		m.ResetUsername()
		return nil
	case member.FieldMobile:
		m.ResetMobile()
		return nil
	case member.FieldName:
		m.ResetName()
		return nil
	case member.FieldAvatar:
		m.ResetAvatar()
		return nil
	case member.FieldCondition:
		m.ResetCondition()
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.member_profile != nil {
		edges = append(edges, member.EdgeMemberProfile)
	}
	if m.member_notes != nil {
		edges = append(edges, member.EdgeMemberNotes)
	}
	if m.member_products != nil {
		edges = append(edges, member.EdgeMemberProducts)
	}
	if m.member_contents != nil {
		edges = append(edges, member.EdgeMemberContents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeMemberProfile:
		ids := make([]ent.Value, 0, len(m.member_profile))
		for id := range m.member_profile {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberNotes:
		ids := make([]ent.Value, 0, len(m.member_notes))
		for id := range m.member_notes {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberProducts:
		ids := make([]ent.Value, 0, len(m.member_products))
		for id := range m.member_products {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberContents:
		ids := make([]ent.Value, 0, len(m.member_contents))
		for id := range m.member_contents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmember_profile != nil {
		edges = append(edges, member.EdgeMemberProfile)
	}
	if m.removedmember_notes != nil {
		edges = append(edges, member.EdgeMemberNotes)
	}
	if m.removedmember_products != nil {
		edges = append(edges, member.EdgeMemberProducts)
	}
	if m.removedmember_contents != nil {
		edges = append(edges, member.EdgeMemberContents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeMemberProfile:
		ids := make([]ent.Value, 0, len(m.removedmember_profile))
		for id := range m.removedmember_profile {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberNotes:
		ids := make([]ent.Value, 0, len(m.removedmember_notes))
		for id := range m.removedmember_notes {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberProducts:
		ids := make([]ent.Value, 0, len(m.removedmember_products))
		for id := range m.removedmember_products {
			ids = append(ids, id)
		}
		return ids
	case member.EdgeMemberContents:
		ids := make([]ent.Value, 0, len(m.removedmember_contents))
		for id := range m.removedmember_contents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmember_profile {
		edges = append(edges, member.EdgeMemberProfile)
	}
	if m.clearedmember_notes {
		edges = append(edges, member.EdgeMemberNotes)
	}
	if m.clearedmember_products {
		edges = append(edges, member.EdgeMemberProducts)
	}
	if m.clearedmember_contents {
		edges = append(edges, member.EdgeMemberContents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberMutation) EdgeCleared(name string) bool {
	switch name {
	case member.EdgeMemberProfile:
		return m.clearedmember_profile
	case member.EdgeMemberNotes:
		return m.clearedmember_notes
	case member.EdgeMemberProducts:
		return m.clearedmember_products
	case member.EdgeMemberContents:
		return m.clearedmember_contents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Member unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberMutation) ResetEdge(name string) error {
	switch name {
	case member.EdgeMemberProfile:
		m.ResetMemberProfile()
		return nil
	case member.EdgeMemberNotes:
		m.ResetMemberNotes()
		return nil
	case member.EdgeMemberProducts:
		m.ResetMemberProducts()
		return nil
	case member.EdgeMemberContents:
		m.ResetMemberContents()
		return nil
	}
	return fmt.Errorf("unknown Member edge %s", name)
}

// MemberContractMutation represents an operation that mutates the MemberContract nodes in the graph.
type MemberContractMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	delete                *int64
	adddelete             *int64
	created_id            *int64
	addcreated_id         *int64
	status                *int64
	addstatus             *int64
	contract_id           *int64
	addcontract_id        *int64
	order_id              *int64
	addorder_id           *int64
	venue_id              *int64
	addvenue_id           *int64
	name                  *string
	sign                  *string
	clearedFields         map[string]struct{}
	content               map[int64]struct{}
	removedcontent        map[int64]struct{}
	clearedcontent        bool
	member                *int64
	clearedmember         bool
	member_product        *int64
	clearedmember_product bool
	done                  bool
	oldValue              func(context.Context) (*MemberContract, error)
	predicates            []predicate.MemberContract
}

var _ ent.Mutation = (*MemberContractMutation)(nil)

// membercontractOption allows management of the mutation configuration using functional options.
type membercontractOption func(*MemberContractMutation)

// newMemberContractMutation creates new mutation for the MemberContract entity.
func newMemberContractMutation(c config, op Op, opts ...membercontractOption) *MemberContractMutation {
	m := &MemberContractMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberContractID sets the ID field of the mutation.
func withMemberContractID(id int64) membercontractOption {
	return func(m *MemberContractMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberContract
		)
		m.oldValue = func(ctx context.Context) (*MemberContract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberContract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberContract sets the old MemberContract of the mutation.
func withMemberContract(node *MemberContract) membercontractOption {
	return func(m *MemberContractMutation) {
		m.oldValue = func(context.Context) (*MemberContract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberContract entities.
func (m *MemberContractMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberContractMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberContractMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberContract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberContractMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[membercontract.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberContractMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberContractMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, membercontract.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberContractMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[membercontract.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberContractMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, membercontract.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberContractMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberContractMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberContractMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberContractMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberContractMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[membercontract.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberContractMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberContractMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, membercontract.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberContractMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberContractMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberContractMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberContractMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberContractMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[membercontract.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberContractMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberContractMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, membercontract.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MemberContractMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberContractMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberContractMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberContractMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberContractMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[membercontract.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberContractMutation) StatusCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberContractMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, membercontract.FieldStatus)
}

// SetMemberID sets the "member_id" field.
func (m *MemberContractMutation) SetMemberID(i int64) {
	m.member = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberContractMutation) MemberID() (r int64, exists bool) {
	v := m.member
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberContractMutation) ClearMemberID() {
	m.member = nil
	m.clearedFields[membercontract.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberContractMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberContractMutation) ResetMemberID() {
	m.member = nil
	delete(m.clearedFields, membercontract.FieldMemberID)
}

// SetContractID sets the "contract_id" field.
func (m *MemberContractMutation) SetContractID(i int64) {
	m.contract_id = &i
	m.addcontract_id = nil
}

// ContractID returns the value of the "contract_id" field in the mutation.
func (m *MemberContractMutation) ContractID() (r int64, exists bool) {
	v := m.contract_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContractID returns the old "contract_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldContractID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractID: %w", err)
	}
	return oldValue.ContractID, nil
}

// AddContractID adds i to the "contract_id" field.
func (m *MemberContractMutation) AddContractID(i int64) {
	if m.addcontract_id != nil {
		*m.addcontract_id += i
	} else {
		m.addcontract_id = &i
	}
}

// AddedContractID returns the value that was added to the "contract_id" field in this mutation.
func (m *MemberContractMutation) AddedContractID() (r int64, exists bool) {
	v := m.addcontract_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearContractID clears the value of the "contract_id" field.
func (m *MemberContractMutation) ClearContractID() {
	m.contract_id = nil
	m.addcontract_id = nil
	m.clearedFields[membercontract.FieldContractID] = struct{}{}
}

// ContractIDCleared returns if the "contract_id" field was cleared in this mutation.
func (m *MemberContractMutation) ContractIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldContractID]
	return ok
}

// ResetContractID resets all changes to the "contract_id" field.
func (m *MemberContractMutation) ResetContractID() {
	m.contract_id = nil
	m.addcontract_id = nil
	delete(m.clearedFields, membercontract.FieldContractID)
}

// SetOrderID sets the "order_id" field.
func (m *MemberContractMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *MemberContractMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *MemberContractMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *MemberContractMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderID clears the value of the "order_id" field.
func (m *MemberContractMutation) ClearOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	m.clearedFields[membercontract.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *MemberContractMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *MemberContractMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	delete(m.clearedFields, membercontract.FieldOrderID)
}

// SetVenueID sets the "venue_id" field.
func (m *MemberContractMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *MemberContractMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *MemberContractMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *MemberContractMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *MemberContractMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[membercontract.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *MemberContractMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *MemberContractMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, membercontract.FieldVenueID)
}

// SetMemberProductID sets the "member_product_id" field.
func (m *MemberContractMutation) SetMemberProductID(i int64) {
	m.member_product = &i
}

// MemberProductID returns the value of the "member_product_id" field in the mutation.
func (m *MemberContractMutation) MemberProductID() (r int64, exists bool) {
	v := m.member_product
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductID returns the old "member_product_id" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldMemberProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductID: %w", err)
	}
	return oldValue.MemberProductID, nil
}

// ClearMemberProductID clears the value of the "member_product_id" field.
func (m *MemberContractMutation) ClearMemberProductID() {
	m.member_product = nil
	m.clearedFields[membercontract.FieldMemberProductID] = struct{}{}
}

// MemberProductIDCleared returns if the "member_product_id" field was cleared in this mutation.
func (m *MemberContractMutation) MemberProductIDCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldMemberProductID]
	return ok
}

// ResetMemberProductID resets all changes to the "member_product_id" field.
func (m *MemberContractMutation) ResetMemberProductID() {
	m.member_product = nil
	delete(m.clearedFields, membercontract.FieldMemberProductID)
}

// SetName sets the "name" field.
func (m *MemberContractMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberContractMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberContractMutation) ClearName() {
	m.name = nil
	m.clearedFields[membercontract.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberContractMutation) NameCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberContractMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, membercontract.FieldName)
}

// SetSign sets the "sign" field.
func (m *MemberContractMutation) SetSign(s string) {
	m.sign = &s
}

// Sign returns the value of the "sign" field in the mutation.
func (m *MemberContractMutation) Sign() (r string, exists bool) {
	v := m.sign
	if v == nil {
		return
	}
	return *v, true
}

// OldSign returns the old "sign" field's value of the MemberContract entity.
// If the MemberContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractMutation) OldSign(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSign: %w", err)
	}
	return oldValue.Sign, nil
}

// ClearSign clears the value of the "sign" field.
func (m *MemberContractMutation) ClearSign() {
	m.sign = nil
	m.clearedFields[membercontract.FieldSign] = struct{}{}
}

// SignCleared returns if the "sign" field was cleared in this mutation.
func (m *MemberContractMutation) SignCleared() bool {
	_, ok := m.clearedFields[membercontract.FieldSign]
	return ok
}

// ResetSign resets all changes to the "sign" field.
func (m *MemberContractMutation) ResetSign() {
	m.sign = nil
	delete(m.clearedFields, membercontract.FieldSign)
}

// AddContentIDs adds the "content" edge to the MemberContractContent entity by ids.
func (m *MemberContractMutation) AddContentIDs(ids ...int64) {
	if m.content == nil {
		m.content = make(map[int64]struct{})
	}
	for i := range ids {
		m.content[ids[i]] = struct{}{}
	}
}

// ClearContent clears the "content" edge to the MemberContractContent entity.
func (m *MemberContractMutation) ClearContent() {
	m.clearedcontent = true
}

// ContentCleared reports if the "content" edge to the MemberContractContent entity was cleared.
func (m *MemberContractMutation) ContentCleared() bool {
	return m.clearedcontent
}

// RemoveContentIDs removes the "content" edge to the MemberContractContent entity by IDs.
func (m *MemberContractMutation) RemoveContentIDs(ids ...int64) {
	if m.removedcontent == nil {
		m.removedcontent = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.content, ids[i])
		m.removedcontent[ids[i]] = struct{}{}
	}
}

// RemovedContent returns the removed IDs of the "content" edge to the MemberContractContent entity.
func (m *MemberContractMutation) RemovedContentIDs() (ids []int64) {
	for id := range m.removedcontent {
		ids = append(ids, id)
	}
	return
}

// ContentIDs returns the "content" edge IDs in the mutation.
func (m *MemberContractMutation) ContentIDs() (ids []int64) {
	for id := range m.content {
		ids = append(ids, id)
	}
	return
}

// ResetContent resets all changes to the "content" edge.
func (m *MemberContractMutation) ResetContent() {
	m.content = nil
	m.clearedcontent = false
	m.removedcontent = nil
}

// ClearMember clears the "member" edge to the Member entity.
func (m *MemberContractMutation) ClearMember() {
	m.clearedmember = true
	m.clearedFields[membercontract.FieldMemberID] = struct{}{}
}

// MemberCleared reports if the "member" edge to the Member entity was cleared.
func (m *MemberContractMutation) MemberCleared() bool {
	return m.MemberIDCleared() || m.clearedmember
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *MemberContractMutation) MemberIDs() (ids []int64) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *MemberContractMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// ClearMemberProduct clears the "member_product" edge to the MemberProduct entity.
func (m *MemberContractMutation) ClearMemberProduct() {
	m.clearedmember_product = true
	m.clearedFields[membercontract.FieldMemberProductID] = struct{}{}
}

// MemberProductCleared reports if the "member_product" edge to the MemberProduct entity was cleared.
func (m *MemberContractMutation) MemberProductCleared() bool {
	return m.MemberProductIDCleared() || m.clearedmember_product
}

// MemberProductIDs returns the "member_product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberProductID instead. It exists only for internal usage by the builders.
func (m *MemberContractMutation) MemberProductIDs() (ids []int64) {
	if id := m.member_product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMemberProduct resets all changes to the "member_product" edge.
func (m *MemberContractMutation) ResetMemberProduct() {
	m.member_product = nil
	m.clearedmember_product = false
}

// Where appends a list predicates to the MemberContractMutation builder.
func (m *MemberContractMutation) Where(ps ...predicate.MemberContract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberContractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberContractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberContract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberContractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberContractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberContract).
func (m *MemberContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberContractMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, membercontract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membercontract.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, membercontract.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, membercontract.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, membercontract.FieldStatus)
	}
	if m.member != nil {
		fields = append(fields, membercontract.FieldMemberID)
	}
	if m.contract_id != nil {
		fields = append(fields, membercontract.FieldContractID)
	}
	if m.order_id != nil {
		fields = append(fields, membercontract.FieldOrderID)
	}
	if m.venue_id != nil {
		fields = append(fields, membercontract.FieldVenueID)
	}
	if m.member_product != nil {
		fields = append(fields, membercontract.FieldMemberProductID)
	}
	if m.name != nil {
		fields = append(fields, membercontract.FieldName)
	}
	if m.sign != nil {
		fields = append(fields, membercontract.FieldSign)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membercontract.FieldCreatedAt:
		return m.CreatedAt()
	case membercontract.FieldUpdatedAt:
		return m.UpdatedAt()
	case membercontract.FieldDelete:
		return m.Delete()
	case membercontract.FieldCreatedID:
		return m.CreatedID()
	case membercontract.FieldStatus:
		return m.Status()
	case membercontract.FieldMemberID:
		return m.MemberID()
	case membercontract.FieldContractID:
		return m.ContractID()
	case membercontract.FieldOrderID:
		return m.OrderID()
	case membercontract.FieldVenueID:
		return m.VenueID()
	case membercontract.FieldMemberProductID:
		return m.MemberProductID()
	case membercontract.FieldName:
		return m.Name()
	case membercontract.FieldSign:
		return m.Sign()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membercontract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membercontract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membercontract.FieldDelete:
		return m.OldDelete(ctx)
	case membercontract.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case membercontract.FieldStatus:
		return m.OldStatus(ctx)
	case membercontract.FieldMemberID:
		return m.OldMemberID(ctx)
	case membercontract.FieldContractID:
		return m.OldContractID(ctx)
	case membercontract.FieldOrderID:
		return m.OldOrderID(ctx)
	case membercontract.FieldVenueID:
		return m.OldVenueID(ctx)
	case membercontract.FieldMemberProductID:
		return m.OldMemberProductID(ctx)
	case membercontract.FieldName:
		return m.OldName(ctx)
	case membercontract.FieldSign:
		return m.OldSign(ctx)
	}
	return nil, fmt.Errorf("unknown MemberContract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membercontract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membercontract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membercontract.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case membercontract.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case membercontract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case membercontract.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case membercontract.FieldContractID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractID(v)
		return nil
	case membercontract.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case membercontract.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case membercontract.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductID(v)
		return nil
	case membercontract.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case membercontract.FieldSign:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSign(v)
		return nil
	}
	return fmt.Errorf("unknown MemberContract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberContractMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, membercontract.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, membercontract.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, membercontract.FieldStatus)
	}
	if m.addcontract_id != nil {
		fields = append(fields, membercontract.FieldContractID)
	}
	if m.addorder_id != nil {
		fields = append(fields, membercontract.FieldOrderID)
	}
	if m.addvenue_id != nil {
		fields = append(fields, membercontract.FieldVenueID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membercontract.FieldDelete:
		return m.AddedDelete()
	case membercontract.FieldCreatedID:
		return m.AddedCreatedID()
	case membercontract.FieldStatus:
		return m.AddedStatus()
	case membercontract.FieldContractID:
		return m.AddedContractID()
	case membercontract.FieldOrderID:
		return m.AddedOrderID()
	case membercontract.FieldVenueID:
		return m.AddedVenueID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membercontract.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case membercontract.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case membercontract.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case membercontract.FieldContractID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContractID(v)
		return nil
	case membercontract.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case membercontract.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	}
	return fmt.Errorf("unknown MemberContract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membercontract.FieldCreatedAt) {
		fields = append(fields, membercontract.FieldCreatedAt)
	}
	if m.FieldCleared(membercontract.FieldUpdatedAt) {
		fields = append(fields, membercontract.FieldUpdatedAt)
	}
	if m.FieldCleared(membercontract.FieldDelete) {
		fields = append(fields, membercontract.FieldDelete)
	}
	if m.FieldCleared(membercontract.FieldCreatedID) {
		fields = append(fields, membercontract.FieldCreatedID)
	}
	if m.FieldCleared(membercontract.FieldStatus) {
		fields = append(fields, membercontract.FieldStatus)
	}
	if m.FieldCleared(membercontract.FieldMemberID) {
		fields = append(fields, membercontract.FieldMemberID)
	}
	if m.FieldCleared(membercontract.FieldContractID) {
		fields = append(fields, membercontract.FieldContractID)
	}
	if m.FieldCleared(membercontract.FieldOrderID) {
		fields = append(fields, membercontract.FieldOrderID)
	}
	if m.FieldCleared(membercontract.FieldVenueID) {
		fields = append(fields, membercontract.FieldVenueID)
	}
	if m.FieldCleared(membercontract.FieldMemberProductID) {
		fields = append(fields, membercontract.FieldMemberProductID)
	}
	if m.FieldCleared(membercontract.FieldName) {
		fields = append(fields, membercontract.FieldName)
	}
	if m.FieldCleared(membercontract.FieldSign) {
		fields = append(fields, membercontract.FieldSign)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberContractMutation) ClearField(name string) error {
	switch name {
	case membercontract.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case membercontract.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case membercontract.FieldDelete:
		m.ClearDelete()
		return nil
	case membercontract.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case membercontract.FieldStatus:
		m.ClearStatus()
		return nil
	case membercontract.FieldMemberID:
		m.ClearMemberID()
		return nil
	case membercontract.FieldContractID:
		m.ClearContractID()
		return nil
	case membercontract.FieldOrderID:
		m.ClearOrderID()
		return nil
	case membercontract.FieldVenueID:
		m.ClearVenueID()
		return nil
	case membercontract.FieldMemberProductID:
		m.ClearMemberProductID()
		return nil
	case membercontract.FieldName:
		m.ClearName()
		return nil
	case membercontract.FieldSign:
		m.ClearSign()
		return nil
	}
	return fmt.Errorf("unknown MemberContract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberContractMutation) ResetField(name string) error {
	switch name {
	case membercontract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membercontract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membercontract.FieldDelete:
		m.ResetDelete()
		return nil
	case membercontract.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case membercontract.FieldStatus:
		m.ResetStatus()
		return nil
	case membercontract.FieldMemberID:
		m.ResetMemberID()
		return nil
	case membercontract.FieldContractID:
		m.ResetContractID()
		return nil
	case membercontract.FieldOrderID:
		m.ResetOrderID()
		return nil
	case membercontract.FieldVenueID:
		m.ResetVenueID()
		return nil
	case membercontract.FieldMemberProductID:
		m.ResetMemberProductID()
		return nil
	case membercontract.FieldName:
		m.ResetName()
		return nil
	case membercontract.FieldSign:
		m.ResetSign()
		return nil
	}
	return fmt.Errorf("unknown MemberContract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.content != nil {
		edges = append(edges, membercontract.EdgeContent)
	}
	if m.member != nil {
		edges = append(edges, membercontract.EdgeMember)
	}
	if m.member_product != nil {
		edges = append(edges, membercontract.EdgeMemberProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membercontract.EdgeContent:
		ids := make([]ent.Value, 0, len(m.content))
		for id := range m.content {
			ids = append(ids, id)
		}
		return ids
	case membercontract.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	case membercontract.EdgeMemberProduct:
		if id := m.member_product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcontent != nil {
		edges = append(edges, membercontract.EdgeContent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberContractMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case membercontract.EdgeContent:
		ids := make([]ent.Value, 0, len(m.removedcontent))
		for id := range m.removedcontent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcontent {
		edges = append(edges, membercontract.EdgeContent)
	}
	if m.clearedmember {
		edges = append(edges, membercontract.EdgeMember)
	}
	if m.clearedmember_product {
		edges = append(edges, membercontract.EdgeMemberProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberContractMutation) EdgeCleared(name string) bool {
	switch name {
	case membercontract.EdgeContent:
		return m.clearedcontent
	case membercontract.EdgeMember:
		return m.clearedmember
	case membercontract.EdgeMemberProduct:
		return m.clearedmember_product
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberContractMutation) ClearEdge(name string) error {
	switch name {
	case membercontract.EdgeMember:
		m.ClearMember()
		return nil
	case membercontract.EdgeMemberProduct:
		m.ClearMemberProduct()
		return nil
	}
	return fmt.Errorf("unknown MemberContract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberContractMutation) ResetEdge(name string) error {
	switch name {
	case membercontract.EdgeContent:
		m.ResetContent()
		return nil
	case membercontract.EdgeMember:
		m.ResetMember()
		return nil
	case membercontract.EdgeMemberProduct:
		m.ResetMemberProduct()
		return nil
	}
	return fmt.Errorf("unknown MemberContract edge %s", name)
}

// MemberContractContentMutation represents an operation that mutates the MemberContractContent nodes in the graph.
type MemberContractContentMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	content         *string
	sign_img        *string
	clearedFields   map[string]struct{}
	contract        *int64
	clearedcontract bool
	done            bool
	oldValue        func(context.Context) (*MemberContractContent, error)
	predicates      []predicate.MemberContractContent
}

var _ ent.Mutation = (*MemberContractContentMutation)(nil)

// membercontractcontentOption allows management of the mutation configuration using functional options.
type membercontractcontentOption func(*MemberContractContentMutation)

// newMemberContractContentMutation creates new mutation for the MemberContractContent entity.
func newMemberContractContentMutation(c config, op Op, opts ...membercontractcontentOption) *MemberContractContentMutation {
	m := &MemberContractContentMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberContractContent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberContractContentID sets the ID field of the mutation.
func withMemberContractContentID(id int64) membercontractcontentOption {
	return func(m *MemberContractContentMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberContractContent
		)
		m.oldValue = func(ctx context.Context) (*MemberContractContent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberContractContent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberContractContent sets the old MemberContractContent of the mutation.
func withMemberContractContent(node *MemberContractContent) membercontractcontentOption {
	return func(m *MemberContractContentMutation) {
		m.oldValue = func(context.Context) (*MemberContractContent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberContractContentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberContractContentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberContractContent entities.
func (m *MemberContractContentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberContractContentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberContractContentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberContractContent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberContractContentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberContractContentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberContractContentMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[membercontractcontent.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberContractContentMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberContractContentMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, membercontractcontent.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberContractContentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberContractContentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberContractContentMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[membercontractcontent.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberContractContentMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberContractContentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, membercontractcontent.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberContractContentMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberContractContentMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberContractContentMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberContractContentMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberContractContentMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[membercontractcontent.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberContractContentMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberContractContentMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, membercontractcontent.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberContractContentMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberContractContentMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberContractContentMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberContractContentMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberContractContentMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[membercontractcontent.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberContractContentMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberContractContentMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, membercontractcontent.FieldCreatedID)
}

// SetMemberContractID sets the "member_contract_id" field.
func (m *MemberContractContentMutation) SetMemberContractID(i int64) {
	m.contract = &i
}

// MemberContractID returns the value of the "member_contract_id" field in the mutation.
func (m *MemberContractContentMutation) MemberContractID() (r int64, exists bool) {
	v := m.contract
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberContractID returns the old "member_contract_id" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldMemberContractID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberContractID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberContractID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberContractID: %w", err)
	}
	return oldValue.MemberContractID, nil
}

// ClearMemberContractID clears the value of the "member_contract_id" field.
func (m *MemberContractContentMutation) ClearMemberContractID() {
	m.contract = nil
	m.clearedFields[membercontractcontent.FieldMemberContractID] = struct{}{}
}

// MemberContractIDCleared returns if the "member_contract_id" field was cleared in this mutation.
func (m *MemberContractContentMutation) MemberContractIDCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldMemberContractID]
	return ok
}

// ResetMemberContractID resets all changes to the "member_contract_id" field.
func (m *MemberContractContentMutation) ResetMemberContractID() {
	m.contract = nil
	delete(m.clearedFields, membercontractcontent.FieldMemberContractID)
}

// SetContent sets the "content" field.
func (m *MemberContractContentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MemberContractContentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *MemberContractContentMutation) ClearContent() {
	m.content = nil
	m.clearedFields[membercontractcontent.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *MemberContractContentMutation) ContentCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *MemberContractContentMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, membercontractcontent.FieldContent)
}

// SetSignImg sets the "sign_img" field.
func (m *MemberContractContentMutation) SetSignImg(s string) {
	m.sign_img = &s
}

// SignImg returns the value of the "sign_img" field in the mutation.
func (m *MemberContractContentMutation) SignImg() (r string, exists bool) {
	v := m.sign_img
	if v == nil {
		return
	}
	return *v, true
}

// OldSignImg returns the old "sign_img" field's value of the MemberContractContent entity.
// If the MemberContractContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberContractContentMutation) OldSignImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignImg: %w", err)
	}
	return oldValue.SignImg, nil
}

// ClearSignImg clears the value of the "sign_img" field.
func (m *MemberContractContentMutation) ClearSignImg() {
	m.sign_img = nil
	m.clearedFields[membercontractcontent.FieldSignImg] = struct{}{}
}

// SignImgCleared returns if the "sign_img" field was cleared in this mutation.
func (m *MemberContractContentMutation) SignImgCleared() bool {
	_, ok := m.clearedFields[membercontractcontent.FieldSignImg]
	return ok
}

// ResetSignImg resets all changes to the "sign_img" field.
func (m *MemberContractContentMutation) ResetSignImg() {
	m.sign_img = nil
	delete(m.clearedFields, membercontractcontent.FieldSignImg)
}

// SetContractID sets the "contract" edge to the MemberContract entity by id.
func (m *MemberContractContentMutation) SetContractID(id int64) {
	m.contract = &id
}

// ClearContract clears the "contract" edge to the MemberContract entity.
func (m *MemberContractContentMutation) ClearContract() {
	m.clearedcontract = true
	m.clearedFields[membercontractcontent.FieldMemberContractID] = struct{}{}
}

// ContractCleared reports if the "contract" edge to the MemberContract entity was cleared.
func (m *MemberContractContentMutation) ContractCleared() bool {
	return m.MemberContractIDCleared() || m.clearedcontract
}

// ContractID returns the "contract" edge ID in the mutation.
func (m *MemberContractContentMutation) ContractID() (id int64, exists bool) {
	if m.contract != nil {
		return *m.contract, true
	}
	return
}

// ContractIDs returns the "contract" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContractID instead. It exists only for internal usage by the builders.
func (m *MemberContractContentMutation) ContractIDs() (ids []int64) {
	if id := m.contract; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContract resets all changes to the "contract" edge.
func (m *MemberContractContentMutation) ResetContract() {
	m.contract = nil
	m.clearedcontract = false
}

// Where appends a list predicates to the MemberContractContentMutation builder.
func (m *MemberContractContentMutation) Where(ps ...predicate.MemberContractContent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberContractContentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberContractContentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberContractContent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberContractContentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberContractContentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberContractContent).
func (m *MemberContractContentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberContractContentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, membercontractcontent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membercontractcontent.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, membercontractcontent.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, membercontractcontent.FieldCreatedID)
	}
	if m.contract != nil {
		fields = append(fields, membercontractcontent.FieldMemberContractID)
	}
	if m.content != nil {
		fields = append(fields, membercontractcontent.FieldContent)
	}
	if m.sign_img != nil {
		fields = append(fields, membercontractcontent.FieldSignImg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberContractContentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		return m.CreatedAt()
	case membercontractcontent.FieldUpdatedAt:
		return m.UpdatedAt()
	case membercontractcontent.FieldDelete:
		return m.Delete()
	case membercontractcontent.FieldCreatedID:
		return m.CreatedID()
	case membercontractcontent.FieldMemberContractID:
		return m.MemberContractID()
	case membercontractcontent.FieldContent:
		return m.Content()
	case membercontractcontent.FieldSignImg:
		return m.SignImg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberContractContentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membercontractcontent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membercontractcontent.FieldDelete:
		return m.OldDelete(ctx)
	case membercontractcontent.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case membercontractcontent.FieldMemberContractID:
		return m.OldMemberContractID(ctx)
	case membercontractcontent.FieldContent:
		return m.OldContent(ctx)
	case membercontractcontent.FieldSignImg:
		return m.OldSignImg(ctx)
	}
	return nil, fmt.Errorf("unknown MemberContractContent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractContentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membercontractcontent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membercontractcontent.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case membercontractcontent.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case membercontractcontent.FieldMemberContractID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberContractID(v)
		return nil
	case membercontractcontent.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case membercontractcontent.FieldSignImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignImg(v)
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberContractContentMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, membercontractcontent.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, membercontractcontent.FieldCreatedID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberContractContentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membercontractcontent.FieldDelete:
		return m.AddedDelete()
	case membercontractcontent.FieldCreatedID:
		return m.AddedCreatedID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberContractContentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membercontractcontent.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case membercontractcontent.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberContractContentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membercontractcontent.FieldCreatedAt) {
		fields = append(fields, membercontractcontent.FieldCreatedAt)
	}
	if m.FieldCleared(membercontractcontent.FieldUpdatedAt) {
		fields = append(fields, membercontractcontent.FieldUpdatedAt)
	}
	if m.FieldCleared(membercontractcontent.FieldDelete) {
		fields = append(fields, membercontractcontent.FieldDelete)
	}
	if m.FieldCleared(membercontractcontent.FieldCreatedID) {
		fields = append(fields, membercontractcontent.FieldCreatedID)
	}
	if m.FieldCleared(membercontractcontent.FieldMemberContractID) {
		fields = append(fields, membercontractcontent.FieldMemberContractID)
	}
	if m.FieldCleared(membercontractcontent.FieldContent) {
		fields = append(fields, membercontractcontent.FieldContent)
	}
	if m.FieldCleared(membercontractcontent.FieldSignImg) {
		fields = append(fields, membercontractcontent.FieldSignImg)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberContractContentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberContractContentMutation) ClearField(name string) error {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case membercontractcontent.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case membercontractcontent.FieldDelete:
		m.ClearDelete()
		return nil
	case membercontractcontent.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case membercontractcontent.FieldMemberContractID:
		m.ClearMemberContractID()
		return nil
	case membercontractcontent.FieldContent:
		m.ClearContent()
		return nil
	case membercontractcontent.FieldSignImg:
		m.ClearSignImg()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberContractContentMutation) ResetField(name string) error {
	switch name {
	case membercontractcontent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membercontractcontent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membercontractcontent.FieldDelete:
		m.ResetDelete()
		return nil
	case membercontractcontent.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case membercontractcontent.FieldMemberContractID:
		m.ResetMemberContractID()
		return nil
	case membercontractcontent.FieldContent:
		m.ResetContent()
		return nil
	case membercontractcontent.FieldSignImg:
		m.ResetSignImg()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberContractContentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.contract != nil {
		edges = append(edges, membercontractcontent.EdgeContract)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberContractContentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membercontractcontent.EdgeContract:
		if id := m.contract; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberContractContentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberContractContentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberContractContentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontract {
		edges = append(edges, membercontractcontent.EdgeContract)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberContractContentMutation) EdgeCleared(name string) bool {
	switch name {
	case membercontractcontent.EdgeContract:
		return m.clearedcontract
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberContractContentMutation) ClearEdge(name string) error {
	switch name {
	case membercontractcontent.EdgeContract:
		m.ClearContract()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberContractContentMutation) ResetEdge(name string) error {
	switch name {
	case membercontractcontent.EdgeContract:
		m.ResetContract()
		return nil
	}
	return fmt.Errorf("unknown MemberContractContent edge %s", name)
}

// MemberNoteMutation represents an operation that mutates the MemberNote nodes in the graph.
type MemberNoteMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	status        *int64
	addstatus     *int64
	note          *string
	clearedFields map[string]struct{}
	notes         *int64
	clearednotes  bool
	done          bool
	oldValue      func(context.Context) (*MemberNote, error)
	predicates    []predicate.MemberNote
}

var _ ent.Mutation = (*MemberNoteMutation)(nil)

// membernoteOption allows management of the mutation configuration using functional options.
type membernoteOption func(*MemberNoteMutation)

// newMemberNoteMutation creates new mutation for the MemberNote entity.
func newMemberNoteMutation(c config, op Op, opts ...membernoteOption) *MemberNoteMutation {
	m := &MemberNoteMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberNote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberNoteID sets the ID field of the mutation.
func withMemberNoteID(id int64) membernoteOption {
	return func(m *MemberNoteMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberNote
		)
		m.oldValue = func(ctx context.Context) (*MemberNote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberNote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberNote sets the old MemberNote of the mutation.
func withMemberNote(node *MemberNote) membernoteOption {
	return func(m *MemberNoteMutation) {
		m.oldValue = func(context.Context) (*MemberNote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberNoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberNoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberNote entities.
func (m *MemberNoteMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberNoteMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberNoteMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberNote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberNoteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberNoteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberNoteMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[membernote.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberNoteMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[membernote.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberNoteMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, membernote.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberNoteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberNoteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberNoteMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[membernote.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberNoteMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[membernote.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberNoteMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, membernote.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberNoteMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberNoteMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberNoteMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberNoteMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberNoteMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[membernote.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberNoteMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[membernote.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberNoteMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, membernote.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberNoteMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberNoteMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberNoteMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberNoteMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberNoteMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[membernote.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberNoteMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[membernote.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberNoteMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, membernote.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MemberNoteMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberNoteMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberNoteMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberNoteMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberNoteMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[membernote.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberNoteMutation) StatusCleared() bool {
	_, ok := m.clearedFields[membernote.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberNoteMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, membernote.FieldStatus)
}

// SetMemberID sets the "member_id" field.
func (m *MemberNoteMutation) SetMemberID(i int64) {
	m.notes = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberNoteMutation) MemberID() (r int64, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberNoteMutation) ClearMemberID() {
	m.notes = nil
	m.clearedFields[membernote.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberNoteMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[membernote.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberNoteMutation) ResetMemberID() {
	m.notes = nil
	delete(m.clearedFields, membernote.FieldMemberID)
}

// SetNote sets the "note" field.
func (m *MemberNoteMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *MemberNoteMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the MemberNote entity.
// If the MemberNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberNoteMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *MemberNoteMutation) ClearNote() {
	m.note = nil
	m.clearedFields[membernote.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *MemberNoteMutation) NoteCleared() bool {
	_, ok := m.clearedFields[membernote.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *MemberNoteMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, membernote.FieldNote)
}

// SetNotesID sets the "notes" edge to the Member entity by id.
func (m *MemberNoteMutation) SetNotesID(id int64) {
	m.notes = &id
}

// ClearNotes clears the "notes" edge to the Member entity.
func (m *MemberNoteMutation) ClearNotes() {
	m.clearednotes = true
	m.clearedFields[membernote.FieldMemberID] = struct{}{}
}

// NotesCleared reports if the "notes" edge to the Member entity was cleared.
func (m *MemberNoteMutation) NotesCleared() bool {
	return m.MemberIDCleared() || m.clearednotes
}

// NotesID returns the "notes" edge ID in the mutation.
func (m *MemberNoteMutation) NotesID() (id int64, exists bool) {
	if m.notes != nil {
		return *m.notes, true
	}
	return
}

// NotesIDs returns the "notes" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotesID instead. It exists only for internal usage by the builders.
func (m *MemberNoteMutation) NotesIDs() (ids []int64) {
	if id := m.notes; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotes resets all changes to the "notes" edge.
func (m *MemberNoteMutation) ResetNotes() {
	m.notes = nil
	m.clearednotes = false
}

// Where appends a list predicates to the MemberNoteMutation builder.
func (m *MemberNoteMutation) Where(ps ...predicate.MemberNote) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberNoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberNoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberNote, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberNoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberNoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberNote).
func (m *MemberNoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberNoteMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, membernote.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, membernote.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, membernote.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, membernote.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, membernote.FieldStatus)
	}
	if m.notes != nil {
		fields = append(fields, membernote.FieldMemberID)
	}
	if m.note != nil {
		fields = append(fields, membernote.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberNoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membernote.FieldCreatedAt:
		return m.CreatedAt()
	case membernote.FieldUpdatedAt:
		return m.UpdatedAt()
	case membernote.FieldDelete:
		return m.Delete()
	case membernote.FieldCreatedID:
		return m.CreatedID()
	case membernote.FieldStatus:
		return m.Status()
	case membernote.FieldMemberID:
		return m.MemberID()
	case membernote.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberNoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membernote.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case membernote.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case membernote.FieldDelete:
		return m.OldDelete(ctx)
	case membernote.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case membernote.FieldStatus:
		return m.OldStatus(ctx)
	case membernote.FieldMemberID:
		return m.OldMemberID(ctx)
	case membernote.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown MemberNote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberNoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membernote.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case membernote.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case membernote.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case membernote.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case membernote.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case membernote.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case membernote.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown MemberNote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberNoteMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, membernote.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, membernote.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, membernote.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberNoteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case membernote.FieldDelete:
		return m.AddedDelete()
	case membernote.FieldCreatedID:
		return m.AddedCreatedID()
	case membernote.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberNoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case membernote.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case membernote.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case membernote.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown MemberNote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberNoteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(membernote.FieldCreatedAt) {
		fields = append(fields, membernote.FieldCreatedAt)
	}
	if m.FieldCleared(membernote.FieldUpdatedAt) {
		fields = append(fields, membernote.FieldUpdatedAt)
	}
	if m.FieldCleared(membernote.FieldDelete) {
		fields = append(fields, membernote.FieldDelete)
	}
	if m.FieldCleared(membernote.FieldCreatedID) {
		fields = append(fields, membernote.FieldCreatedID)
	}
	if m.FieldCleared(membernote.FieldStatus) {
		fields = append(fields, membernote.FieldStatus)
	}
	if m.FieldCleared(membernote.FieldMemberID) {
		fields = append(fields, membernote.FieldMemberID)
	}
	if m.FieldCleared(membernote.FieldNote) {
		fields = append(fields, membernote.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberNoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberNoteMutation) ClearField(name string) error {
	switch name {
	case membernote.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case membernote.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case membernote.FieldDelete:
		m.ClearDelete()
		return nil
	case membernote.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case membernote.FieldStatus:
		m.ClearStatus()
		return nil
	case membernote.FieldMemberID:
		m.ClearMemberID()
		return nil
	case membernote.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown MemberNote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberNoteMutation) ResetField(name string) error {
	switch name {
	case membernote.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case membernote.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case membernote.FieldDelete:
		m.ResetDelete()
		return nil
	case membernote.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case membernote.FieldStatus:
		m.ResetStatus()
		return nil
	case membernote.FieldMemberID:
		m.ResetMemberID()
		return nil
	case membernote.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown MemberNote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberNoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.notes != nil {
		edges = append(edges, membernote.EdgeNotes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberNoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membernote.EdgeNotes:
		if id := m.notes; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberNoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberNoteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberNoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednotes {
		edges = append(edges, membernote.EdgeNotes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberNoteMutation) EdgeCleared(name string) bool {
	switch name {
	case membernote.EdgeNotes:
		return m.clearednotes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberNoteMutation) ClearEdge(name string) error {
	switch name {
	case membernote.EdgeNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown MemberNote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberNoteMutation) ResetEdge(name string) error {
	switch name {
	case membernote.EdgeNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown MemberNote edge %s", name)
}

// MemberProductMutation represents an operation that mutates the MemberProduct nodes in the graph.
type MemberProductMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int64
	created_at                      *time.Time
	updated_at                      *time.Time
	delete                          *int64
	adddelete                       *int64
	created_id                      *int64
	addcreated_id                   *int64
	status                          *int64
	addstatus                       *int64
	sn                              *string
	product_id                      *int64
	addproduct_id                   *int64
	venue_id                        *int64
	addvenue_id                     *int64
	order_id                        *int64
	addorder_id                     *int64
	name                            *string
	price                           *float64
	addprice                        *float64
	clearedFields                   map[string]struct{}
	members                         *int64
	clearedmembers                  bool
	member_product_propertys        map[int64]struct{}
	removedmember_product_propertys map[int64]struct{}
	clearedmember_product_propertys bool
	member_product_contents         map[int64]struct{}
	removedmember_product_contents  map[int64]struct{}
	clearedmember_product_contents  bool
	done                            bool
	oldValue                        func(context.Context) (*MemberProduct, error)
	predicates                      []predicate.MemberProduct
}

var _ ent.Mutation = (*MemberProductMutation)(nil)

// memberproductOption allows management of the mutation configuration using functional options.
type memberproductOption func(*MemberProductMutation)

// newMemberProductMutation creates new mutation for the MemberProduct entity.
func newMemberProductMutation(c config, op Op, opts ...memberproductOption) *MemberProductMutation {
	m := &MemberProductMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberProductID sets the ID field of the mutation.
func withMemberProductID(id int64) memberproductOption {
	return func(m *MemberProductMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberProduct
		)
		m.oldValue = func(ctx context.Context) (*MemberProduct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberProduct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberProduct sets the old MemberProduct of the mutation.
func withMemberProduct(node *MemberProduct) memberproductOption {
	return func(m *MemberProductMutation) {
		m.oldValue = func(context.Context) (*MemberProduct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberProduct entities.
func (m *MemberProductMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberProductMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberProductMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberProduct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberProductMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[memberproduct.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberProductMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberProductMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, memberproduct.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberProductMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[memberproduct.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberProductMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, memberproduct.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberProductMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberProductMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberProductMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberProductMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberProductMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[memberproduct.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberProductMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberProductMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, memberproduct.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberProductMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberProductMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberProductMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberProductMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberProductMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[memberproduct.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberProductMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberProductMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, memberproduct.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MemberProductMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberProductMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberProductMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberProductMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberProductMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[memberproduct.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberProductMutation) StatusCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberProductMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, memberproduct.FieldStatus)
}

// SetSn sets the "sn" field.
func (m *MemberProductMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *MemberProductMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ClearSn clears the value of the "sn" field.
func (m *MemberProductMutation) ClearSn() {
	m.sn = nil
	m.clearedFields[memberproduct.FieldSn] = struct{}{}
}

// SnCleared returns if the "sn" field was cleared in this mutation.
func (m *MemberProductMutation) SnCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldSn]
	return ok
}

// ResetSn resets all changes to the "sn" field.
func (m *MemberProductMutation) ResetSn() {
	m.sn = nil
	delete(m.clearedFields, memberproduct.FieldSn)
}

// SetMemberID sets the "member_id" field.
func (m *MemberProductMutation) SetMemberID(i int64) {
	m.members = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberProductMutation) MemberID() (r int64, exists bool) {
	v := m.members
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberProductMutation) ClearMemberID() {
	m.members = nil
	m.clearedFields[memberproduct.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberProductMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberProductMutation) ResetMemberID() {
	m.members = nil
	delete(m.clearedFields, memberproduct.FieldMemberID)
}

// SetProductID sets the "product_id" field.
func (m *MemberProductMutation) SetProductID(i int64) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *MemberProductMutation) ProductID() (r int64, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *MemberProductMutation) AddProductID(i int64) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *MemberProductMutation) AddedProductID() (r int64, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *MemberProductMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[memberproduct.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *MemberProductMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *MemberProductMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, memberproduct.FieldProductID)
}

// SetVenueID sets the "venue_id" field.
func (m *MemberProductMutation) SetVenueID(i int64) {
	m.venue_id = &i
	m.addvenue_id = nil
}

// VenueID returns the value of the "venue_id" field in the mutation.
func (m *MemberProductMutation) VenueID() (r int64, exists bool) {
	v := m.venue_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVenueID returns the old "venue_id" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldVenueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenueID: %w", err)
	}
	return oldValue.VenueID, nil
}

// AddVenueID adds i to the "venue_id" field.
func (m *MemberProductMutation) AddVenueID(i int64) {
	if m.addvenue_id != nil {
		*m.addvenue_id += i
	} else {
		m.addvenue_id = &i
	}
}

// AddedVenueID returns the value that was added to the "venue_id" field in this mutation.
func (m *MemberProductMutation) AddedVenueID() (r int64, exists bool) {
	v := m.addvenue_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVenueID clears the value of the "venue_id" field.
func (m *MemberProductMutation) ClearVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	m.clearedFields[memberproduct.FieldVenueID] = struct{}{}
}

// VenueIDCleared returns if the "venue_id" field was cleared in this mutation.
func (m *MemberProductMutation) VenueIDCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldVenueID]
	return ok
}

// ResetVenueID resets all changes to the "venue_id" field.
func (m *MemberProductMutation) ResetVenueID() {
	m.venue_id = nil
	m.addvenue_id = nil
	delete(m.clearedFields, memberproduct.FieldVenueID)
}

// SetOrderID sets the "order_id" field.
func (m *MemberProductMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *MemberProductMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *MemberProductMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *MemberProductMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderID clears the value of the "order_id" field.
func (m *MemberProductMutation) ClearOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	m.clearedFields[memberproduct.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *MemberProductMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *MemberProductMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	delete(m.clearedFields, memberproduct.FieldOrderID)
}

// SetName sets the "name" field.
func (m *MemberProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberProductMutation) ClearName() {
	m.name = nil
	m.clearedFields[memberproduct.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberProductMutation) NameCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberProductMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, memberproduct.FieldName)
}

// SetPrice sets the "price" field.
func (m *MemberProductMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *MemberProductMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the MemberProduct entity.
// If the MemberProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *MemberProductMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *MemberProductMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *MemberProductMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[memberproduct.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *MemberProductMutation) PriceCleared() bool {
	_, ok := m.clearedFields[memberproduct.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *MemberProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, memberproduct.FieldPrice)
}

// SetMembersID sets the "members" edge to the Member entity by id.
func (m *MemberProductMutation) SetMembersID(id int64) {
	m.members = &id
}

// ClearMembers clears the "members" edge to the Member entity.
func (m *MemberProductMutation) ClearMembers() {
	m.clearedmembers = true
	m.clearedFields[memberproduct.FieldMemberID] = struct{}{}
}

// MembersCleared reports if the "members" edge to the Member entity was cleared.
func (m *MemberProductMutation) MembersCleared() bool {
	return m.MemberIDCleared() || m.clearedmembers
}

// MembersID returns the "members" edge ID in the mutation.
func (m *MemberProductMutation) MembersID() (id int64, exists bool) {
	if m.members != nil {
		return *m.members, true
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MembersID instead. It exists only for internal usage by the builders.
func (m *MemberProductMutation) MembersIDs() (ids []int64) {
	if id := m.members; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *MemberProductMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
}

// AddMemberProductPropertyIDs adds the "member_product_propertys" edge to the MemberProductProperty entity by ids.
func (m *MemberProductMutation) AddMemberProductPropertyIDs(ids ...int64) {
	if m.member_product_propertys == nil {
		m.member_product_propertys = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_product_propertys[ids[i]] = struct{}{}
	}
}

// ClearMemberProductPropertys clears the "member_product_propertys" edge to the MemberProductProperty entity.
func (m *MemberProductMutation) ClearMemberProductPropertys() {
	m.clearedmember_product_propertys = true
}

// MemberProductPropertysCleared reports if the "member_product_propertys" edge to the MemberProductProperty entity was cleared.
func (m *MemberProductMutation) MemberProductPropertysCleared() bool {
	return m.clearedmember_product_propertys
}

// RemoveMemberProductPropertyIDs removes the "member_product_propertys" edge to the MemberProductProperty entity by IDs.
func (m *MemberProductMutation) RemoveMemberProductPropertyIDs(ids ...int64) {
	if m.removedmember_product_propertys == nil {
		m.removedmember_product_propertys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_product_propertys, ids[i])
		m.removedmember_product_propertys[ids[i]] = struct{}{}
	}
}

// RemovedMemberProductPropertys returns the removed IDs of the "member_product_propertys" edge to the MemberProductProperty entity.
func (m *MemberProductMutation) RemovedMemberProductPropertysIDs() (ids []int64) {
	for id := range m.removedmember_product_propertys {
		ids = append(ids, id)
	}
	return
}

// MemberProductPropertysIDs returns the "member_product_propertys" edge IDs in the mutation.
func (m *MemberProductMutation) MemberProductPropertysIDs() (ids []int64) {
	for id := range m.member_product_propertys {
		ids = append(ids, id)
	}
	return
}

// ResetMemberProductPropertys resets all changes to the "member_product_propertys" edge.
func (m *MemberProductMutation) ResetMemberProductPropertys() {
	m.member_product_propertys = nil
	m.clearedmember_product_propertys = false
	m.removedmember_product_propertys = nil
}

// AddMemberProductContentIDs adds the "member_product_contents" edge to the MemberContract entity by ids.
func (m *MemberProductMutation) AddMemberProductContentIDs(ids ...int64) {
	if m.member_product_contents == nil {
		m.member_product_contents = make(map[int64]struct{})
	}
	for i := range ids {
		m.member_product_contents[ids[i]] = struct{}{}
	}
}

// ClearMemberProductContents clears the "member_product_contents" edge to the MemberContract entity.
func (m *MemberProductMutation) ClearMemberProductContents() {
	m.clearedmember_product_contents = true
}

// MemberProductContentsCleared reports if the "member_product_contents" edge to the MemberContract entity was cleared.
func (m *MemberProductMutation) MemberProductContentsCleared() bool {
	return m.clearedmember_product_contents
}

// RemoveMemberProductContentIDs removes the "member_product_contents" edge to the MemberContract entity by IDs.
func (m *MemberProductMutation) RemoveMemberProductContentIDs(ids ...int64) {
	if m.removedmember_product_contents == nil {
		m.removedmember_product_contents = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.member_product_contents, ids[i])
		m.removedmember_product_contents[ids[i]] = struct{}{}
	}
}

// RemovedMemberProductContents returns the removed IDs of the "member_product_contents" edge to the MemberContract entity.
func (m *MemberProductMutation) RemovedMemberProductContentsIDs() (ids []int64) {
	for id := range m.removedmember_product_contents {
		ids = append(ids, id)
	}
	return
}

// MemberProductContentsIDs returns the "member_product_contents" edge IDs in the mutation.
func (m *MemberProductMutation) MemberProductContentsIDs() (ids []int64) {
	for id := range m.member_product_contents {
		ids = append(ids, id)
	}
	return
}

// ResetMemberProductContents resets all changes to the "member_product_contents" edge.
func (m *MemberProductMutation) ResetMemberProductContents() {
	m.member_product_contents = nil
	m.clearedmember_product_contents = false
	m.removedmember_product_contents = nil
}

// Where appends a list predicates to the MemberProductMutation builder.
func (m *MemberProductMutation) Where(ps ...predicate.MemberProduct) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberProduct, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberProduct).
func (m *MemberProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberProductMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, memberproduct.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, memberproduct.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, memberproduct.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, memberproduct.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, memberproduct.FieldStatus)
	}
	if m.sn != nil {
		fields = append(fields, memberproduct.FieldSn)
	}
	if m.members != nil {
		fields = append(fields, memberproduct.FieldMemberID)
	}
	if m.product_id != nil {
		fields = append(fields, memberproduct.FieldProductID)
	}
	if m.venue_id != nil {
		fields = append(fields, memberproduct.FieldVenueID)
	}
	if m.order_id != nil {
		fields = append(fields, memberproduct.FieldOrderID)
	}
	if m.name != nil {
		fields = append(fields, memberproduct.FieldName)
	}
	if m.price != nil {
		fields = append(fields, memberproduct.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberproduct.FieldCreatedAt:
		return m.CreatedAt()
	case memberproduct.FieldUpdatedAt:
		return m.UpdatedAt()
	case memberproduct.FieldDelete:
		return m.Delete()
	case memberproduct.FieldCreatedID:
		return m.CreatedID()
	case memberproduct.FieldStatus:
		return m.Status()
	case memberproduct.FieldSn:
		return m.Sn()
	case memberproduct.FieldMemberID:
		return m.MemberID()
	case memberproduct.FieldProductID:
		return m.ProductID()
	case memberproduct.FieldVenueID:
		return m.VenueID()
	case memberproduct.FieldOrderID:
		return m.OrderID()
	case memberproduct.FieldName:
		return m.Name()
	case memberproduct.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberproduct.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case memberproduct.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case memberproduct.FieldDelete:
		return m.OldDelete(ctx)
	case memberproduct.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case memberproduct.FieldStatus:
		return m.OldStatus(ctx)
	case memberproduct.FieldSn:
		return m.OldSn(ctx)
	case memberproduct.FieldMemberID:
		return m.OldMemberID(ctx)
	case memberproduct.FieldProductID:
		return m.OldProductID(ctx)
	case memberproduct.FieldVenueID:
		return m.OldVenueID(ctx)
	case memberproduct.FieldOrderID:
		return m.OldOrderID(ctx)
	case memberproduct.FieldName:
		return m.OldName(ctx)
	case memberproduct.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown MemberProduct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberproduct.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case memberproduct.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case memberproduct.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case memberproduct.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case memberproduct.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case memberproduct.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case memberproduct.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case memberproduct.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case memberproduct.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenueID(v)
		return nil
	case memberproduct.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case memberproduct.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case memberproduct.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProduct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberProductMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, memberproduct.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, memberproduct.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, memberproduct.FieldStatus)
	}
	if m.addproduct_id != nil {
		fields = append(fields, memberproduct.FieldProductID)
	}
	if m.addvenue_id != nil {
		fields = append(fields, memberproduct.FieldVenueID)
	}
	if m.addorder_id != nil {
		fields = append(fields, memberproduct.FieldOrderID)
	}
	if m.addprice != nil {
		fields = append(fields, memberproduct.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case memberproduct.FieldDelete:
		return m.AddedDelete()
	case memberproduct.FieldCreatedID:
		return m.AddedCreatedID()
	case memberproduct.FieldStatus:
		return m.AddedStatus()
	case memberproduct.FieldProductID:
		return m.AddedProductID()
	case memberproduct.FieldVenueID:
		return m.AddedVenueID()
	case memberproduct.FieldOrderID:
		return m.AddedOrderID()
	case memberproduct.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case memberproduct.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case memberproduct.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case memberproduct.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case memberproduct.FieldProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case memberproduct.FieldVenueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVenueID(v)
		return nil
	case memberproduct.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case memberproduct.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProduct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(memberproduct.FieldCreatedAt) {
		fields = append(fields, memberproduct.FieldCreatedAt)
	}
	if m.FieldCleared(memberproduct.FieldUpdatedAt) {
		fields = append(fields, memberproduct.FieldUpdatedAt)
	}
	if m.FieldCleared(memberproduct.FieldDelete) {
		fields = append(fields, memberproduct.FieldDelete)
	}
	if m.FieldCleared(memberproduct.FieldCreatedID) {
		fields = append(fields, memberproduct.FieldCreatedID)
	}
	if m.FieldCleared(memberproduct.FieldStatus) {
		fields = append(fields, memberproduct.FieldStatus)
	}
	if m.FieldCleared(memberproduct.FieldSn) {
		fields = append(fields, memberproduct.FieldSn)
	}
	if m.FieldCleared(memberproduct.FieldMemberID) {
		fields = append(fields, memberproduct.FieldMemberID)
	}
	if m.FieldCleared(memberproduct.FieldProductID) {
		fields = append(fields, memberproduct.FieldProductID)
	}
	if m.FieldCleared(memberproduct.FieldVenueID) {
		fields = append(fields, memberproduct.FieldVenueID)
	}
	if m.FieldCleared(memberproduct.FieldOrderID) {
		fields = append(fields, memberproduct.FieldOrderID)
	}
	if m.FieldCleared(memberproduct.FieldName) {
		fields = append(fields, memberproduct.FieldName)
	}
	if m.FieldCleared(memberproduct.FieldPrice) {
		fields = append(fields, memberproduct.FieldPrice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberProductMutation) ClearField(name string) error {
	switch name {
	case memberproduct.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case memberproduct.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case memberproduct.FieldDelete:
		m.ClearDelete()
		return nil
	case memberproduct.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case memberproduct.FieldStatus:
		m.ClearStatus()
		return nil
	case memberproduct.FieldSn:
		m.ClearSn()
		return nil
	case memberproduct.FieldMemberID:
		m.ClearMemberID()
		return nil
	case memberproduct.FieldProductID:
		m.ClearProductID()
		return nil
	case memberproduct.FieldVenueID:
		m.ClearVenueID()
		return nil
	case memberproduct.FieldOrderID:
		m.ClearOrderID()
		return nil
	case memberproduct.FieldName:
		m.ClearName()
		return nil
	case memberproduct.FieldPrice:
		m.ClearPrice()
		return nil
	}
	return fmt.Errorf("unknown MemberProduct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberProductMutation) ResetField(name string) error {
	switch name {
	case memberproduct.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case memberproduct.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case memberproduct.FieldDelete:
		m.ResetDelete()
		return nil
	case memberproduct.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case memberproduct.FieldStatus:
		m.ResetStatus()
		return nil
	case memberproduct.FieldSn:
		m.ResetSn()
		return nil
	case memberproduct.FieldMemberID:
		m.ResetMemberID()
		return nil
	case memberproduct.FieldProductID:
		m.ResetProductID()
		return nil
	case memberproduct.FieldVenueID:
		m.ResetVenueID()
		return nil
	case memberproduct.FieldOrderID:
		m.ResetOrderID()
		return nil
	case memberproduct.FieldName:
		m.ResetName()
		return nil
	case memberproduct.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown MemberProduct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.members != nil {
		edges = append(edges, memberproduct.EdgeMembers)
	}
	if m.member_product_propertys != nil {
		edges = append(edges, memberproduct.EdgeMemberProductPropertys)
	}
	if m.member_product_contents != nil {
		edges = append(edges, memberproduct.EdgeMemberProductContents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case memberproduct.EdgeMembers:
		if id := m.members; id != nil {
			return []ent.Value{*id}
		}
	case memberproduct.EdgeMemberProductPropertys:
		ids := make([]ent.Value, 0, len(m.member_product_propertys))
		for id := range m.member_product_propertys {
			ids = append(ids, id)
		}
		return ids
	case memberproduct.EdgeMemberProductContents:
		ids := make([]ent.Value, 0, len(m.member_product_contents))
		for id := range m.member_product_contents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmember_product_propertys != nil {
		edges = append(edges, memberproduct.EdgeMemberProductPropertys)
	}
	if m.removedmember_product_contents != nil {
		edges = append(edges, memberproduct.EdgeMemberProductContents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case memberproduct.EdgeMemberProductPropertys:
		ids := make([]ent.Value, 0, len(m.removedmember_product_propertys))
		for id := range m.removedmember_product_propertys {
			ids = append(ids, id)
		}
		return ids
	case memberproduct.EdgeMemberProductContents:
		ids := make([]ent.Value, 0, len(m.removedmember_product_contents))
		for id := range m.removedmember_product_contents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmembers {
		edges = append(edges, memberproduct.EdgeMembers)
	}
	if m.clearedmember_product_propertys {
		edges = append(edges, memberproduct.EdgeMemberProductPropertys)
	}
	if m.clearedmember_product_contents {
		edges = append(edges, memberproduct.EdgeMemberProductContents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberProductMutation) EdgeCleared(name string) bool {
	switch name {
	case memberproduct.EdgeMembers:
		return m.clearedmembers
	case memberproduct.EdgeMemberProductPropertys:
		return m.clearedmember_product_propertys
	case memberproduct.EdgeMemberProductContents:
		return m.clearedmember_product_contents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberProductMutation) ClearEdge(name string) error {
	switch name {
	case memberproduct.EdgeMembers:
		m.ClearMembers()
		return nil
	}
	return fmt.Errorf("unknown MemberProduct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberProductMutation) ResetEdge(name string) error {
	switch name {
	case memberproduct.EdgeMembers:
		m.ResetMembers()
		return nil
	case memberproduct.EdgeMemberProductPropertys:
		m.ResetMemberProductPropertys()
		return nil
	case memberproduct.EdgeMemberProductContents:
		m.ResetMemberProductContents()
		return nil
	}
	return fmt.Errorf("unknown MemberProduct edge %s", name)
}

// MemberProductPropertyMutation represents an operation that mutates the MemberProductProperty nodes in the graph.
type MemberProductPropertyMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_at       *time.Time
	updated_at       *time.Time
	delete           *int64
	adddelete        *int64
	created_id       *int64
	addcreated_id    *int64
	status           *int64
	addstatus        *int64
	member_id        *int64
	addmember_id     *int64
	sn               *string
	property_id      *int64
	addproperty_id   *int64
	_type            *string
	name             *string
	duration         *int64
	addduration      *int64
	length           *int64
	addlength        *int64
	count            *int64
	addcount         *int64
	count_surplus    *int64
	addcount_surplus *int64
	price            *float64
	addprice         *float64
	validity_at      *time.Time
	cancel_at        *time.Time
	clearedFields    map[string]struct{}
	owner            *int64
	clearedowner     bool
	done             bool
	oldValue         func(context.Context) (*MemberProductProperty, error)
	predicates       []predicate.MemberProductProperty
}

var _ ent.Mutation = (*MemberProductPropertyMutation)(nil)

// memberproductpropertyOption allows management of the mutation configuration using functional options.
type memberproductpropertyOption func(*MemberProductPropertyMutation)

// newMemberProductPropertyMutation creates new mutation for the MemberProductProperty entity.
func newMemberProductPropertyMutation(c config, op Op, opts ...memberproductpropertyOption) *MemberProductPropertyMutation {
	m := &MemberProductPropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberProductProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberProductPropertyID sets the ID field of the mutation.
func withMemberProductPropertyID(id int64) memberproductpropertyOption {
	return func(m *MemberProductPropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberProductProperty
		)
		m.oldValue = func(ctx context.Context) (*MemberProductProperty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberProductProperty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberProductProperty sets the old MemberProductProperty of the mutation.
func withMemberProductProperty(node *MemberProductProperty) memberproductpropertyOption {
	return func(m *MemberProductPropertyMutation) {
		m.oldValue = func(context.Context) (*MemberProductProperty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberProductPropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberProductPropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberProductProperty entities.
func (m *MemberProductPropertyMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberProductPropertyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberProductPropertyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberProductProperty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberProductPropertyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberProductPropertyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberProductPropertyMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[memberproductproperty.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberProductPropertyMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, memberproductproperty.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberProductPropertyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberProductPropertyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberProductPropertyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[memberproductproperty.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberProductPropertyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, memberproductproperty.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberProductPropertyMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberProductPropertyMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberProductPropertyMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberProductPropertyMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberProductPropertyMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[memberproductproperty.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberProductPropertyMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, memberproductproperty.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberProductPropertyMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberProductPropertyMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberProductPropertyMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberProductPropertyMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberProductPropertyMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[memberproductproperty.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberProductPropertyMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, memberproductproperty.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *MemberProductPropertyMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *MemberProductPropertyMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *MemberProductPropertyMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *MemberProductPropertyMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *MemberProductPropertyMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[memberproductproperty.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) StatusCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MemberProductPropertyMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, memberproductproperty.FieldStatus)
}

// SetMemberID sets the "member_id" field.
func (m *MemberProductPropertyMutation) SetMemberID(i int64) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberProductPropertyMutation) MemberID() (r int64, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *MemberProductPropertyMutation) AddMemberID(i int64) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *MemberProductPropertyMutation) AddedMemberID() (r int64, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberProductPropertyMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[memberproductproperty.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberProductPropertyMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, memberproductproperty.FieldMemberID)
}

// SetMemberProductID sets the "member_product_id" field.
func (m *MemberProductPropertyMutation) SetMemberProductID(i int64) {
	m.owner = &i
}

// MemberProductID returns the value of the "member_product_id" field in the mutation.
func (m *MemberProductPropertyMutation) MemberProductID() (r int64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberProductID returns the old "member_product_id" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldMemberProductID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberProductID: %w", err)
	}
	return oldValue.MemberProductID, nil
}

// ClearMemberProductID clears the value of the "member_product_id" field.
func (m *MemberProductPropertyMutation) ClearMemberProductID() {
	m.owner = nil
	m.clearedFields[memberproductproperty.FieldMemberProductID] = struct{}{}
}

// MemberProductIDCleared returns if the "member_product_id" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) MemberProductIDCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldMemberProductID]
	return ok
}

// ResetMemberProductID resets all changes to the "member_product_id" field.
func (m *MemberProductPropertyMutation) ResetMemberProductID() {
	m.owner = nil
	delete(m.clearedFields, memberproductproperty.FieldMemberProductID)
}

// SetSn sets the "sn" field.
func (m *MemberProductPropertyMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *MemberProductPropertyMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ClearSn clears the value of the "sn" field.
func (m *MemberProductPropertyMutation) ClearSn() {
	m.sn = nil
	m.clearedFields[memberproductproperty.FieldSn] = struct{}{}
}

// SnCleared returns if the "sn" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) SnCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldSn]
	return ok
}

// ResetSn resets all changes to the "sn" field.
func (m *MemberProductPropertyMutation) ResetSn() {
	m.sn = nil
	delete(m.clearedFields, memberproductproperty.FieldSn)
}

// SetPropertyID sets the "property_id" field.
func (m *MemberProductPropertyMutation) SetPropertyID(i int64) {
	m.property_id = &i
	m.addproperty_id = nil
}

// PropertyID returns the value of the "property_id" field in the mutation.
func (m *MemberProductPropertyMutation) PropertyID() (r int64, exists bool) {
	v := m.property_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyID returns the old "property_id" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldPropertyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyID: %w", err)
	}
	return oldValue.PropertyID, nil
}

// AddPropertyID adds i to the "property_id" field.
func (m *MemberProductPropertyMutation) AddPropertyID(i int64) {
	if m.addproperty_id != nil {
		*m.addproperty_id += i
	} else {
		m.addproperty_id = &i
	}
}

// AddedPropertyID returns the value that was added to the "property_id" field in this mutation.
func (m *MemberProductPropertyMutation) AddedPropertyID() (r int64, exists bool) {
	v := m.addproperty_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPropertyID clears the value of the "property_id" field.
func (m *MemberProductPropertyMutation) ClearPropertyID() {
	m.property_id = nil
	m.addproperty_id = nil
	m.clearedFields[memberproductproperty.FieldPropertyID] = struct{}{}
}

// PropertyIDCleared returns if the "property_id" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) PropertyIDCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldPropertyID]
	return ok
}

// ResetPropertyID resets all changes to the "property_id" field.
func (m *MemberProductPropertyMutation) ResetPropertyID() {
	m.property_id = nil
	m.addproperty_id = nil
	delete(m.clearedFields, memberproductproperty.FieldPropertyID)
}

// SetType sets the "type" field.
func (m *MemberProductPropertyMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MemberProductPropertyMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *MemberProductPropertyMutation) ClearType() {
	m._type = nil
	m.clearedFields[memberproductproperty.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) TypeCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *MemberProductPropertyMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, memberproductproperty.FieldType)
}

// SetName sets the "name" field.
func (m *MemberProductPropertyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MemberProductPropertyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MemberProductPropertyMutation) ClearName() {
	m.name = nil
	m.clearedFields[memberproductproperty.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) NameCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MemberProductPropertyMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, memberproductproperty.FieldName)
}

// SetDuration sets the "duration" field.
func (m *MemberProductPropertyMutation) SetDuration(i int64) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *MemberProductPropertyMutation) Duration() (r int64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldDuration(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *MemberProductPropertyMutation) AddDuration(i int64) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *MemberProductPropertyMutation) AddedDuration() (r int64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *MemberProductPropertyMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[memberproductproperty.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) DurationCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *MemberProductPropertyMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, memberproductproperty.FieldDuration)
}

// SetLength sets the "length" field.
func (m *MemberProductPropertyMutation) SetLength(i int64) {
	m.length = &i
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *MemberProductPropertyMutation) Length() (r int64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldLength(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds i to the "length" field.
func (m *MemberProductPropertyMutation) AddLength(i int64) {
	if m.addlength != nil {
		*m.addlength += i
	} else {
		m.addlength = &i
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *MemberProductPropertyMutation) AddedLength() (r int64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ClearLength clears the value of the "length" field.
func (m *MemberProductPropertyMutation) ClearLength() {
	m.length = nil
	m.addlength = nil
	m.clearedFields[memberproductproperty.FieldLength] = struct{}{}
}

// LengthCleared returns if the "length" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) LengthCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldLength]
	return ok
}

// ResetLength resets all changes to the "length" field.
func (m *MemberProductPropertyMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
	delete(m.clearedFields, memberproductproperty.FieldLength)
}

// SetCount sets the "count" field.
func (m *MemberProductPropertyMutation) SetCount(i int64) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *MemberProductPropertyMutation) Count() (r int64, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *MemberProductPropertyMutation) AddCount(i int64) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *MemberProductPropertyMutation) AddedCount() (r int64, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ClearCount clears the value of the "count" field.
func (m *MemberProductPropertyMutation) ClearCount() {
	m.count = nil
	m.addcount = nil
	m.clearedFields[memberproductproperty.FieldCount] = struct{}{}
}

// CountCleared returns if the "count" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) CountCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldCount]
	return ok
}

// ResetCount resets all changes to the "count" field.
func (m *MemberProductPropertyMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
	delete(m.clearedFields, memberproductproperty.FieldCount)
}

// SetCountSurplus sets the "count_surplus" field.
func (m *MemberProductPropertyMutation) SetCountSurplus(i int64) {
	m.count_surplus = &i
	m.addcount_surplus = nil
}

// CountSurplus returns the value of the "count_surplus" field in the mutation.
func (m *MemberProductPropertyMutation) CountSurplus() (r int64, exists bool) {
	v := m.count_surplus
	if v == nil {
		return
	}
	return *v, true
}

// OldCountSurplus returns the old "count_surplus" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldCountSurplus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountSurplus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountSurplus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountSurplus: %w", err)
	}
	return oldValue.CountSurplus, nil
}

// AddCountSurplus adds i to the "count_surplus" field.
func (m *MemberProductPropertyMutation) AddCountSurplus(i int64) {
	if m.addcount_surplus != nil {
		*m.addcount_surplus += i
	} else {
		m.addcount_surplus = &i
	}
}

// AddedCountSurplus returns the value that was added to the "count_surplus" field in this mutation.
func (m *MemberProductPropertyMutation) AddedCountSurplus() (r int64, exists bool) {
	v := m.addcount_surplus
	if v == nil {
		return
	}
	return *v, true
}

// ClearCountSurplus clears the value of the "count_surplus" field.
func (m *MemberProductPropertyMutation) ClearCountSurplus() {
	m.count_surplus = nil
	m.addcount_surplus = nil
	m.clearedFields[memberproductproperty.FieldCountSurplus] = struct{}{}
}

// CountSurplusCleared returns if the "count_surplus" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) CountSurplusCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldCountSurplus]
	return ok
}

// ResetCountSurplus resets all changes to the "count_surplus" field.
func (m *MemberProductPropertyMutation) ResetCountSurplus() {
	m.count_surplus = nil
	m.addcount_surplus = nil
	delete(m.clearedFields, memberproductproperty.FieldCountSurplus)
}

// SetPrice sets the "price" field.
func (m *MemberProductPropertyMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *MemberProductPropertyMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *MemberProductPropertyMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *MemberProductPropertyMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *MemberProductPropertyMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[memberproductproperty.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) PriceCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *MemberProductPropertyMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, memberproductproperty.FieldPrice)
}

// SetValidityAt sets the "validity_at" field.
func (m *MemberProductPropertyMutation) SetValidityAt(t time.Time) {
	m.validity_at = &t
}

// ValidityAt returns the value of the "validity_at" field in the mutation.
func (m *MemberProductPropertyMutation) ValidityAt() (r time.Time, exists bool) {
	v := m.validity_at
	if v == nil {
		return
	}
	return *v, true
}

// OldValidityAt returns the old "validity_at" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldValidityAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidityAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidityAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidityAt: %w", err)
	}
	return oldValue.ValidityAt, nil
}

// ClearValidityAt clears the value of the "validity_at" field.
func (m *MemberProductPropertyMutation) ClearValidityAt() {
	m.validity_at = nil
	m.clearedFields[memberproductproperty.FieldValidityAt] = struct{}{}
}

// ValidityAtCleared returns if the "validity_at" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) ValidityAtCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldValidityAt]
	return ok
}

// ResetValidityAt resets all changes to the "validity_at" field.
func (m *MemberProductPropertyMutation) ResetValidityAt() {
	m.validity_at = nil
	delete(m.clearedFields, memberproductproperty.FieldValidityAt)
}

// SetCancelAt sets the "cancel_at" field.
func (m *MemberProductPropertyMutation) SetCancelAt(t time.Time) {
	m.cancel_at = &t
}

// CancelAt returns the value of the "cancel_at" field in the mutation.
func (m *MemberProductPropertyMutation) CancelAt() (r time.Time, exists bool) {
	v := m.cancel_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelAt returns the old "cancel_at" field's value of the MemberProductProperty entity.
// If the MemberProductProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProductPropertyMutation) OldCancelAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelAt: %w", err)
	}
	return oldValue.CancelAt, nil
}

// ClearCancelAt clears the value of the "cancel_at" field.
func (m *MemberProductPropertyMutation) ClearCancelAt() {
	m.cancel_at = nil
	m.clearedFields[memberproductproperty.FieldCancelAt] = struct{}{}
}

// CancelAtCleared returns if the "cancel_at" field was cleared in this mutation.
func (m *MemberProductPropertyMutation) CancelAtCleared() bool {
	_, ok := m.clearedFields[memberproductproperty.FieldCancelAt]
	return ok
}

// ResetCancelAt resets all changes to the "cancel_at" field.
func (m *MemberProductPropertyMutation) ResetCancelAt() {
	m.cancel_at = nil
	delete(m.clearedFields, memberproductproperty.FieldCancelAt)
}

// SetOwnerID sets the "owner" edge to the MemberProduct entity by id.
func (m *MemberProductPropertyMutation) SetOwnerID(id int64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the MemberProduct entity.
func (m *MemberProductPropertyMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[memberproductproperty.FieldMemberProductID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the MemberProduct entity was cleared.
func (m *MemberProductPropertyMutation) OwnerCleared() bool {
	return m.MemberProductIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *MemberProductPropertyMutation) OwnerID() (id int64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MemberProductPropertyMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *MemberProductPropertyMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the MemberProductPropertyMutation builder.
func (m *MemberProductPropertyMutation) Where(ps ...predicate.MemberProductProperty) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberProductPropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberProductPropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberProductProperty, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberProductPropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberProductPropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberProductProperty).
func (m *MemberProductPropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberProductPropertyMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, memberproductproperty.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, memberproductproperty.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, memberproductproperty.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, memberproductproperty.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, memberproductproperty.FieldStatus)
	}
	if m.member_id != nil {
		fields = append(fields, memberproductproperty.FieldMemberID)
	}
	if m.owner != nil {
		fields = append(fields, memberproductproperty.FieldMemberProductID)
	}
	if m.sn != nil {
		fields = append(fields, memberproductproperty.FieldSn)
	}
	if m.property_id != nil {
		fields = append(fields, memberproductproperty.FieldPropertyID)
	}
	if m._type != nil {
		fields = append(fields, memberproductproperty.FieldType)
	}
	if m.name != nil {
		fields = append(fields, memberproductproperty.FieldName)
	}
	if m.duration != nil {
		fields = append(fields, memberproductproperty.FieldDuration)
	}
	if m.length != nil {
		fields = append(fields, memberproductproperty.FieldLength)
	}
	if m.count != nil {
		fields = append(fields, memberproductproperty.FieldCount)
	}
	if m.count_surplus != nil {
		fields = append(fields, memberproductproperty.FieldCountSurplus)
	}
	if m.price != nil {
		fields = append(fields, memberproductproperty.FieldPrice)
	}
	if m.validity_at != nil {
		fields = append(fields, memberproductproperty.FieldValidityAt)
	}
	if m.cancel_at != nil {
		fields = append(fields, memberproductproperty.FieldCancelAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberProductPropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberproductproperty.FieldCreatedAt:
		return m.CreatedAt()
	case memberproductproperty.FieldUpdatedAt:
		return m.UpdatedAt()
	case memberproductproperty.FieldDelete:
		return m.Delete()
	case memberproductproperty.FieldCreatedID:
		return m.CreatedID()
	case memberproductproperty.FieldStatus:
		return m.Status()
	case memberproductproperty.FieldMemberID:
		return m.MemberID()
	case memberproductproperty.FieldMemberProductID:
		return m.MemberProductID()
	case memberproductproperty.FieldSn:
		return m.Sn()
	case memberproductproperty.FieldPropertyID:
		return m.PropertyID()
	case memberproductproperty.FieldType:
		return m.GetType()
	case memberproductproperty.FieldName:
		return m.Name()
	case memberproductproperty.FieldDuration:
		return m.Duration()
	case memberproductproperty.FieldLength:
		return m.Length()
	case memberproductproperty.FieldCount:
		return m.Count()
	case memberproductproperty.FieldCountSurplus:
		return m.CountSurplus()
	case memberproductproperty.FieldPrice:
		return m.Price()
	case memberproductproperty.FieldValidityAt:
		return m.ValidityAt()
	case memberproductproperty.FieldCancelAt:
		return m.CancelAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberProductPropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberproductproperty.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case memberproductproperty.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case memberproductproperty.FieldDelete:
		return m.OldDelete(ctx)
	case memberproductproperty.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case memberproductproperty.FieldStatus:
		return m.OldStatus(ctx)
	case memberproductproperty.FieldMemberID:
		return m.OldMemberID(ctx)
	case memberproductproperty.FieldMemberProductID:
		return m.OldMemberProductID(ctx)
	case memberproductproperty.FieldSn:
		return m.OldSn(ctx)
	case memberproductproperty.FieldPropertyID:
		return m.OldPropertyID(ctx)
	case memberproductproperty.FieldType:
		return m.OldType(ctx)
	case memberproductproperty.FieldName:
		return m.OldName(ctx)
	case memberproductproperty.FieldDuration:
		return m.OldDuration(ctx)
	case memberproductproperty.FieldLength:
		return m.OldLength(ctx)
	case memberproductproperty.FieldCount:
		return m.OldCount(ctx)
	case memberproductproperty.FieldCountSurplus:
		return m.OldCountSurplus(ctx)
	case memberproductproperty.FieldPrice:
		return m.OldPrice(ctx)
	case memberproductproperty.FieldValidityAt:
		return m.OldValidityAt(ctx)
	case memberproductproperty.FieldCancelAt:
		return m.OldCancelAt(ctx)
	}
	return nil, fmt.Errorf("unknown MemberProductProperty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProductPropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberproductproperty.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case memberproductproperty.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case memberproductproperty.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case memberproductproperty.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case memberproductproperty.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case memberproductproperty.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case memberproductproperty.FieldMemberProductID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberProductID(v)
		return nil
	case memberproductproperty.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case memberproductproperty.FieldPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyID(v)
		return nil
	case memberproductproperty.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case memberproductproperty.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case memberproductproperty.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case memberproductproperty.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case memberproductproperty.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case memberproductproperty.FieldCountSurplus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountSurplus(v)
		return nil
	case memberproductproperty.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case memberproductproperty.FieldValidityAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidityAt(v)
		return nil
	case memberproductproperty.FieldCancelAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelAt(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProductProperty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberProductPropertyMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, memberproductproperty.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, memberproductproperty.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, memberproductproperty.FieldStatus)
	}
	if m.addmember_id != nil {
		fields = append(fields, memberproductproperty.FieldMemberID)
	}
	if m.addproperty_id != nil {
		fields = append(fields, memberproductproperty.FieldPropertyID)
	}
	if m.addduration != nil {
		fields = append(fields, memberproductproperty.FieldDuration)
	}
	if m.addlength != nil {
		fields = append(fields, memberproductproperty.FieldLength)
	}
	if m.addcount != nil {
		fields = append(fields, memberproductproperty.FieldCount)
	}
	if m.addcount_surplus != nil {
		fields = append(fields, memberproductproperty.FieldCountSurplus)
	}
	if m.addprice != nil {
		fields = append(fields, memberproductproperty.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberProductPropertyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case memberproductproperty.FieldDelete:
		return m.AddedDelete()
	case memberproductproperty.FieldCreatedID:
		return m.AddedCreatedID()
	case memberproductproperty.FieldStatus:
		return m.AddedStatus()
	case memberproductproperty.FieldMemberID:
		return m.AddedMemberID()
	case memberproductproperty.FieldPropertyID:
		return m.AddedPropertyID()
	case memberproductproperty.FieldDuration:
		return m.AddedDuration()
	case memberproductproperty.FieldLength:
		return m.AddedLength()
	case memberproductproperty.FieldCount:
		return m.AddedCount()
	case memberproductproperty.FieldCountSurplus:
		return m.AddedCountSurplus()
	case memberproductproperty.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProductPropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case memberproductproperty.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case memberproductproperty.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case memberproductproperty.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case memberproductproperty.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	case memberproductproperty.FieldPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPropertyID(v)
		return nil
	case memberproductproperty.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case memberproductproperty.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case memberproductproperty.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case memberproductproperty.FieldCountSurplus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCountSurplus(v)
		return nil
	case memberproductproperty.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProductProperty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberProductPropertyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(memberproductproperty.FieldCreatedAt) {
		fields = append(fields, memberproductproperty.FieldCreatedAt)
	}
	if m.FieldCleared(memberproductproperty.FieldUpdatedAt) {
		fields = append(fields, memberproductproperty.FieldUpdatedAt)
	}
	if m.FieldCleared(memberproductproperty.FieldDelete) {
		fields = append(fields, memberproductproperty.FieldDelete)
	}
	if m.FieldCleared(memberproductproperty.FieldCreatedID) {
		fields = append(fields, memberproductproperty.FieldCreatedID)
	}
	if m.FieldCleared(memberproductproperty.FieldStatus) {
		fields = append(fields, memberproductproperty.FieldStatus)
	}
	if m.FieldCleared(memberproductproperty.FieldMemberID) {
		fields = append(fields, memberproductproperty.FieldMemberID)
	}
	if m.FieldCleared(memberproductproperty.FieldMemberProductID) {
		fields = append(fields, memberproductproperty.FieldMemberProductID)
	}
	if m.FieldCleared(memberproductproperty.FieldSn) {
		fields = append(fields, memberproductproperty.FieldSn)
	}
	if m.FieldCleared(memberproductproperty.FieldPropertyID) {
		fields = append(fields, memberproductproperty.FieldPropertyID)
	}
	if m.FieldCleared(memberproductproperty.FieldType) {
		fields = append(fields, memberproductproperty.FieldType)
	}
	if m.FieldCleared(memberproductproperty.FieldName) {
		fields = append(fields, memberproductproperty.FieldName)
	}
	if m.FieldCleared(memberproductproperty.FieldDuration) {
		fields = append(fields, memberproductproperty.FieldDuration)
	}
	if m.FieldCleared(memberproductproperty.FieldLength) {
		fields = append(fields, memberproductproperty.FieldLength)
	}
	if m.FieldCleared(memberproductproperty.FieldCount) {
		fields = append(fields, memberproductproperty.FieldCount)
	}
	if m.FieldCleared(memberproductproperty.FieldCountSurplus) {
		fields = append(fields, memberproductproperty.FieldCountSurplus)
	}
	if m.FieldCleared(memberproductproperty.FieldPrice) {
		fields = append(fields, memberproductproperty.FieldPrice)
	}
	if m.FieldCleared(memberproductproperty.FieldValidityAt) {
		fields = append(fields, memberproductproperty.FieldValidityAt)
	}
	if m.FieldCleared(memberproductproperty.FieldCancelAt) {
		fields = append(fields, memberproductproperty.FieldCancelAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberProductPropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberProductPropertyMutation) ClearField(name string) error {
	switch name {
	case memberproductproperty.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case memberproductproperty.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case memberproductproperty.FieldDelete:
		m.ClearDelete()
		return nil
	case memberproductproperty.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case memberproductproperty.FieldStatus:
		m.ClearStatus()
		return nil
	case memberproductproperty.FieldMemberID:
		m.ClearMemberID()
		return nil
	case memberproductproperty.FieldMemberProductID:
		m.ClearMemberProductID()
		return nil
	case memberproductproperty.FieldSn:
		m.ClearSn()
		return nil
	case memberproductproperty.FieldPropertyID:
		m.ClearPropertyID()
		return nil
	case memberproductproperty.FieldType:
		m.ClearType()
		return nil
	case memberproductproperty.FieldName:
		m.ClearName()
		return nil
	case memberproductproperty.FieldDuration:
		m.ClearDuration()
		return nil
	case memberproductproperty.FieldLength:
		m.ClearLength()
		return nil
	case memberproductproperty.FieldCount:
		m.ClearCount()
		return nil
	case memberproductproperty.FieldCountSurplus:
		m.ClearCountSurplus()
		return nil
	case memberproductproperty.FieldPrice:
		m.ClearPrice()
		return nil
	case memberproductproperty.FieldValidityAt:
		m.ClearValidityAt()
		return nil
	case memberproductproperty.FieldCancelAt:
		m.ClearCancelAt()
		return nil
	}
	return fmt.Errorf("unknown MemberProductProperty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberProductPropertyMutation) ResetField(name string) error {
	switch name {
	case memberproductproperty.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case memberproductproperty.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case memberproductproperty.FieldDelete:
		m.ResetDelete()
		return nil
	case memberproductproperty.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case memberproductproperty.FieldStatus:
		m.ResetStatus()
		return nil
	case memberproductproperty.FieldMemberID:
		m.ResetMemberID()
		return nil
	case memberproductproperty.FieldMemberProductID:
		m.ResetMemberProductID()
		return nil
	case memberproductproperty.FieldSn:
		m.ResetSn()
		return nil
	case memberproductproperty.FieldPropertyID:
		m.ResetPropertyID()
		return nil
	case memberproductproperty.FieldType:
		m.ResetType()
		return nil
	case memberproductproperty.FieldName:
		m.ResetName()
		return nil
	case memberproductproperty.FieldDuration:
		m.ResetDuration()
		return nil
	case memberproductproperty.FieldLength:
		m.ResetLength()
		return nil
	case memberproductproperty.FieldCount:
		m.ResetCount()
		return nil
	case memberproductproperty.FieldCountSurplus:
		m.ResetCountSurplus()
		return nil
	case memberproductproperty.FieldPrice:
		m.ResetPrice()
		return nil
	case memberproductproperty.FieldValidityAt:
		m.ResetValidityAt()
		return nil
	case memberproductproperty.FieldCancelAt:
		m.ResetCancelAt()
		return nil
	}
	return fmt.Errorf("unknown MemberProductProperty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberProductPropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, memberproductproperty.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberProductPropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case memberproductproperty.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberProductPropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberProductPropertyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberProductPropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, memberproductproperty.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberProductPropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case memberproductproperty.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberProductPropertyMutation) ClearEdge(name string) error {
	switch name {
	case memberproductproperty.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown MemberProductProperty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberProductPropertyMutation) ResetEdge(name string) error {
	switch name {
	case memberproductproperty.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown MemberProductProperty edge %s", name)
}

// MemberProfileMutation represents an operation that mutates the MemberProfile nodes in the graph.
type MemberProfileMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	intention       *int64
	addintention    *int64
	source          *int64
	addsource       *int64
	gender          *int64
	addgender       *int64
	birthday        *time.Time
	email           *string
	wecom           *string
	relation_mid    *int64
	addrelation_mid *int64
	relation_mame   *string
	clearedFields   map[string]struct{}
	member          *int64
	clearedmember   bool
	done            bool
	oldValue        func(context.Context) (*MemberProfile, error)
	predicates      []predicate.MemberProfile
}

var _ ent.Mutation = (*MemberProfileMutation)(nil)

// memberprofileOption allows management of the mutation configuration using functional options.
type memberprofileOption func(*MemberProfileMutation)

// newMemberProfileMutation creates new mutation for the MemberProfile entity.
func newMemberProfileMutation(c config, op Op, opts ...memberprofileOption) *MemberProfileMutation {
	m := &MemberProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeMemberProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberProfileID sets the ID field of the mutation.
func withMemberProfileID(id int64) memberprofileOption {
	return func(m *MemberProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *MemberProfile
		)
		m.oldValue = func(ctx context.Context) (*MemberProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MemberProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMemberProfile sets the old MemberProfile of the mutation.
func withMemberProfile(node *MemberProfile) memberprofileOption {
	return func(m *MemberProfileMutation) {
		m.oldValue = func(context.Context) (*MemberProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MemberProfile entities.
func (m *MemberProfileMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberProfileMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberProfileMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MemberProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MemberProfileMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[memberprofile.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MemberProfileMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberProfileMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, memberprofile.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MemberProfileMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[memberprofile.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MemberProfileMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, memberprofile.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MemberProfileMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MemberProfileMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MemberProfileMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MemberProfileMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MemberProfileMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[memberprofile.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MemberProfileMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MemberProfileMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, memberprofile.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MemberProfileMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MemberProfileMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MemberProfileMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MemberProfileMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MemberProfileMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[memberprofile.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MemberProfileMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MemberProfileMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, memberprofile.FieldCreatedID)
}

// SetIntention sets the "intention" field.
func (m *MemberProfileMutation) SetIntention(i int64) {
	m.intention = &i
	m.addintention = nil
}

// Intention returns the value of the "intention" field in the mutation.
func (m *MemberProfileMutation) Intention() (r int64, exists bool) {
	v := m.intention
	if v == nil {
		return
	}
	return *v, true
}

// OldIntention returns the old "intention" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldIntention(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntention is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntention requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntention: %w", err)
	}
	return oldValue.Intention, nil
}

// AddIntention adds i to the "intention" field.
func (m *MemberProfileMutation) AddIntention(i int64) {
	if m.addintention != nil {
		*m.addintention += i
	} else {
		m.addintention = &i
	}
}

// AddedIntention returns the value that was added to the "intention" field in this mutation.
func (m *MemberProfileMutation) AddedIntention() (r int64, exists bool) {
	v := m.addintention
	if v == nil {
		return
	}
	return *v, true
}

// ClearIntention clears the value of the "intention" field.
func (m *MemberProfileMutation) ClearIntention() {
	m.intention = nil
	m.addintention = nil
	m.clearedFields[memberprofile.FieldIntention] = struct{}{}
}

// IntentionCleared returns if the "intention" field was cleared in this mutation.
func (m *MemberProfileMutation) IntentionCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldIntention]
	return ok
}

// ResetIntention resets all changes to the "intention" field.
func (m *MemberProfileMutation) ResetIntention() {
	m.intention = nil
	m.addintention = nil
	delete(m.clearedFields, memberprofile.FieldIntention)
}

// SetSource sets the "source" field.
func (m *MemberProfileMutation) SetSource(i int64) {
	m.source = &i
	m.addsource = nil
}

// Source returns the value of the "source" field in the mutation.
func (m *MemberProfileMutation) Source() (r int64, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldSource(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// AddSource adds i to the "source" field.
func (m *MemberProfileMutation) AddSource(i int64) {
	if m.addsource != nil {
		*m.addsource += i
	} else {
		m.addsource = &i
	}
}

// AddedSource returns the value that was added to the "source" field in this mutation.
func (m *MemberProfileMutation) AddedSource() (r int64, exists bool) {
	v := m.addsource
	if v == nil {
		return
	}
	return *v, true
}

// ClearSource clears the value of the "source" field.
func (m *MemberProfileMutation) ClearSource() {
	m.source = nil
	m.addsource = nil
	m.clearedFields[memberprofile.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *MemberProfileMutation) SourceCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *MemberProfileMutation) ResetSource() {
	m.source = nil
	m.addsource = nil
	delete(m.clearedFields, memberprofile.FieldSource)
}

// SetMemberID sets the "member_id" field.
func (m *MemberProfileMutation) SetMemberID(i int64) {
	m.member = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *MemberProfileMutation) MemberID() (r int64, exists bool) {
	v := m.member
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldMemberID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *MemberProfileMutation) ClearMemberID() {
	m.member = nil
	m.clearedFields[memberprofile.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *MemberProfileMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *MemberProfileMutation) ResetMemberID() {
	m.member = nil
	delete(m.clearedFields, memberprofile.FieldMemberID)
}

// SetGender sets the "gender" field.
func (m *MemberProfileMutation) SetGender(i int64) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *MemberProfileMutation) Gender() (r int64, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldGender(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *MemberProfileMutation) AddGender(i int64) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *MemberProfileMutation) AddedGender() (r int64, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ClearGender clears the value of the "gender" field.
func (m *MemberProfileMutation) ClearGender() {
	m.gender = nil
	m.addgender = nil
	m.clearedFields[memberprofile.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *MemberProfileMutation) GenderCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *MemberProfileMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
	delete(m.clearedFields, memberprofile.FieldGender)
}

// SetBirthday sets the "birthday" field.
func (m *MemberProfileMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *MemberProfileMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *MemberProfileMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[memberprofile.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *MemberProfileMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *MemberProfileMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, memberprofile.FieldBirthday)
}

// SetEmail sets the "email" field.
func (m *MemberProfileMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MemberProfileMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *MemberProfileMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[memberprofile.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *MemberProfileMutation) EmailCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *MemberProfileMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, memberprofile.FieldEmail)
}

// SetWecom sets the "wecom" field.
func (m *MemberProfileMutation) SetWecom(s string) {
	m.wecom = &s
}

// Wecom returns the value of the "wecom" field in the mutation.
func (m *MemberProfileMutation) Wecom() (r string, exists bool) {
	v := m.wecom
	if v == nil {
		return
	}
	return *v, true
}

// OldWecom returns the old "wecom" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldWecom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWecom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWecom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWecom: %w", err)
	}
	return oldValue.Wecom, nil
}

// ClearWecom clears the value of the "wecom" field.
func (m *MemberProfileMutation) ClearWecom() {
	m.wecom = nil
	m.clearedFields[memberprofile.FieldWecom] = struct{}{}
}

// WecomCleared returns if the "wecom" field was cleared in this mutation.
func (m *MemberProfileMutation) WecomCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldWecom]
	return ok
}

// ResetWecom resets all changes to the "wecom" field.
func (m *MemberProfileMutation) ResetWecom() {
	m.wecom = nil
	delete(m.clearedFields, memberprofile.FieldWecom)
}

// SetRelationMid sets the "relation_mid" field.
func (m *MemberProfileMutation) SetRelationMid(i int64) {
	m.relation_mid = &i
	m.addrelation_mid = nil
}

// RelationMid returns the value of the "relation_mid" field in the mutation.
func (m *MemberProfileMutation) RelationMid() (r int64, exists bool) {
	v := m.relation_mid
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationMid returns the old "relation_mid" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldRelationMid(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationMid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationMid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationMid: %w", err)
	}
	return oldValue.RelationMid, nil
}

// AddRelationMid adds i to the "relation_mid" field.
func (m *MemberProfileMutation) AddRelationMid(i int64) {
	if m.addrelation_mid != nil {
		*m.addrelation_mid += i
	} else {
		m.addrelation_mid = &i
	}
}

// AddedRelationMid returns the value that was added to the "relation_mid" field in this mutation.
func (m *MemberProfileMutation) AddedRelationMid() (r int64, exists bool) {
	v := m.addrelation_mid
	if v == nil {
		return
	}
	return *v, true
}

// ClearRelationMid clears the value of the "relation_mid" field.
func (m *MemberProfileMutation) ClearRelationMid() {
	m.relation_mid = nil
	m.addrelation_mid = nil
	m.clearedFields[memberprofile.FieldRelationMid] = struct{}{}
}

// RelationMidCleared returns if the "relation_mid" field was cleared in this mutation.
func (m *MemberProfileMutation) RelationMidCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldRelationMid]
	return ok
}

// ResetRelationMid resets all changes to the "relation_mid" field.
func (m *MemberProfileMutation) ResetRelationMid() {
	m.relation_mid = nil
	m.addrelation_mid = nil
	delete(m.clearedFields, memberprofile.FieldRelationMid)
}

// SetRelationMame sets the "relation_mame" field.
func (m *MemberProfileMutation) SetRelationMame(s string) {
	m.relation_mame = &s
}

// RelationMame returns the value of the "relation_mame" field in the mutation.
func (m *MemberProfileMutation) RelationMame() (r string, exists bool) {
	v := m.relation_mame
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationMame returns the old "relation_mame" field's value of the MemberProfile entity.
// If the MemberProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberProfileMutation) OldRelationMame(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationMame is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationMame requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationMame: %w", err)
	}
	return oldValue.RelationMame, nil
}

// ClearRelationMame clears the value of the "relation_mame" field.
func (m *MemberProfileMutation) ClearRelationMame() {
	m.relation_mame = nil
	m.clearedFields[memberprofile.FieldRelationMame] = struct{}{}
}

// RelationMameCleared returns if the "relation_mame" field was cleared in this mutation.
func (m *MemberProfileMutation) RelationMameCleared() bool {
	_, ok := m.clearedFields[memberprofile.FieldRelationMame]
	return ok
}

// ResetRelationMame resets all changes to the "relation_mame" field.
func (m *MemberProfileMutation) ResetRelationMame() {
	m.relation_mame = nil
	delete(m.clearedFields, memberprofile.FieldRelationMame)
}

// ClearMember clears the "member" edge to the Member entity.
func (m *MemberProfileMutation) ClearMember() {
	m.clearedmember = true
	m.clearedFields[memberprofile.FieldMemberID] = struct{}{}
}

// MemberCleared reports if the "member" edge to the Member entity was cleared.
func (m *MemberProfileMutation) MemberCleared() bool {
	return m.MemberIDCleared() || m.clearedmember
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *MemberProfileMutation) MemberIDs() (ids []int64) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *MemberProfileMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// Where appends a list predicates to the MemberProfileMutation builder.
func (m *MemberProfileMutation) Where(ps ...predicate.MemberProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MemberProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MemberProfile).
func (m *MemberProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberProfileMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, memberprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, memberprofile.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, memberprofile.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, memberprofile.FieldCreatedID)
	}
	if m.intention != nil {
		fields = append(fields, memberprofile.FieldIntention)
	}
	if m.source != nil {
		fields = append(fields, memberprofile.FieldSource)
	}
	if m.member != nil {
		fields = append(fields, memberprofile.FieldMemberID)
	}
	if m.gender != nil {
		fields = append(fields, memberprofile.FieldGender)
	}
	if m.birthday != nil {
		fields = append(fields, memberprofile.FieldBirthday)
	}
	if m.email != nil {
		fields = append(fields, memberprofile.FieldEmail)
	}
	if m.wecom != nil {
		fields = append(fields, memberprofile.FieldWecom)
	}
	if m.relation_mid != nil {
		fields = append(fields, memberprofile.FieldRelationMid)
	}
	if m.relation_mame != nil {
		fields = append(fields, memberprofile.FieldRelationMame)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case memberprofile.FieldCreatedAt:
		return m.CreatedAt()
	case memberprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case memberprofile.FieldDelete:
		return m.Delete()
	case memberprofile.FieldCreatedID:
		return m.CreatedID()
	case memberprofile.FieldIntention:
		return m.Intention()
	case memberprofile.FieldSource:
		return m.Source()
	case memberprofile.FieldMemberID:
		return m.MemberID()
	case memberprofile.FieldGender:
		return m.Gender()
	case memberprofile.FieldBirthday:
		return m.Birthday()
	case memberprofile.FieldEmail:
		return m.Email()
	case memberprofile.FieldWecom:
		return m.Wecom()
	case memberprofile.FieldRelationMid:
		return m.RelationMid()
	case memberprofile.FieldRelationMame:
		return m.RelationMame()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case memberprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case memberprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case memberprofile.FieldDelete:
		return m.OldDelete(ctx)
	case memberprofile.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case memberprofile.FieldIntention:
		return m.OldIntention(ctx)
	case memberprofile.FieldSource:
		return m.OldSource(ctx)
	case memberprofile.FieldMemberID:
		return m.OldMemberID(ctx)
	case memberprofile.FieldGender:
		return m.OldGender(ctx)
	case memberprofile.FieldBirthday:
		return m.OldBirthday(ctx)
	case memberprofile.FieldEmail:
		return m.OldEmail(ctx)
	case memberprofile.FieldWecom:
		return m.OldWecom(ctx)
	case memberprofile.FieldRelationMid:
		return m.OldRelationMid(ctx)
	case memberprofile.FieldRelationMame:
		return m.OldRelationMame(ctx)
	}
	return nil, fmt.Errorf("unknown MemberProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case memberprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case memberprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case memberprofile.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case memberprofile.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case memberprofile.FieldIntention:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntention(v)
		return nil
	case memberprofile.FieldSource:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case memberprofile.FieldMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case memberprofile.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case memberprofile.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case memberprofile.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case memberprofile.FieldWecom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWecom(v)
		return nil
	case memberprofile.FieldRelationMid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationMid(v)
		return nil
	case memberprofile.FieldRelationMame:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationMame(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberProfileMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, memberprofile.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, memberprofile.FieldCreatedID)
	}
	if m.addintention != nil {
		fields = append(fields, memberprofile.FieldIntention)
	}
	if m.addsource != nil {
		fields = append(fields, memberprofile.FieldSource)
	}
	if m.addgender != nil {
		fields = append(fields, memberprofile.FieldGender)
	}
	if m.addrelation_mid != nil {
		fields = append(fields, memberprofile.FieldRelationMid)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case memberprofile.FieldDelete:
		return m.AddedDelete()
	case memberprofile.FieldCreatedID:
		return m.AddedCreatedID()
	case memberprofile.FieldIntention:
		return m.AddedIntention()
	case memberprofile.FieldSource:
		return m.AddedSource()
	case memberprofile.FieldGender:
		return m.AddedGender()
	case memberprofile.FieldRelationMid:
		return m.AddedRelationMid()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case memberprofile.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case memberprofile.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case memberprofile.FieldIntention:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntention(v)
		return nil
	case memberprofile.FieldSource:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSource(v)
		return nil
	case memberprofile.FieldGender:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case memberprofile.FieldRelationMid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRelationMid(v)
		return nil
	}
	return fmt.Errorf("unknown MemberProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(memberprofile.FieldCreatedAt) {
		fields = append(fields, memberprofile.FieldCreatedAt)
	}
	if m.FieldCleared(memberprofile.FieldUpdatedAt) {
		fields = append(fields, memberprofile.FieldUpdatedAt)
	}
	if m.FieldCleared(memberprofile.FieldDelete) {
		fields = append(fields, memberprofile.FieldDelete)
	}
	if m.FieldCleared(memberprofile.FieldCreatedID) {
		fields = append(fields, memberprofile.FieldCreatedID)
	}
	if m.FieldCleared(memberprofile.FieldIntention) {
		fields = append(fields, memberprofile.FieldIntention)
	}
	if m.FieldCleared(memberprofile.FieldSource) {
		fields = append(fields, memberprofile.FieldSource)
	}
	if m.FieldCleared(memberprofile.FieldMemberID) {
		fields = append(fields, memberprofile.FieldMemberID)
	}
	if m.FieldCleared(memberprofile.FieldGender) {
		fields = append(fields, memberprofile.FieldGender)
	}
	if m.FieldCleared(memberprofile.FieldBirthday) {
		fields = append(fields, memberprofile.FieldBirthday)
	}
	if m.FieldCleared(memberprofile.FieldEmail) {
		fields = append(fields, memberprofile.FieldEmail)
	}
	if m.FieldCleared(memberprofile.FieldWecom) {
		fields = append(fields, memberprofile.FieldWecom)
	}
	if m.FieldCleared(memberprofile.FieldRelationMid) {
		fields = append(fields, memberprofile.FieldRelationMid)
	}
	if m.FieldCleared(memberprofile.FieldRelationMame) {
		fields = append(fields, memberprofile.FieldRelationMame)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberProfileMutation) ClearField(name string) error {
	switch name {
	case memberprofile.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case memberprofile.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case memberprofile.FieldDelete:
		m.ClearDelete()
		return nil
	case memberprofile.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case memberprofile.FieldIntention:
		m.ClearIntention()
		return nil
	case memberprofile.FieldSource:
		m.ClearSource()
		return nil
	case memberprofile.FieldMemberID:
		m.ClearMemberID()
		return nil
	case memberprofile.FieldGender:
		m.ClearGender()
		return nil
	case memberprofile.FieldBirthday:
		m.ClearBirthday()
		return nil
	case memberprofile.FieldEmail:
		m.ClearEmail()
		return nil
	case memberprofile.FieldWecom:
		m.ClearWecom()
		return nil
	case memberprofile.FieldRelationMid:
		m.ClearRelationMid()
		return nil
	case memberprofile.FieldRelationMame:
		m.ClearRelationMame()
		return nil
	}
	return fmt.Errorf("unknown MemberProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberProfileMutation) ResetField(name string) error {
	switch name {
	case memberprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case memberprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case memberprofile.FieldDelete:
		m.ResetDelete()
		return nil
	case memberprofile.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case memberprofile.FieldIntention:
		m.ResetIntention()
		return nil
	case memberprofile.FieldSource:
		m.ResetSource()
		return nil
	case memberprofile.FieldMemberID:
		m.ResetMemberID()
		return nil
	case memberprofile.FieldGender:
		m.ResetGender()
		return nil
	case memberprofile.FieldBirthday:
		m.ResetBirthday()
		return nil
	case memberprofile.FieldEmail:
		m.ResetEmail()
		return nil
	case memberprofile.FieldWecom:
		m.ResetWecom()
		return nil
	case memberprofile.FieldRelationMid:
		m.ResetRelationMid()
		return nil
	case memberprofile.FieldRelationMame:
		m.ResetRelationMame()
		return nil
	}
	return fmt.Errorf("unknown MemberProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.member != nil {
		edges = append(edges, memberprofile.EdgeMember)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case memberprofile.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmember {
		edges = append(edges, memberprofile.EdgeMember)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case memberprofile.EdgeMember:
		return m.clearedmember
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberProfileMutation) ClearEdge(name string) error {
	switch name {
	case memberprofile.EdgeMember:
		m.ClearMember()
		return nil
	}
	return fmt.Errorf("unknown MemberProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberProfileMutation) ResetEdge(name string) error {
	switch name {
	case memberprofile.EdgeMember:
		m.ResetMember()
		return nil
	}
	return fmt.Errorf("unknown MemberProfile edge %s", name)
}

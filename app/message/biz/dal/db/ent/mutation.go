// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"message/biz/dal/db/ent/messages"
	"message/biz/dal/db/ent/messagessentrecords"
	"message/biz/dal/db/ent/predicate"
	"message/biz/dal/db/ent/sms"
	"message/biz/dal/db/ent/smssentrecords"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMessages            = "Messages"
	TypeMessagesSentRecords = "MessagesSentRecords"
	TypeSms                 = "Sms"
	TypeSmsSentRecords      = "SmsSentRecords"
)

// MessagesMutation represents an operation that mutates the Messages nodes in the graph.
type MessagesMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	title           *string
	from_user_id    *int64
	addfrom_user_id *int64
	content         *string
	status          *messages.Status
	_type           *messages.Type
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Messages, error)
	predicates      []predicate.Messages
}

var _ ent.Mutation = (*MessagesMutation)(nil)

// messagesOption allows management of the mutation configuration using functional options.
type messagesOption func(*MessagesMutation)

// newMessagesMutation creates new mutation for the Messages entity.
func newMessagesMutation(c config, op Op, opts ...messagesOption) *MessagesMutation {
	m := &MessagesMutation{
		config:        c,
		op:            op,
		typ:           TypeMessages,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessagesID sets the ID field of the mutation.
func withMessagesID(id int64) messagesOption {
	return func(m *MessagesMutation) {
		var (
			err   error
			once  sync.Once
			value *Messages
		)
		m.oldValue = func(ctx context.Context) (*Messages, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Messages.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessages sets the old Messages of the mutation.
func withMessages(node *Messages) messagesOption {
	return func(m *MessagesMutation) {
		m.oldValue = func(context.Context) (*Messages, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessagesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessagesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Messages entities.
func (m *MessagesMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessagesMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessagesMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Messages.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessagesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessagesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MessagesMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[messages.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MessagesMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[messages.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessagesMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, messages.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessagesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessagesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MessagesMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[messages.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MessagesMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[messages.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessagesMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, messages.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MessagesMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MessagesMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MessagesMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MessagesMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MessagesMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[messages.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MessagesMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[messages.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MessagesMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, messages.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MessagesMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MessagesMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MessagesMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MessagesMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MessagesMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[messages.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MessagesMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[messages.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MessagesMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, messages.FieldCreatedID)
}

// SetTitle sets the "title" field.
func (m *MessagesMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *MessagesMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *MessagesMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[messages.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *MessagesMutation) TitleCleared() bool {
	_, ok := m.clearedFields[messages.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *MessagesMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, messages.FieldTitle)
}

// SetFromUserID sets the "from_user_id" field.
func (m *MessagesMutation) SetFromUserID(i int64) {
	m.from_user_id = &i
	m.addfrom_user_id = nil
}

// FromUserID returns the value of the "from_user_id" field in the mutation.
func (m *MessagesMutation) FromUserID() (r int64, exists bool) {
	v := m.from_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromUserID returns the old "from_user_id" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldFromUserID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromUserID: %w", err)
	}
	return oldValue.FromUserID, nil
}

// AddFromUserID adds i to the "from_user_id" field.
func (m *MessagesMutation) AddFromUserID(i int64) {
	if m.addfrom_user_id != nil {
		*m.addfrom_user_id += i
	} else {
		m.addfrom_user_id = &i
	}
}

// AddedFromUserID returns the value that was added to the "from_user_id" field in this mutation.
func (m *MessagesMutation) AddedFromUserID() (r int64, exists bool) {
	v := m.addfrom_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFromUserID clears the value of the "from_user_id" field.
func (m *MessagesMutation) ClearFromUserID() {
	m.from_user_id = nil
	m.addfrom_user_id = nil
	m.clearedFields[messages.FieldFromUserID] = struct{}{}
}

// FromUserIDCleared returns if the "from_user_id" field was cleared in this mutation.
func (m *MessagesMutation) FromUserIDCleared() bool {
	_, ok := m.clearedFields[messages.FieldFromUserID]
	return ok
}

// ResetFromUserID resets all changes to the "from_user_id" field.
func (m *MessagesMutation) ResetFromUserID() {
	m.from_user_id = nil
	m.addfrom_user_id = nil
	delete(m.clearedFields, messages.FieldFromUserID)
}

// SetContent sets the "content" field.
func (m *MessagesMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessagesMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *MessagesMutation) ClearContent() {
	m.content = nil
	m.clearedFields[messages.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *MessagesMutation) ContentCleared() bool {
	_, ok := m.clearedFields[messages.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *MessagesMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, messages.FieldContent)
}

// SetStatus sets the "status" field.
func (m *MessagesMutation) SetStatus(value messages.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MessagesMutation) Status() (r messages.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldStatus(ctx context.Context) (v *messages.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *MessagesMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[messages.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MessagesMutation) StatusCleared() bool {
	_, ok := m.clearedFields[messages.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MessagesMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, messages.FieldStatus)
}

// SetType sets the "type" field.
func (m *MessagesMutation) SetType(value messages.Type) {
	m._type = &value
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessagesMutation) GetType() (r messages.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Messages entity.
// If the Messages object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesMutation) OldType(ctx context.Context) (v *messages.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *MessagesMutation) ClearType() {
	m._type = nil
	m.clearedFields[messages.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *MessagesMutation) TypeCleared() bool {
	_, ok := m.clearedFields[messages.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *MessagesMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, messages.FieldType)
}

// Where appends a list predicates to the MessagesMutation builder.
func (m *MessagesMutation) Where(ps ...predicate.Messages) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessagesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessagesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Messages, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessagesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessagesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Messages).
func (m *MessagesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessagesMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, messages.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, messages.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, messages.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, messages.FieldCreatedID)
	}
	if m.title != nil {
		fields = append(fields, messages.FieldTitle)
	}
	if m.from_user_id != nil {
		fields = append(fields, messages.FieldFromUserID)
	}
	if m.content != nil {
		fields = append(fields, messages.FieldContent)
	}
	if m.status != nil {
		fields = append(fields, messages.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, messages.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessagesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messages.FieldCreatedAt:
		return m.CreatedAt()
	case messages.FieldUpdatedAt:
		return m.UpdatedAt()
	case messages.FieldDelete:
		return m.Delete()
	case messages.FieldCreatedID:
		return m.CreatedID()
	case messages.FieldTitle:
		return m.Title()
	case messages.FieldFromUserID:
		return m.FromUserID()
	case messages.FieldContent:
		return m.Content()
	case messages.FieldStatus:
		return m.Status()
	case messages.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessagesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messages.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case messages.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case messages.FieldDelete:
		return m.OldDelete(ctx)
	case messages.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case messages.FieldTitle:
		return m.OldTitle(ctx)
	case messages.FieldFromUserID:
		return m.OldFromUserID(ctx)
	case messages.FieldContent:
		return m.OldContent(ctx)
	case messages.FieldStatus:
		return m.OldStatus(ctx)
	case messages.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Messages field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messages.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case messages.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case messages.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case messages.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case messages.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case messages.FieldFromUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromUserID(v)
		return nil
	case messages.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case messages.FieldStatus:
		v, ok := value.(messages.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case messages.FieldType:
		v, ok := value.(messages.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Messages field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessagesMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, messages.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, messages.FieldCreatedID)
	}
	if m.addfrom_user_id != nil {
		fields = append(fields, messages.FieldFromUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessagesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case messages.FieldDelete:
		return m.AddedDelete()
	case messages.FieldCreatedID:
		return m.AddedCreatedID()
	case messages.FieldFromUserID:
		return m.AddedFromUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case messages.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case messages.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case messages.FieldFromUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Messages numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessagesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(messages.FieldCreatedAt) {
		fields = append(fields, messages.FieldCreatedAt)
	}
	if m.FieldCleared(messages.FieldUpdatedAt) {
		fields = append(fields, messages.FieldUpdatedAt)
	}
	if m.FieldCleared(messages.FieldDelete) {
		fields = append(fields, messages.FieldDelete)
	}
	if m.FieldCleared(messages.FieldCreatedID) {
		fields = append(fields, messages.FieldCreatedID)
	}
	if m.FieldCleared(messages.FieldTitle) {
		fields = append(fields, messages.FieldTitle)
	}
	if m.FieldCleared(messages.FieldFromUserID) {
		fields = append(fields, messages.FieldFromUserID)
	}
	if m.FieldCleared(messages.FieldContent) {
		fields = append(fields, messages.FieldContent)
	}
	if m.FieldCleared(messages.FieldStatus) {
		fields = append(fields, messages.FieldStatus)
	}
	if m.FieldCleared(messages.FieldType) {
		fields = append(fields, messages.FieldType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessagesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessagesMutation) ClearField(name string) error {
	switch name {
	case messages.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case messages.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case messages.FieldDelete:
		m.ClearDelete()
		return nil
	case messages.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case messages.FieldTitle:
		m.ClearTitle()
		return nil
	case messages.FieldFromUserID:
		m.ClearFromUserID()
		return nil
	case messages.FieldContent:
		m.ClearContent()
		return nil
	case messages.FieldStatus:
		m.ClearStatus()
		return nil
	case messages.FieldType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Messages nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessagesMutation) ResetField(name string) error {
	switch name {
	case messages.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case messages.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case messages.FieldDelete:
		m.ResetDelete()
		return nil
	case messages.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case messages.FieldTitle:
		m.ResetTitle()
		return nil
	case messages.FieldFromUserID:
		m.ResetFromUserID()
		return nil
	case messages.FieldContent:
		m.ResetContent()
		return nil
	case messages.FieldStatus:
		m.ResetStatus()
		return nil
	case messages.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Messages field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessagesMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessagesMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessagesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessagesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessagesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessagesMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessagesMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Messages unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessagesMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Messages edge %s", name)
}

// MessagesSentRecordsMutation represents an operation that mutates the MessagesSentRecords nodes in the graph.
type MessagesSentRecordsMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	delete        *int64
	adddelete     *int64
	created_id    *int64
	addcreated_id *int64
	message_id    *int64
	addmessage_id *int64
	to_user_id    *int64
	addto_user_id *int64
	status        *messagessentrecords.Status
	received_at   *time.Time
	read_at       *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MessagesSentRecords, error)
	predicates    []predicate.MessagesSentRecords
}

var _ ent.Mutation = (*MessagesSentRecordsMutation)(nil)

// messagessentrecordsOption allows management of the mutation configuration using functional options.
type messagessentrecordsOption func(*MessagesSentRecordsMutation)

// newMessagesSentRecordsMutation creates new mutation for the MessagesSentRecords entity.
func newMessagesSentRecordsMutation(c config, op Op, opts ...messagessentrecordsOption) *MessagesSentRecordsMutation {
	m := &MessagesSentRecordsMutation{
		config:        c,
		op:            op,
		typ:           TypeMessagesSentRecords,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessagesSentRecordsID sets the ID field of the mutation.
func withMessagesSentRecordsID(id int64) messagessentrecordsOption {
	return func(m *MessagesSentRecordsMutation) {
		var (
			err   error
			once  sync.Once
			value *MessagesSentRecords
		)
		m.oldValue = func(ctx context.Context) (*MessagesSentRecords, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MessagesSentRecords.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessagesSentRecords sets the old MessagesSentRecords of the mutation.
func withMessagesSentRecords(node *MessagesSentRecords) messagessentrecordsOption {
	return func(m *MessagesSentRecordsMutation) {
		m.oldValue = func(context.Context) (*MessagesSentRecords, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessagesSentRecordsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessagesSentRecordsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MessagesSentRecords entities.
func (m *MessagesSentRecordsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessagesSentRecordsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessagesSentRecordsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MessagesSentRecords.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessagesSentRecordsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessagesSentRecordsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MessagesSentRecords entity.
// If the MessagesSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesSentRecordsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MessagesSentRecordsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[messagessentrecords.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MessagesSentRecordsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[messagessentrecords.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessagesSentRecordsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, messagessentrecords.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessagesSentRecordsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessagesSentRecordsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MessagesSentRecords entity.
// If the MessagesSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesSentRecordsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MessagesSentRecordsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[messagessentrecords.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MessagesSentRecordsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[messagessentrecords.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessagesSentRecordsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, messagessentrecords.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *MessagesSentRecordsMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *MessagesSentRecordsMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the MessagesSentRecords entity.
// If the MessagesSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesSentRecordsMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *MessagesSentRecordsMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *MessagesSentRecordsMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *MessagesSentRecordsMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[messagessentrecords.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *MessagesSentRecordsMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[messagessentrecords.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *MessagesSentRecordsMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, messagessentrecords.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *MessagesSentRecordsMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *MessagesSentRecordsMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the MessagesSentRecords entity.
// If the MessagesSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesSentRecordsMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *MessagesSentRecordsMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *MessagesSentRecordsMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *MessagesSentRecordsMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[messagessentrecords.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *MessagesSentRecordsMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[messagessentrecords.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *MessagesSentRecordsMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, messagessentrecords.FieldCreatedID)
}

// SetMessageID sets the "message_id" field.
func (m *MessagesSentRecordsMutation) SetMessageID(i int64) {
	m.message_id = &i
	m.addmessage_id = nil
}

// MessageID returns the value of the "message_id" field in the mutation.
func (m *MessagesSentRecordsMutation) MessageID() (r int64, exists bool) {
	v := m.message_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageID returns the old "message_id" field's value of the MessagesSentRecords entity.
// If the MessagesSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesSentRecordsMutation) OldMessageID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageID: %w", err)
	}
	return oldValue.MessageID, nil
}

// AddMessageID adds i to the "message_id" field.
func (m *MessagesSentRecordsMutation) AddMessageID(i int64) {
	if m.addmessage_id != nil {
		*m.addmessage_id += i
	} else {
		m.addmessage_id = &i
	}
}

// AddedMessageID returns the value that was added to the "message_id" field in this mutation.
func (m *MessagesSentRecordsMutation) AddedMessageID() (r int64, exists bool) {
	v := m.addmessage_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMessageID clears the value of the "message_id" field.
func (m *MessagesSentRecordsMutation) ClearMessageID() {
	m.message_id = nil
	m.addmessage_id = nil
	m.clearedFields[messagessentrecords.FieldMessageID] = struct{}{}
}

// MessageIDCleared returns if the "message_id" field was cleared in this mutation.
func (m *MessagesSentRecordsMutation) MessageIDCleared() bool {
	_, ok := m.clearedFields[messagessentrecords.FieldMessageID]
	return ok
}

// ResetMessageID resets all changes to the "message_id" field.
func (m *MessagesSentRecordsMutation) ResetMessageID() {
	m.message_id = nil
	m.addmessage_id = nil
	delete(m.clearedFields, messagessentrecords.FieldMessageID)
}

// SetToUserID sets the "to_user_id" field.
func (m *MessagesSentRecordsMutation) SetToUserID(i int64) {
	m.to_user_id = &i
	m.addto_user_id = nil
}

// ToUserID returns the value of the "to_user_id" field in the mutation.
func (m *MessagesSentRecordsMutation) ToUserID() (r int64, exists bool) {
	v := m.to_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldToUserID returns the old "to_user_id" field's value of the MessagesSentRecords entity.
// If the MessagesSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesSentRecordsMutation) OldToUserID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToUserID: %w", err)
	}
	return oldValue.ToUserID, nil
}

// AddToUserID adds i to the "to_user_id" field.
func (m *MessagesSentRecordsMutation) AddToUserID(i int64) {
	if m.addto_user_id != nil {
		*m.addto_user_id += i
	} else {
		m.addto_user_id = &i
	}
}

// AddedToUserID returns the value that was added to the "to_user_id" field in this mutation.
func (m *MessagesSentRecordsMutation) AddedToUserID() (r int64, exists bool) {
	v := m.addto_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearToUserID clears the value of the "to_user_id" field.
func (m *MessagesSentRecordsMutation) ClearToUserID() {
	m.to_user_id = nil
	m.addto_user_id = nil
	m.clearedFields[messagessentrecords.FieldToUserID] = struct{}{}
}

// ToUserIDCleared returns if the "to_user_id" field was cleared in this mutation.
func (m *MessagesSentRecordsMutation) ToUserIDCleared() bool {
	_, ok := m.clearedFields[messagessentrecords.FieldToUserID]
	return ok
}

// ResetToUserID resets all changes to the "to_user_id" field.
func (m *MessagesSentRecordsMutation) ResetToUserID() {
	m.to_user_id = nil
	m.addto_user_id = nil
	delete(m.clearedFields, messagessentrecords.FieldToUserID)
}

// SetStatus sets the "status" field.
func (m *MessagesSentRecordsMutation) SetStatus(value messagessentrecords.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MessagesSentRecordsMutation) Status() (r messagessentrecords.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MessagesSentRecords entity.
// If the MessagesSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesSentRecordsMutation) OldStatus(ctx context.Context) (v *messagessentrecords.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *MessagesSentRecordsMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[messagessentrecords.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MessagesSentRecordsMutation) StatusCleared() bool {
	_, ok := m.clearedFields[messagessentrecords.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MessagesSentRecordsMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, messagessentrecords.FieldStatus)
}

// SetReceivedAt sets the "received_at" field.
func (m *MessagesSentRecordsMutation) SetReceivedAt(t time.Time) {
	m.received_at = &t
}

// ReceivedAt returns the value of the "received_at" field in the mutation.
func (m *MessagesSentRecordsMutation) ReceivedAt() (r time.Time, exists bool) {
	v := m.received_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivedAt returns the old "received_at" field's value of the MessagesSentRecords entity.
// If the MessagesSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesSentRecordsMutation) OldReceivedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivedAt: %w", err)
	}
	return oldValue.ReceivedAt, nil
}

// ClearReceivedAt clears the value of the "received_at" field.
func (m *MessagesSentRecordsMutation) ClearReceivedAt() {
	m.received_at = nil
	m.clearedFields[messagessentrecords.FieldReceivedAt] = struct{}{}
}

// ReceivedAtCleared returns if the "received_at" field was cleared in this mutation.
func (m *MessagesSentRecordsMutation) ReceivedAtCleared() bool {
	_, ok := m.clearedFields[messagessentrecords.FieldReceivedAt]
	return ok
}

// ResetReceivedAt resets all changes to the "received_at" field.
func (m *MessagesSentRecordsMutation) ResetReceivedAt() {
	m.received_at = nil
	delete(m.clearedFields, messagessentrecords.FieldReceivedAt)
}

// SetReadAt sets the "read_at" field.
func (m *MessagesSentRecordsMutation) SetReadAt(t time.Time) {
	m.read_at = &t
}

// ReadAt returns the value of the "read_at" field in the mutation.
func (m *MessagesSentRecordsMutation) ReadAt() (r time.Time, exists bool) {
	v := m.read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReadAt returns the old "read_at" field's value of the MessagesSentRecords entity.
// If the MessagesSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessagesSentRecordsMutation) OldReadAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadAt: %w", err)
	}
	return oldValue.ReadAt, nil
}

// ClearReadAt clears the value of the "read_at" field.
func (m *MessagesSentRecordsMutation) ClearReadAt() {
	m.read_at = nil
	m.clearedFields[messagessentrecords.FieldReadAt] = struct{}{}
}

// ReadAtCleared returns if the "read_at" field was cleared in this mutation.
func (m *MessagesSentRecordsMutation) ReadAtCleared() bool {
	_, ok := m.clearedFields[messagessentrecords.FieldReadAt]
	return ok
}

// ResetReadAt resets all changes to the "read_at" field.
func (m *MessagesSentRecordsMutation) ResetReadAt() {
	m.read_at = nil
	delete(m.clearedFields, messagessentrecords.FieldReadAt)
}

// Where appends a list predicates to the MessagesSentRecordsMutation builder.
func (m *MessagesSentRecordsMutation) Where(ps ...predicate.MessagesSentRecords) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessagesSentRecordsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessagesSentRecordsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MessagesSentRecords, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessagesSentRecordsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessagesSentRecordsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MessagesSentRecords).
func (m *MessagesSentRecordsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessagesSentRecordsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, messagessentrecords.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, messagessentrecords.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, messagessentrecords.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, messagessentrecords.FieldCreatedID)
	}
	if m.message_id != nil {
		fields = append(fields, messagessentrecords.FieldMessageID)
	}
	if m.to_user_id != nil {
		fields = append(fields, messagessentrecords.FieldToUserID)
	}
	if m.status != nil {
		fields = append(fields, messagessentrecords.FieldStatus)
	}
	if m.received_at != nil {
		fields = append(fields, messagessentrecords.FieldReceivedAt)
	}
	if m.read_at != nil {
		fields = append(fields, messagessentrecords.FieldReadAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessagesSentRecordsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messagessentrecords.FieldCreatedAt:
		return m.CreatedAt()
	case messagessentrecords.FieldUpdatedAt:
		return m.UpdatedAt()
	case messagessentrecords.FieldDelete:
		return m.Delete()
	case messagessentrecords.FieldCreatedID:
		return m.CreatedID()
	case messagessentrecords.FieldMessageID:
		return m.MessageID()
	case messagessentrecords.FieldToUserID:
		return m.ToUserID()
	case messagessentrecords.FieldStatus:
		return m.Status()
	case messagessentrecords.FieldReceivedAt:
		return m.ReceivedAt()
	case messagessentrecords.FieldReadAt:
		return m.ReadAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessagesSentRecordsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messagessentrecords.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case messagessentrecords.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case messagessentrecords.FieldDelete:
		return m.OldDelete(ctx)
	case messagessentrecords.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case messagessentrecords.FieldMessageID:
		return m.OldMessageID(ctx)
	case messagessentrecords.FieldToUserID:
		return m.OldToUserID(ctx)
	case messagessentrecords.FieldStatus:
		return m.OldStatus(ctx)
	case messagessentrecords.FieldReceivedAt:
		return m.OldReceivedAt(ctx)
	case messagessentrecords.FieldReadAt:
		return m.OldReadAt(ctx)
	}
	return nil, fmt.Errorf("unknown MessagesSentRecords field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesSentRecordsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messagessentrecords.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case messagessentrecords.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case messagessentrecords.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case messagessentrecords.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case messagessentrecords.FieldMessageID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageID(v)
		return nil
	case messagessentrecords.FieldToUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToUserID(v)
		return nil
	case messagessentrecords.FieldStatus:
		v, ok := value.(messagessentrecords.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case messagessentrecords.FieldReceivedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivedAt(v)
		return nil
	case messagessentrecords.FieldReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadAt(v)
		return nil
	}
	return fmt.Errorf("unknown MessagesSentRecords field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessagesSentRecordsMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, messagessentrecords.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, messagessentrecords.FieldCreatedID)
	}
	if m.addmessage_id != nil {
		fields = append(fields, messagessentrecords.FieldMessageID)
	}
	if m.addto_user_id != nil {
		fields = append(fields, messagessentrecords.FieldToUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessagesSentRecordsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case messagessentrecords.FieldDelete:
		return m.AddedDelete()
	case messagessentrecords.FieldCreatedID:
		return m.AddedCreatedID()
	case messagessentrecords.FieldMessageID:
		return m.AddedMessageID()
	case messagessentrecords.FieldToUserID:
		return m.AddedToUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessagesSentRecordsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case messagessentrecords.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case messagessentrecords.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case messagessentrecords.FieldMessageID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMessageID(v)
		return nil
	case messagessentrecords.FieldToUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToUserID(v)
		return nil
	}
	return fmt.Errorf("unknown MessagesSentRecords numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessagesSentRecordsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(messagessentrecords.FieldCreatedAt) {
		fields = append(fields, messagessentrecords.FieldCreatedAt)
	}
	if m.FieldCleared(messagessentrecords.FieldUpdatedAt) {
		fields = append(fields, messagessentrecords.FieldUpdatedAt)
	}
	if m.FieldCleared(messagessentrecords.FieldDelete) {
		fields = append(fields, messagessentrecords.FieldDelete)
	}
	if m.FieldCleared(messagessentrecords.FieldCreatedID) {
		fields = append(fields, messagessentrecords.FieldCreatedID)
	}
	if m.FieldCleared(messagessentrecords.FieldMessageID) {
		fields = append(fields, messagessentrecords.FieldMessageID)
	}
	if m.FieldCleared(messagessentrecords.FieldToUserID) {
		fields = append(fields, messagessentrecords.FieldToUserID)
	}
	if m.FieldCleared(messagessentrecords.FieldStatus) {
		fields = append(fields, messagessentrecords.FieldStatus)
	}
	if m.FieldCleared(messagessentrecords.FieldReceivedAt) {
		fields = append(fields, messagessentrecords.FieldReceivedAt)
	}
	if m.FieldCleared(messagessentrecords.FieldReadAt) {
		fields = append(fields, messagessentrecords.FieldReadAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessagesSentRecordsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessagesSentRecordsMutation) ClearField(name string) error {
	switch name {
	case messagessentrecords.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case messagessentrecords.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case messagessentrecords.FieldDelete:
		m.ClearDelete()
		return nil
	case messagessentrecords.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case messagessentrecords.FieldMessageID:
		m.ClearMessageID()
		return nil
	case messagessentrecords.FieldToUserID:
		m.ClearToUserID()
		return nil
	case messagessentrecords.FieldStatus:
		m.ClearStatus()
		return nil
	case messagessentrecords.FieldReceivedAt:
		m.ClearReceivedAt()
		return nil
	case messagessentrecords.FieldReadAt:
		m.ClearReadAt()
		return nil
	}
	return fmt.Errorf("unknown MessagesSentRecords nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessagesSentRecordsMutation) ResetField(name string) error {
	switch name {
	case messagessentrecords.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case messagessentrecords.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case messagessentrecords.FieldDelete:
		m.ResetDelete()
		return nil
	case messagessentrecords.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case messagessentrecords.FieldMessageID:
		m.ResetMessageID()
		return nil
	case messagessentrecords.FieldToUserID:
		m.ResetToUserID()
		return nil
	case messagessentrecords.FieldStatus:
		m.ResetStatus()
		return nil
	case messagessentrecords.FieldReceivedAt:
		m.ResetReceivedAt()
		return nil
	case messagessentrecords.FieldReadAt:
		m.ResetReadAt()
		return nil
	}
	return fmt.Errorf("unknown MessagesSentRecords field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessagesSentRecordsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessagesSentRecordsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessagesSentRecordsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessagesSentRecordsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessagesSentRecordsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessagesSentRecordsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessagesSentRecordsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MessagesSentRecords unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessagesSentRecordsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MessagesSentRecords edge %s", name)
}

// SmsMutation represents an operation that mutates the Sms nodes in the graph.
type SmsMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	delete          *int64
	adddelete       *int64
	created_id      *int64
	addcreated_id   *int64
	status          *int64
	addstatus       *int64
	notice_count    *int64
	addnotice_count *int64
	used_notice     *int64
	addused_notice  *int64
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Sms, error)
	predicates      []predicate.Sms
}

var _ ent.Mutation = (*SmsMutation)(nil)

// smsOption allows management of the mutation configuration using functional options.
type smsOption func(*SmsMutation)

// newSmsMutation creates new mutation for the Sms entity.
func newSmsMutation(c config, op Op, opts ...smsOption) *SmsMutation {
	m := &SmsMutation{
		config:        c,
		op:            op,
		typ:           TypeSms,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSmsID sets the ID field of the mutation.
func withSmsID(id int64) smsOption {
	return func(m *SmsMutation) {
		var (
			err   error
			once  sync.Once
			value *Sms
		)
		m.oldValue = func(ctx context.Context) (*Sms, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Sms.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSms sets the old Sms of the mutation.
func withSms(node *Sms) smsOption {
	return func(m *SmsMutation) {
		m.oldValue = func(context.Context) (*Sms, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SmsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SmsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Sms entities.
func (m *SmsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SmsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SmsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Sms.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SmsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SmsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Sms entity.
// If the Sms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SmsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[sms.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SmsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[sms.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SmsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, sms.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SmsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SmsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Sms entity.
// If the Sms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SmsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[sms.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SmsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[sms.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SmsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, sms.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *SmsMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *SmsMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the Sms entity.
// If the Sms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *SmsMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *SmsMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *SmsMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[sms.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *SmsMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[sms.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *SmsMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, sms.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *SmsMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *SmsMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the Sms entity.
// If the Sms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *SmsMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *SmsMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *SmsMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[sms.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *SmsMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[sms.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *SmsMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, sms.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *SmsMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SmsMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Sms entity.
// If the Sms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SmsMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SmsMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *SmsMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[sms.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *SmsMutation) StatusCleared() bool {
	_, ok := m.clearedFields[sms.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *SmsMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, sms.FieldStatus)
}

// SetNoticeCount sets the "notice_count" field.
func (m *SmsMutation) SetNoticeCount(i int64) {
	m.notice_count = &i
	m.addnotice_count = nil
}

// NoticeCount returns the value of the "notice_count" field in the mutation.
func (m *SmsMutation) NoticeCount() (r int64, exists bool) {
	v := m.notice_count
	if v == nil {
		return
	}
	return *v, true
}

// OldNoticeCount returns the old "notice_count" field's value of the Sms entity.
// If the Sms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsMutation) OldNoticeCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoticeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoticeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoticeCount: %w", err)
	}
	return oldValue.NoticeCount, nil
}

// AddNoticeCount adds i to the "notice_count" field.
func (m *SmsMutation) AddNoticeCount(i int64) {
	if m.addnotice_count != nil {
		*m.addnotice_count += i
	} else {
		m.addnotice_count = &i
	}
}

// AddedNoticeCount returns the value that was added to the "notice_count" field in this mutation.
func (m *SmsMutation) AddedNoticeCount() (r int64, exists bool) {
	v := m.addnotice_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearNoticeCount clears the value of the "notice_count" field.
func (m *SmsMutation) ClearNoticeCount() {
	m.notice_count = nil
	m.addnotice_count = nil
	m.clearedFields[sms.FieldNoticeCount] = struct{}{}
}

// NoticeCountCleared returns if the "notice_count" field was cleared in this mutation.
func (m *SmsMutation) NoticeCountCleared() bool {
	_, ok := m.clearedFields[sms.FieldNoticeCount]
	return ok
}

// ResetNoticeCount resets all changes to the "notice_count" field.
func (m *SmsMutation) ResetNoticeCount() {
	m.notice_count = nil
	m.addnotice_count = nil
	delete(m.clearedFields, sms.FieldNoticeCount)
}

// SetUsedNotice sets the "used_notice" field.
func (m *SmsMutation) SetUsedNotice(i int64) {
	m.used_notice = &i
	m.addused_notice = nil
}

// UsedNotice returns the value of the "used_notice" field in the mutation.
func (m *SmsMutation) UsedNotice() (r int64, exists bool) {
	v := m.used_notice
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedNotice returns the old "used_notice" field's value of the Sms entity.
// If the Sms object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsMutation) OldUsedNotice(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedNotice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedNotice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedNotice: %w", err)
	}
	return oldValue.UsedNotice, nil
}

// AddUsedNotice adds i to the "used_notice" field.
func (m *SmsMutation) AddUsedNotice(i int64) {
	if m.addused_notice != nil {
		*m.addused_notice += i
	} else {
		m.addused_notice = &i
	}
}

// AddedUsedNotice returns the value that was added to the "used_notice" field in this mutation.
func (m *SmsMutation) AddedUsedNotice() (r int64, exists bool) {
	v := m.addused_notice
	if v == nil {
		return
	}
	return *v, true
}

// ClearUsedNotice clears the value of the "used_notice" field.
func (m *SmsMutation) ClearUsedNotice() {
	m.used_notice = nil
	m.addused_notice = nil
	m.clearedFields[sms.FieldUsedNotice] = struct{}{}
}

// UsedNoticeCleared returns if the "used_notice" field was cleared in this mutation.
func (m *SmsMutation) UsedNoticeCleared() bool {
	_, ok := m.clearedFields[sms.FieldUsedNotice]
	return ok
}

// ResetUsedNotice resets all changes to the "used_notice" field.
func (m *SmsMutation) ResetUsedNotice() {
	m.used_notice = nil
	m.addused_notice = nil
	delete(m.clearedFields, sms.FieldUsedNotice)
}

// Where appends a list predicates to the SmsMutation builder.
func (m *SmsMutation) Where(ps ...predicate.Sms) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SmsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SmsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Sms, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SmsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SmsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Sms).
func (m *SmsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SmsMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, sms.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sms.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, sms.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, sms.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, sms.FieldStatus)
	}
	if m.notice_count != nil {
		fields = append(fields, sms.FieldNoticeCount)
	}
	if m.used_notice != nil {
		fields = append(fields, sms.FieldUsedNotice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SmsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sms.FieldCreatedAt:
		return m.CreatedAt()
	case sms.FieldUpdatedAt:
		return m.UpdatedAt()
	case sms.FieldDelete:
		return m.Delete()
	case sms.FieldCreatedID:
		return m.CreatedID()
	case sms.FieldStatus:
		return m.Status()
	case sms.FieldNoticeCount:
		return m.NoticeCount()
	case sms.FieldUsedNotice:
		return m.UsedNotice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SmsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sms.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sms.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sms.FieldDelete:
		return m.OldDelete(ctx)
	case sms.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case sms.FieldStatus:
		return m.OldStatus(ctx)
	case sms.FieldNoticeCount:
		return m.OldNoticeCount(ctx)
	case sms.FieldUsedNotice:
		return m.OldUsedNotice(ctx)
	}
	return nil, fmt.Errorf("unknown Sms field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SmsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sms.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sms.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sms.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case sms.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case sms.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sms.FieldNoticeCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoticeCount(v)
		return nil
	case sms.FieldUsedNotice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedNotice(v)
		return nil
	}
	return fmt.Errorf("unknown Sms field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SmsMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, sms.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, sms.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, sms.FieldStatus)
	}
	if m.addnotice_count != nil {
		fields = append(fields, sms.FieldNoticeCount)
	}
	if m.addused_notice != nil {
		fields = append(fields, sms.FieldUsedNotice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SmsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sms.FieldDelete:
		return m.AddedDelete()
	case sms.FieldCreatedID:
		return m.AddedCreatedID()
	case sms.FieldStatus:
		return m.AddedStatus()
	case sms.FieldNoticeCount:
		return m.AddedNoticeCount()
	case sms.FieldUsedNotice:
		return m.AddedUsedNotice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SmsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sms.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case sms.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case sms.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case sms.FieldNoticeCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNoticeCount(v)
		return nil
	case sms.FieldUsedNotice:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedNotice(v)
		return nil
	}
	return fmt.Errorf("unknown Sms numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SmsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sms.FieldCreatedAt) {
		fields = append(fields, sms.FieldCreatedAt)
	}
	if m.FieldCleared(sms.FieldUpdatedAt) {
		fields = append(fields, sms.FieldUpdatedAt)
	}
	if m.FieldCleared(sms.FieldDelete) {
		fields = append(fields, sms.FieldDelete)
	}
	if m.FieldCleared(sms.FieldCreatedID) {
		fields = append(fields, sms.FieldCreatedID)
	}
	if m.FieldCleared(sms.FieldStatus) {
		fields = append(fields, sms.FieldStatus)
	}
	if m.FieldCleared(sms.FieldNoticeCount) {
		fields = append(fields, sms.FieldNoticeCount)
	}
	if m.FieldCleared(sms.FieldUsedNotice) {
		fields = append(fields, sms.FieldUsedNotice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SmsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SmsMutation) ClearField(name string) error {
	switch name {
	case sms.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case sms.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case sms.FieldDelete:
		m.ClearDelete()
		return nil
	case sms.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case sms.FieldStatus:
		m.ClearStatus()
		return nil
	case sms.FieldNoticeCount:
		m.ClearNoticeCount()
		return nil
	case sms.FieldUsedNotice:
		m.ClearUsedNotice()
		return nil
	}
	return fmt.Errorf("unknown Sms nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SmsMutation) ResetField(name string) error {
	switch name {
	case sms.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sms.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sms.FieldDelete:
		m.ResetDelete()
		return nil
	case sms.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case sms.FieldStatus:
		m.ResetStatus()
		return nil
	case sms.FieldNoticeCount:
		m.ResetNoticeCount()
		return nil
	case sms.FieldUsedNotice:
		m.ResetUsedNotice()
		return nil
	}
	return fmt.Errorf("unknown Sms field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SmsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SmsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SmsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SmsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SmsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SmsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SmsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Sms unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SmsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Sms edge %s", name)
}

// SmsSentRecordsMutation represents an operation that mutates the SmsSentRecords nodes in the graph.
type SmsSentRecordsMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	delete         *int64
	adddelete      *int64
	created_id     *int64
	addcreated_id  *int64
	status         *int64
	addstatus      *int64
	mobile         *string
	biz_id         *string
	code           *string
	content        *string
	notify_type    *int64
	addnotify_type *int64
	template       *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*SmsSentRecords, error)
	predicates     []predicate.SmsSentRecords
}

var _ ent.Mutation = (*SmsSentRecordsMutation)(nil)

// smssentrecordsOption allows management of the mutation configuration using functional options.
type smssentrecordsOption func(*SmsSentRecordsMutation)

// newSmsSentRecordsMutation creates new mutation for the SmsSentRecords entity.
func newSmsSentRecordsMutation(c config, op Op, opts ...smssentrecordsOption) *SmsSentRecordsMutation {
	m := &SmsSentRecordsMutation{
		config:        c,
		op:            op,
		typ:           TypeSmsSentRecords,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSmsSentRecordsID sets the ID field of the mutation.
func withSmsSentRecordsID(id int64) smssentrecordsOption {
	return func(m *SmsSentRecordsMutation) {
		var (
			err   error
			once  sync.Once
			value *SmsSentRecords
		)
		m.oldValue = func(ctx context.Context) (*SmsSentRecords, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SmsSentRecords.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSmsSentRecords sets the old SmsSentRecords of the mutation.
func withSmsSentRecords(node *SmsSentRecords) smssentrecordsOption {
	return func(m *SmsSentRecordsMutation) {
		m.oldValue = func(context.Context) (*SmsSentRecords, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SmsSentRecordsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SmsSentRecordsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SmsSentRecords entities.
func (m *SmsSentRecordsMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SmsSentRecordsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SmsSentRecordsMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SmsSentRecords.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SmsSentRecordsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SmsSentRecordsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SmsSentRecords entity.
// If the SmsSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsSentRecordsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SmsSentRecordsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[smssentrecords.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SmsSentRecordsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[smssentrecords.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SmsSentRecordsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, smssentrecords.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SmsSentRecordsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SmsSentRecordsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SmsSentRecords entity.
// If the SmsSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsSentRecordsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SmsSentRecordsMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[smssentrecords.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SmsSentRecordsMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[smssentrecords.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SmsSentRecordsMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, smssentrecords.FieldUpdatedAt)
}

// SetDelete sets the "delete" field.
func (m *SmsSentRecordsMutation) SetDelete(i int64) {
	m.delete = &i
	m.adddelete = nil
}

// Delete returns the value of the "delete" field in the mutation.
func (m *SmsSentRecordsMutation) Delete() (r int64, exists bool) {
	v := m.delete
	if v == nil {
		return
	}
	return *v, true
}

// OldDelete returns the old "delete" field's value of the SmsSentRecords entity.
// If the SmsSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsSentRecordsMutation) OldDelete(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDelete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDelete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelete: %w", err)
	}
	return oldValue.Delete, nil
}

// AddDelete adds i to the "delete" field.
func (m *SmsSentRecordsMutation) AddDelete(i int64) {
	if m.adddelete != nil {
		*m.adddelete += i
	} else {
		m.adddelete = &i
	}
}

// AddedDelete returns the value that was added to the "delete" field in this mutation.
func (m *SmsSentRecordsMutation) AddedDelete() (r int64, exists bool) {
	v := m.adddelete
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelete clears the value of the "delete" field.
func (m *SmsSentRecordsMutation) ClearDelete() {
	m.delete = nil
	m.adddelete = nil
	m.clearedFields[smssentrecords.FieldDelete] = struct{}{}
}

// DeleteCleared returns if the "delete" field was cleared in this mutation.
func (m *SmsSentRecordsMutation) DeleteCleared() bool {
	_, ok := m.clearedFields[smssentrecords.FieldDelete]
	return ok
}

// ResetDelete resets all changes to the "delete" field.
func (m *SmsSentRecordsMutation) ResetDelete() {
	m.delete = nil
	m.adddelete = nil
	delete(m.clearedFields, smssentrecords.FieldDelete)
}

// SetCreatedID sets the "created_id" field.
func (m *SmsSentRecordsMutation) SetCreatedID(i int64) {
	m.created_id = &i
	m.addcreated_id = nil
}

// CreatedID returns the value of the "created_id" field in the mutation.
func (m *SmsSentRecordsMutation) CreatedID() (r int64, exists bool) {
	v := m.created_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedID returns the old "created_id" field's value of the SmsSentRecords entity.
// If the SmsSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsSentRecordsMutation) OldCreatedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedID: %w", err)
	}
	return oldValue.CreatedID, nil
}

// AddCreatedID adds i to the "created_id" field.
func (m *SmsSentRecordsMutation) AddCreatedID(i int64) {
	if m.addcreated_id != nil {
		*m.addcreated_id += i
	} else {
		m.addcreated_id = &i
	}
}

// AddedCreatedID returns the value that was added to the "created_id" field in this mutation.
func (m *SmsSentRecordsMutation) AddedCreatedID() (r int64, exists bool) {
	v := m.addcreated_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedID clears the value of the "created_id" field.
func (m *SmsSentRecordsMutation) ClearCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	m.clearedFields[smssentrecords.FieldCreatedID] = struct{}{}
}

// CreatedIDCleared returns if the "created_id" field was cleared in this mutation.
func (m *SmsSentRecordsMutation) CreatedIDCleared() bool {
	_, ok := m.clearedFields[smssentrecords.FieldCreatedID]
	return ok
}

// ResetCreatedID resets all changes to the "created_id" field.
func (m *SmsSentRecordsMutation) ResetCreatedID() {
	m.created_id = nil
	m.addcreated_id = nil
	delete(m.clearedFields, smssentrecords.FieldCreatedID)
}

// SetStatus sets the "status" field.
func (m *SmsSentRecordsMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SmsSentRecordsMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SmsSentRecords entity.
// If the SmsSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsSentRecordsMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SmsSentRecordsMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SmsSentRecordsMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatus clears the value of the "status" field.
func (m *SmsSentRecordsMutation) ClearStatus() {
	m.status = nil
	m.addstatus = nil
	m.clearedFields[smssentrecords.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *SmsSentRecordsMutation) StatusCleared() bool {
	_, ok := m.clearedFields[smssentrecords.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *SmsSentRecordsMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
	delete(m.clearedFields, smssentrecords.FieldStatus)
}

// SetMobile sets the "mobile" field.
func (m *SmsSentRecordsMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *SmsSentRecordsMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the SmsSentRecords entity.
// If the SmsSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsSentRecordsMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *SmsSentRecordsMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[smssentrecords.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *SmsSentRecordsMutation) MobileCleared() bool {
	_, ok := m.clearedFields[smssentrecords.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *SmsSentRecordsMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, smssentrecords.FieldMobile)
}

// SetBizID sets the "biz_id" field.
func (m *SmsSentRecordsMutation) SetBizID(s string) {
	m.biz_id = &s
}

// BizID returns the value of the "biz_id" field in the mutation.
func (m *SmsSentRecordsMutation) BizID() (r string, exists bool) {
	v := m.biz_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBizID returns the old "biz_id" field's value of the SmsSentRecords entity.
// If the SmsSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsSentRecordsMutation) OldBizID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizID: %w", err)
	}
	return oldValue.BizID, nil
}

// ClearBizID clears the value of the "biz_id" field.
func (m *SmsSentRecordsMutation) ClearBizID() {
	m.biz_id = nil
	m.clearedFields[smssentrecords.FieldBizID] = struct{}{}
}

// BizIDCleared returns if the "biz_id" field was cleared in this mutation.
func (m *SmsSentRecordsMutation) BizIDCleared() bool {
	_, ok := m.clearedFields[smssentrecords.FieldBizID]
	return ok
}

// ResetBizID resets all changes to the "biz_id" field.
func (m *SmsSentRecordsMutation) ResetBizID() {
	m.biz_id = nil
	delete(m.clearedFields, smssentrecords.FieldBizID)
}

// SetCode sets the "code" field.
func (m *SmsSentRecordsMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *SmsSentRecordsMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the SmsSentRecords entity.
// If the SmsSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsSentRecordsMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *SmsSentRecordsMutation) ClearCode() {
	m.code = nil
	m.clearedFields[smssentrecords.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *SmsSentRecordsMutation) CodeCleared() bool {
	_, ok := m.clearedFields[smssentrecords.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *SmsSentRecordsMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, smssentrecords.FieldCode)
}

// SetContent sets the "content" field.
func (m *SmsSentRecordsMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *SmsSentRecordsMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the SmsSentRecords entity.
// If the SmsSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsSentRecordsMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *SmsSentRecordsMutation) ClearContent() {
	m.content = nil
	m.clearedFields[smssentrecords.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *SmsSentRecordsMutation) ContentCleared() bool {
	_, ok := m.clearedFields[smssentrecords.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *SmsSentRecordsMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, smssentrecords.FieldContent)
}

// SetNotifyType sets the "notify_type" field.
func (m *SmsSentRecordsMutation) SetNotifyType(i int64) {
	m.notify_type = &i
	m.addnotify_type = nil
}

// NotifyType returns the value of the "notify_type" field in the mutation.
func (m *SmsSentRecordsMutation) NotifyType() (r int64, exists bool) {
	v := m.notify_type
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyType returns the old "notify_type" field's value of the SmsSentRecords entity.
// If the SmsSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsSentRecordsMutation) OldNotifyType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyType: %w", err)
	}
	return oldValue.NotifyType, nil
}

// AddNotifyType adds i to the "notify_type" field.
func (m *SmsSentRecordsMutation) AddNotifyType(i int64) {
	if m.addnotify_type != nil {
		*m.addnotify_type += i
	} else {
		m.addnotify_type = &i
	}
}

// AddedNotifyType returns the value that was added to the "notify_type" field in this mutation.
func (m *SmsSentRecordsMutation) AddedNotifyType() (r int64, exists bool) {
	v := m.addnotify_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearNotifyType clears the value of the "notify_type" field.
func (m *SmsSentRecordsMutation) ClearNotifyType() {
	m.notify_type = nil
	m.addnotify_type = nil
	m.clearedFields[smssentrecords.FieldNotifyType] = struct{}{}
}

// NotifyTypeCleared returns if the "notify_type" field was cleared in this mutation.
func (m *SmsSentRecordsMutation) NotifyTypeCleared() bool {
	_, ok := m.clearedFields[smssentrecords.FieldNotifyType]
	return ok
}

// ResetNotifyType resets all changes to the "notify_type" field.
func (m *SmsSentRecordsMutation) ResetNotifyType() {
	m.notify_type = nil
	m.addnotify_type = nil
	delete(m.clearedFields, smssentrecords.FieldNotifyType)
}

// SetTemplate sets the "template" field.
func (m *SmsSentRecordsMutation) SetTemplate(s string) {
	m.template = &s
}

// Template returns the value of the "template" field in the mutation.
func (m *SmsSentRecordsMutation) Template() (r string, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old "template" field's value of the SmsSentRecords entity.
// If the SmsSentRecords object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsSentRecordsMutation) OldTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ClearTemplate clears the value of the "template" field.
func (m *SmsSentRecordsMutation) ClearTemplate() {
	m.template = nil
	m.clearedFields[smssentrecords.FieldTemplate] = struct{}{}
}

// TemplateCleared returns if the "template" field was cleared in this mutation.
func (m *SmsSentRecordsMutation) TemplateCleared() bool {
	_, ok := m.clearedFields[smssentrecords.FieldTemplate]
	return ok
}

// ResetTemplate resets all changes to the "template" field.
func (m *SmsSentRecordsMutation) ResetTemplate() {
	m.template = nil
	delete(m.clearedFields, smssentrecords.FieldTemplate)
}

// Where appends a list predicates to the SmsSentRecordsMutation builder.
func (m *SmsSentRecordsMutation) Where(ps ...predicate.SmsSentRecords) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SmsSentRecordsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SmsSentRecordsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SmsSentRecords, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SmsSentRecordsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SmsSentRecordsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SmsSentRecords).
func (m *SmsSentRecordsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SmsSentRecordsMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, smssentrecords.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, smssentrecords.FieldUpdatedAt)
	}
	if m.delete != nil {
		fields = append(fields, smssentrecords.FieldDelete)
	}
	if m.created_id != nil {
		fields = append(fields, smssentrecords.FieldCreatedID)
	}
	if m.status != nil {
		fields = append(fields, smssentrecords.FieldStatus)
	}
	if m.mobile != nil {
		fields = append(fields, smssentrecords.FieldMobile)
	}
	if m.biz_id != nil {
		fields = append(fields, smssentrecords.FieldBizID)
	}
	if m.code != nil {
		fields = append(fields, smssentrecords.FieldCode)
	}
	if m.content != nil {
		fields = append(fields, smssentrecords.FieldContent)
	}
	if m.notify_type != nil {
		fields = append(fields, smssentrecords.FieldNotifyType)
	}
	if m.template != nil {
		fields = append(fields, smssentrecords.FieldTemplate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SmsSentRecordsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case smssentrecords.FieldCreatedAt:
		return m.CreatedAt()
	case smssentrecords.FieldUpdatedAt:
		return m.UpdatedAt()
	case smssentrecords.FieldDelete:
		return m.Delete()
	case smssentrecords.FieldCreatedID:
		return m.CreatedID()
	case smssentrecords.FieldStatus:
		return m.Status()
	case smssentrecords.FieldMobile:
		return m.Mobile()
	case smssentrecords.FieldBizID:
		return m.BizID()
	case smssentrecords.FieldCode:
		return m.Code()
	case smssentrecords.FieldContent:
		return m.Content()
	case smssentrecords.FieldNotifyType:
		return m.NotifyType()
	case smssentrecords.FieldTemplate:
		return m.Template()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SmsSentRecordsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case smssentrecords.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case smssentrecords.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case smssentrecords.FieldDelete:
		return m.OldDelete(ctx)
	case smssentrecords.FieldCreatedID:
		return m.OldCreatedID(ctx)
	case smssentrecords.FieldStatus:
		return m.OldStatus(ctx)
	case smssentrecords.FieldMobile:
		return m.OldMobile(ctx)
	case smssentrecords.FieldBizID:
		return m.OldBizID(ctx)
	case smssentrecords.FieldCode:
		return m.OldCode(ctx)
	case smssentrecords.FieldContent:
		return m.OldContent(ctx)
	case smssentrecords.FieldNotifyType:
		return m.OldNotifyType(ctx)
	case smssentrecords.FieldTemplate:
		return m.OldTemplate(ctx)
	}
	return nil, fmt.Errorf("unknown SmsSentRecords field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SmsSentRecordsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case smssentrecords.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case smssentrecords.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case smssentrecords.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelete(v)
		return nil
	case smssentrecords.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedID(v)
		return nil
	case smssentrecords.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case smssentrecords.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case smssentrecords.FieldBizID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizID(v)
		return nil
	case smssentrecords.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case smssentrecords.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case smssentrecords.FieldNotifyType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyType(v)
		return nil
	case smssentrecords.FieldTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	}
	return fmt.Errorf("unknown SmsSentRecords field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SmsSentRecordsMutation) AddedFields() []string {
	var fields []string
	if m.adddelete != nil {
		fields = append(fields, smssentrecords.FieldDelete)
	}
	if m.addcreated_id != nil {
		fields = append(fields, smssentrecords.FieldCreatedID)
	}
	if m.addstatus != nil {
		fields = append(fields, smssentrecords.FieldStatus)
	}
	if m.addnotify_type != nil {
		fields = append(fields, smssentrecords.FieldNotifyType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SmsSentRecordsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case smssentrecords.FieldDelete:
		return m.AddedDelete()
	case smssentrecords.FieldCreatedID:
		return m.AddedCreatedID()
	case smssentrecords.FieldStatus:
		return m.AddedStatus()
	case smssentrecords.FieldNotifyType:
		return m.AddedNotifyType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SmsSentRecordsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case smssentrecords.FieldDelete:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelete(v)
		return nil
	case smssentrecords.FieldCreatedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedID(v)
		return nil
	case smssentrecords.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case smssentrecords.FieldNotifyType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNotifyType(v)
		return nil
	}
	return fmt.Errorf("unknown SmsSentRecords numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SmsSentRecordsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(smssentrecords.FieldCreatedAt) {
		fields = append(fields, smssentrecords.FieldCreatedAt)
	}
	if m.FieldCleared(smssentrecords.FieldUpdatedAt) {
		fields = append(fields, smssentrecords.FieldUpdatedAt)
	}
	if m.FieldCleared(smssentrecords.FieldDelete) {
		fields = append(fields, smssentrecords.FieldDelete)
	}
	if m.FieldCleared(smssentrecords.FieldCreatedID) {
		fields = append(fields, smssentrecords.FieldCreatedID)
	}
	if m.FieldCleared(smssentrecords.FieldStatus) {
		fields = append(fields, smssentrecords.FieldStatus)
	}
	if m.FieldCleared(smssentrecords.FieldMobile) {
		fields = append(fields, smssentrecords.FieldMobile)
	}
	if m.FieldCleared(smssentrecords.FieldBizID) {
		fields = append(fields, smssentrecords.FieldBizID)
	}
	if m.FieldCleared(smssentrecords.FieldCode) {
		fields = append(fields, smssentrecords.FieldCode)
	}
	if m.FieldCleared(smssentrecords.FieldContent) {
		fields = append(fields, smssentrecords.FieldContent)
	}
	if m.FieldCleared(smssentrecords.FieldNotifyType) {
		fields = append(fields, smssentrecords.FieldNotifyType)
	}
	if m.FieldCleared(smssentrecords.FieldTemplate) {
		fields = append(fields, smssentrecords.FieldTemplate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SmsSentRecordsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SmsSentRecordsMutation) ClearField(name string) error {
	switch name {
	case smssentrecords.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case smssentrecords.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case smssentrecords.FieldDelete:
		m.ClearDelete()
		return nil
	case smssentrecords.FieldCreatedID:
		m.ClearCreatedID()
		return nil
	case smssentrecords.FieldStatus:
		m.ClearStatus()
		return nil
	case smssentrecords.FieldMobile:
		m.ClearMobile()
		return nil
	case smssentrecords.FieldBizID:
		m.ClearBizID()
		return nil
	case smssentrecords.FieldCode:
		m.ClearCode()
		return nil
	case smssentrecords.FieldContent:
		m.ClearContent()
		return nil
	case smssentrecords.FieldNotifyType:
		m.ClearNotifyType()
		return nil
	case smssentrecords.FieldTemplate:
		m.ClearTemplate()
		return nil
	}
	return fmt.Errorf("unknown SmsSentRecords nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SmsSentRecordsMutation) ResetField(name string) error {
	switch name {
	case smssentrecords.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case smssentrecords.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case smssentrecords.FieldDelete:
		m.ResetDelete()
		return nil
	case smssentrecords.FieldCreatedID:
		m.ResetCreatedID()
		return nil
	case smssentrecords.FieldStatus:
		m.ResetStatus()
		return nil
	case smssentrecords.FieldMobile:
		m.ResetMobile()
		return nil
	case smssentrecords.FieldBizID:
		m.ResetBizID()
		return nil
	case smssentrecords.FieldCode:
		m.ResetCode()
		return nil
	case smssentrecords.FieldContent:
		m.ResetContent()
		return nil
	case smssentrecords.FieldNotifyType:
		m.ResetNotifyType()
		return nil
	case smssentrecords.FieldTemplate:
		m.ResetTemplate()
		return nil
	}
	return fmt.Errorf("unknown SmsSentRecords field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SmsSentRecordsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SmsSentRecordsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SmsSentRecordsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SmsSentRecordsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SmsSentRecordsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SmsSentRecordsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SmsSentRecordsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SmsSentRecords unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SmsSentRecordsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SmsSentRecords edge %s", name)
}
